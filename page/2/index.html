<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="阿巴阿巴QAQ" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     困困
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/images/cg.jpg" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="困困" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/bj2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">困困</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['我是一只小菜鸡呜呜呜~', '', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">a little vegetable chicken</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Java-3异常"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/"
    >Java 3异常</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/" class="article-date">
  <time datetime="2021-04-12T07:04:40.000Z" itemprop="datePublished">2021-04-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="异常-try-…-catch"><a href="#异常-try-…-catch" class="headerlink" title="异常 try … catch"></a>异常 try … catch</h1><p><strong>异常（exception）不是编译错误，是运行错误，编译错误是error，异常是一个对象</strong></p>
<p>异常(Exception)是程序运行过程中发生的事件，该事件可以中断程序指令的正常执行流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExcep_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		A aa = <span class="keyword">new</span> A();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			aa.divide(<span class="number">6</span>,O); <span class="comment">//可能错误的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">catch</span>(ArithmeticExcdption e) <span class="comment">//抓取的异常，e用来接收23行抛出的异常对象，e是接受异常的对象</span></span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">//可以简单理解为输出该异常的具体信息</span></span><br><span class="line">			System.out.printf(<span class="string">&quot;除零错误，你的程序出错啦!除数不能为零，嘿&quot;</span>);</span><br><span class="line">			<span class="comment">//应该怎么做</span></span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		System.out.printf(<span class="string">&quot;今天我很高心，因为我和世界的关系和和谐!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只有放进try才会被捕抓到，程序不会连着抛两个异常</strong></p>
<h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.png"></p>
<ol>
<li>Error是系统错误，程序员无法处理这些异常</li>
<li>Exception是程序员可以捕获并处理的异常</li>
<li>RuntimeException的子类异常是你可以处理也可以不处理的异常</li>
<li>凡是继承自Exception但又不是 RuntimeException子类的异常我们都必须的捕捉并进行处理</li>
<li>不知道异常的名字，可以写Exception ，因为它是所有的异常的父类</li>
</ol>
<p><strong>注意：</strong></p>
<p>​    Java认为放在try里的代码可能不会执行成功，所以m不会赋值成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="title">Excep_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			m=<span class="number">2</span>;</span><br><span class="line">			System.out.printf(<span class="string">&quot;m = %d\n&quot;</span>, m);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Except ion e)</span><br><span class="line">        &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        Systcem.out.printf(<span class="string">&quot;m = %d\n&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Error:<br>由Java虚拟机生成并抛出，包括动态链接失败、虚拟机错误等，<strong>Java程序无法对此错误进行处理。</strong></li>
<li>Runtime Exception:（可不抓也可不抓）<br>.Java虚拟机在运行时生成的异常，如被0除等系统错误、数组下标超范围等，<strong>其产生比较频繁，处理麻烦，对程序可读性和运行效率影响太大</strong>天。因此由系统检测，用户可不做处理，系统将它们交给缺省的异常处理程序（当然，必要时,用户可对其处理)。</li>
<li>Exception:<br>一般程序中可预知的问题，其产生的异常可能会带来意想不到的结果，因此<strong>Java编译器要求Java程序必须捕获或声明所有的非运行时异常</strong></li>
</ul>
<h1 id="为什么需要异常"><a href="#为什么需要异常" class="headerlink" title="为什么需要异常"></a>为什么需要异常</h1><p>例子：从键盘输入整数，不能使用if……else处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.uti1.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExcep_3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in); <span class="comment">//System.in 表示键盘 </span></span><br><span class="line">        i = sc.nextInt();</span><br><span class="line">		System.out.printf(<span class="string">&quot;i= %d\n&quot;</span>, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例1：编程实现把键盘输入的数字赋给整型变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInput_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> i = sc.nextilst();</span><br><span class="line">		System.out.println(<span class="string">&quot;i= &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入的不是合法数字运行结果如下:</p>
<p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E6%8A%A5%E9%94%99.png"></p>
<h2 id="读写错误异常-的处理"><a href="#读写错误异常-的处理" class="headerlink" title="读写错误异常 的处理"></a>读写错误异常 的处理</h2><p>​    本程序出现的问题是无法通过逻辑判断来解决的，Java提供的异常处理机制可以很好的解决这个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">    	&#123;</span><br><span class="line">			sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        	<span class="keyword">int</span> i = sc.nextInt();</span><br><span class="line">			System.out.printf(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    	&#125;</span><br><span class="line">		<span class="keyword">catch</span> (InputMismatchException e)</span><br><span class="line">    	&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;读取错误，程序将终止&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="异常的处理机制-重点"><a href="#异常的处理机制-重点" class="headerlink" title="异常的处理机制(重点)"></a>异常的处理机制(重点)</h1><ul>
<li>当Java程序运行时出现问题时，系统会自动检测到该错误，并立即生成一个与该错误对应的异常对象</li>
<li>然后把该异常对象提交给Java虚拟机</li>
<li>Java虚拟机会自动寻找相应的处理代码来处理这个异常，如果没有找到，则由Java虚拟机做一些简单的处理后，程序被强行终止！</li>
<li>程序员可以自己编写代码来捕捉可能出现的异常，并编写代码来处理相应的异常</li>
</ul>
<h3 id="printStackTrace方法-输出异常信息"><a href="#printStackTrace方法-输出异常信息" class="headerlink" title="printStackTrace方法 输出异常信息"></a>printStackTrace方法 输出异常信息</h3><h2 id="可处理可不处理的异常-和-必须得进行处理的异常"><a href="#可处理可不处理的异常-和-必须得进行处理的异常" class="headerlink" title="可处理可不处理的异常 和 必须得进行处理的异常"></a>可处理可不处理的异常 和 必须得进行处理的异常</h2><h3 id="常见异常之空指针异常"><a href="#常见异常之空指针异常" class="headerlink" title="常见异常之空指针异常"></a>常见异常之空指针异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNullPointerException</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		Person p = <span class="keyword">null</span>;</span><br><span class="line">		System.out.printin(p.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png"></p>
<h3 id="常见异常之下标越界异常"><a href="#常见异常之下标越界异常" class="headerlink" title="常见异常之下标越界异常"></a>常见异常之下标越界异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestlndexOutof</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		String friends[]=&#123;<span class="string">&quot;Lisa&quot;</span>,<span class="string">&quot;Bily&quot;</span>,<span class="string">&quot;Kessy&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">			System.out.println(friends[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;\nthis is the end&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png"></p>
<h1 id="处理异常的两种方式"><a href="#处理异常的两种方式" class="headerlink" title="处理异常的两种方式"></a>处理异常的两种方式</h1><h2 id="第一种-throw抛出"><a href="#第一种-throw抛出" class="headerlink" title="第一种 throw抛出"></a>第一种 throw抛出</h2><p>有些异常不处理编译会抛出，f()没有对异常进行处理，交给被调用者处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//public void f()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">		<span class="comment">//throw new IOException(); //throw 抛出异常，交给mian处理</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExcep_5</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="comment">//throws IOException</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A aa = <span class="keyword">new</span> A();</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			aa.f();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>throw将异常抛出函数不处理</strong></p>
<h2 id="第二种本函数处理"><a href="#第二种本函数处理" class="headerlink" title="第二种本函数处理"></a>第二种本函数处理</h2><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><h2 id="异常处理步骤"><a href="#异常处理步骤" class="headerlink" title="异常处理步骤"></a>异常处理步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	可能出现异常的代码块</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionName1 e)</span><br><span class="line">&#123;</span><br><span class="line">	当产生ExceptionName1异常时的处理措施</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionName2 e)</span><br><span class="line">&#123;</span><br><span class="line">	当产生ExceptionName2异常时的处理措施</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">	无论是否捕捉到异常都必须处理的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Finally的作用"><a href="#Finally的作用" class="headerlink" title="Finally的作用"></a>Finally的作用</h2><ul>
<li>无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛弃的异常的类型一致，<strong>finally中的代码一定会得到执行</strong></li>
<li>finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其他部分以前，<strong>能够对程序的状态作统一的管理</strong></li>
<li>通常在finally语句中可以<strong>进行资源的清除工作，如关闭打开的文件、删除临时文件等</strong></li>
</ul>
<h1 id="自定义异常-和-throws常见错误解析"><a href="#自定义异常-和-throws常见错误解析" class="headerlink" title="自定义异常 和 throws常见错误解析"></a>自定义异常 和 throws常见错误解析</h1><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ul>
<li><p>throw用来抛出异常</p>
</li>
<li><p>格式：<br>throw new异常名(参数);</p>
</li>
<li><p>假设f方法抛出了A异常，则f方法有两种方式来处理A异常</p>
<ul>
<li><ol>
<li>throws A<br> 谁调用f方法，谁处理A异常，f方法本身不处理A异常</li>
<li>try{ ..….} catch () { …..….}<br> f方法本身自己来处理A异常</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>要抛出的异常必须得是Throwable的子类</strong></p>
</li>
</ul>
<p>自定义异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Throwable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IOException(); <span class="comment">//throw 抛出异常</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> B</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> B();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void f() throws A</span><br><span class="line">&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    thows A表示调用f方法时f方法可能会抛出A类异常，建议您调用f方法时最好对f方法可能抛出的A类异常进行捕捉</p>
<ul>
<li><p><strong>throws A不表示f方法一定会抛出A类异常</strong></p>
<p>throws A,f方法也可以不抛出A类异常</p>
</li>
<li><p><strong>throws A不表示调用f方法时,必须的对A异常进行捕捉</strong></p>
<ul>
<li>假设A是RuntimeException子类异常<pre><code>由于RuntimeException的子类异常可以处理也可以不处理，所以编译器允许你调用f方
</code></pre>
法时，对f方法抛出的RuntimeException子类异常不进行处理</li>
</ul>
</li>
<li><p><strong>强烈建议你</strong></p>
<ul>
<li><strong>对throws出的所有异常进行处理</strong></li>
<li><strong>如果一个方法内部己经对A异常进行了处理,则就不要再throws A</strong></li>
</ul>
</li>
</ul>
<p>例如</p>
<p><img src><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/thrwos1.png" alt="thrwos1"></p>
<p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/throws2.png"></p>
<p>​    <strong>自己设计f方法，内部写有throw，函数名就要写throws。如果不是设计f方法，而是调用f方法，看到写了throws不管是否要捕获，都要自己进行捕获</strong></p>
<p>​    <strong>自己定义的异常要继承Exception</strong></p>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><p>异常抛出的是一个对象</p>
<p>抛出代码要怎么写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new DivisorIsZeroExceptior();</span><br></pre></td></tr></table></figure>



<p>Throwa 只能抛出类，表示一个声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> DivisorIsZeroException</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==b)</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> DivisorIsZeroException(<span class="string">&quot;除数不能为零!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (DivisorIsZeroException e)</span><br><span class="line">        &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span>==b)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> DivisorIsZeroException(<span class="string">&quot;除数不能为零!&quot;</span>):</span><br><span class="line">	<span class="keyword">int</span> m=a/b;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="小剧场"><a href="#小剧场" class="headerlink" title="小剧场"></a>小剧场</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void f() throws A</span><br><span class="line">&#123;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br><span class="line">void g()</span><br><span class="line">&#123;</span><br><span class="line">	f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>throws A可以不抛异常，g可以直接调用不需要捕获A异常</p>
<ol>
<li><p>Throws A不表示f一定抛出A</p>
</li>
<li><p>Throws A不表示g调用f时一定要捕获A</p>
<p>​    要看A是什么异常，如果A是可处理可不处理的异常，g就不需要捕获，如果是必须处理g调用f()时，要写try</p>
</li>
</ol>
<p>3.果A是必须处理的异常，内部不一定要捕获</p>
<h1 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h1><ul>
<li>所有的catch只能有一个被执行</li>
<li>有可能所有的catch都没有执行</li>
<li><strong>先catch子类异常再catch父类异常</strong><br>■如果先catch父类异常再catch子类异常，则编译时会报错</li>
<li>catch与catch之间是不能有其他代码的</li>
<li><strong>重写方法抛出异常的范围不能大于被重写方法排除的异常范围</strong></li>
</ul>
<h2 id="异常的范围"><a href="#异常的范围" class="headerlink" title="异常的范围"></a>异常的范围</h2><p>​    A,B,C 三个异常A是父类，B继承A，C继承B，A,B,C三个异常都可以被A捕获，因为A是父类，所以<strong>先catch子类异常再catch父类异常</strong></p>
<h1 id="异常的优点"><a href="#异常的优点" class="headerlink" title="异常的优点"></a>异常的优点</h1><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E6%B2%A1%E6%9C%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E7%A8%8B%E5%BA%8F.png"></p>
<p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E6%9C%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.png"></p>
<p>以常规方法处理错误存在的问题<br>■ 观察前面的程序，大家会发现大部分精力花在出错处理上了<br>■ 只把能够想到的错误考虑到，对以外的情况无法处理<br>■ 程序可读性差，大量的错误处理代码混杂在程序中<br>■ 出错返回信息量太少，无法更确切的了解错误状况或原因</p>
<p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E6%9C%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.png"></p>
<h2 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>■ 强制程序员考虑程序的安全性与健壮性<br>■ 增强了程序员对程序的可控性<br>■ 有利于代码的调试<br>■ 把错误处理代码从常规代码中分离出来</p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>■ 异常并不一定能够使程序的逻辑更清晰<br>    因为有时我们必须得编写代码捕捉异常，所以可能会导致程序的逻辑非常混乱<br>■ 异常并不能解决所有的问题</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-2包"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/09/Java-2%E5%8C%85/"
    >Java 2包</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/09/Java-2%E5%8C%85/" class="article-date">
  <time datetime="2021-04-09T03:01:17.000Z" itemprop="datePublished">2021-04-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="包声明-package"><a href="#包声明-package" class="headerlink" title="包声明 package"></a>包声明 package</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名“TestPackage.java&quot;</span></span><br><span class="line"><span class="keyword">package</span> zhangsan.lisi; <span class="comment">//1行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPackage</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> statit <span class="keyword">void</span> <span class="title">main</span><span class="params">(String0 args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> A().print(); </span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;AAAAA&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>package语句必须得是第一条语句</li>
<li>package zhangsan.lisi表示:<br> 把该文件中所有的类放入zhangsan.lisi这个包中（把编译的东西放进zhangsan文件夹下的lisi的文件夹下），并且该文件中所有的<strong>类真正名字将是包名和类名的组合</strong></li>
<li>如:类TestPackage 的名字将变成zhangsan.isl.TestPackage，而不再是TestPackage</li>
<li>编译时建议使用 javac-d . TestPackage.java 尽量不要使用 javac TestPackage.java 因为后者要自己手动建立包目录</li>
<li>如果不在当前路径下运行程序，则必须保证class文件的最上层目录的父目录位于classpath下</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zhangsan.lisi;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;AAAA\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> A().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用javac 需要手动建立包成</p>
<p><strong>真正的类名是 包层+类名</strong></p>
<p>建议使用命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d 启动类名.java</span><br></pre></td></tr></table></figure>



<h4 id="java-zhangsan-lisi-TestPackage解析"><a href="#java-zhangsan-lisi-TestPackage解析" class="headerlink" title="java zhangsan.lisi.TestPackage解析"></a>java zhangsan.lisi.TestPackage解析</h4><p>​    先检测当前目录下是否有zhangsan/isi这个包(包即文件夹)，如果有,再检测该包下是否有zhangsan.lisiTestPackage 这个类，如果没有，编译器将再去classpath设置的路径中依次查找。如果都查找失败，则运行时出错</p>
<p>​    设置变量设置到包层里是错误的，程序找不到包层，设置环境变量要设置最上层</p>
<h1 id="同包-和-不同包-类的相互访问"><a href="#同包-和-不同包-类的相互访问" class="headerlink" title="同包 和 不同包 类的相互访问"></a>同包 和 不同包 类的相互访问</h1><ul>
<li>包相当于一个文件夹</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.java文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     	System.out.println (<span class="string">&quot;AAAA&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B.java文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     	aa = <span class="keyword">new</span> A();</span><br><span class="line">        aa.f();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Javac A.java B.java</span><br><span class="line">java B</span><br><span class="line">----------------------------------</span><br><span class="line">输出结果</span><br><span class="line">AAAA</span><br></pre></td></tr></table></figure>

<p>附注：</p>
<p>​    因为类A和类B默认是在同一个无名的包中所以彼此可以相互访问，只要是非私有成员都可以被同包的另二个类访问</p>
<h1 id="不同包类的相互访问"><a href="#不同包类的相互访问" class="headerlink" title="不同包类的相互访问"></a>不同包类的相互访问</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名 A.java</span></span><br><span class="line"><span class="keyword">package</span> zhangsan.lisi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;AAAAA&quot;</span>);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件名 B.java</span></span><br><span class="line"><span class="keyword">package</span> com.ruide;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		zhangsan.lisi.A aa= <span class="keyword">new</span> zhangsan.lisi.A();</span><br><span class="line">        aa.ma();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独编译时必须的先编译A.java,后编译B.jva，否则会出错建议两个文件一起编译</p>
<p>命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	javac -d . A.java B.java</span><br><span class="line">或</span><br><span class="line">	javac -d . B.java A.java</span><br></pre></td></tr></table></figure>

<p><strong>只有公有类才能被另一个包访问</strong></p>
<h2 id="不同访问修饰符"><a href="#不同访问修饰符" class="headerlink" title="不同访问修饰符"></a>不同访问修饰符</h2><ul>
<li>在同一个包中只有私有的不能被另一个类访问，也只有私有的不能被继承</li>
<li>在不同包没有任何关系的两个类，只有public类的public成员才可以被另一个类访问</li>
<li>在不同包中有继承关系的两个类，只有public类的public成员和public类的protected成员可以被另一个包中的子类在内部使用，但是在子类的外部，通过子类对象名只能访问父类的public成员</li>
</ul>
<h1 id="使用不同包类的方式"><a href="#使用不同包类的方式" class="headerlink" title="使用不同包类的方式"></a>使用不同包类的方式</h1><p><strong>第一种：使用一个类的全名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruide;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		zhangsan.lisi.A aa = <span class="keyword">new</span> zhangsan.lisi.A();</span><br><span class="line">        aa.ma();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二种：使用import语句导入一个包中所有的类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruide;</span><br><span class="line"><span class="keyword">import</span> zhangsan.lisi.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		A aa = <span class="keyword">new</span> A();</span><br><span class="line">        aa.ma();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第三种：使用import语句导入一个包中特定的类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruide;</span><br><span class="line"><span class="keyword">import</span> zhangsan.lisi.A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		A aa = <span class="keyword">new</span> A();aa.ma();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意:导入父包的类并不会自动导入子包的类</strong><br>    如: import zhangsan.*****；只会导入zhangsan这个包下的所有类，并不会导入zhangsan子包lisi这个包中的类<br>    考虑: import java.awt.*****；和 import java.awt.event.*；的区别</p>
<h3 id="不同包之间的相互方问"><a href="#不同包之间的相互方问" class="headerlink" title="不同包之间的相互方问"></a>不同包之间的相互方问</h3><p>不是内部类，不能添加修饰符，要加就加公有，要不什么都不加</p>
<p>两个不同的包，只能访问包的公有类，调用的只能是类的公有方法</p>
<p>不同包继承父类也是只能访问公有的</p>
<h1 id="jar包的生成-avi"><a href="#jar包的生成-avi" class="headerlink" title="jar包的生成 .avi"></a>jar包的生成 .avi</h1><h2 id="归档工具jar"><a href="#归档工具jar" class="headerlink" title="归档工具jar"></a>归档工具jar</h2><p>​    Java归档工具是JDK中提供的一种多用途的存档及压缩工具，可以将多个文件或目录合并压缩为单个的Java归档文件</p>
<p><strong>jar文件的主要作用：</strong><br>    发布和使用类库<br>    便于资源的组合和管理</p>
<p>例如：进入文件夹，把当前文件夹打一个架包，T是名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\桌面\java\&gt;jar cvf T.jar *</span><br></pre></td></tr></table></figure>

<p>架包不能双击打开，除非有菜单页面，可以用压缩包软件打开</p>
<h2 id="Jar使用举例"><a href="#Jar使用举例" class="headerlink" title="Jar使用举例"></a>Jar使用举例</h2><p>格式</p>
<ul>
<li><code>jar -cvf 要生成的包名.jar *</code></li>
</ul>
<p>举例</p>
<ul>
<li><p><code>jar -cvf c.jar *</code>  <strong>一般使用第一个</strong></p>
<p>功能：把当前路径下所有的文件即文件夹下所有的内容打包成c.jar</p>
</li>
<li><p><code>jar -tf c.jar</code></p>
<p>功能：在DOS下显示c.jar这个包解压后的文件的内容</p>
</li>
<li><p><code>jar -xf d:\1\c.jar</code></p>
<p>功能：把d:\1\c.jar这个文件中的内容解压到当前目录下</p>
</li>
</ul>
<h2 id="如何使用jar包中的类"><a href="#如何使用jar包中的类" class="headerlink" title="如何使用jar包中的类"></a>如何使用jar包中的类</h2><ul>
<li>假设现在有一个T.jar包，要想在任何目录下都可以访问T.jar包中的类，则设置classpath时，必须把包名T.jar也设置进去，因为T.jar也相当于一个目录</li>
<li>如在d:\share\java下有一个T.jar，则classpath必须设置为d:\share\java\T.jar，不能设置为d:\share\java，也不能设置成d:\share\java\T，否则在非当前目录下是无法访问T.jar包中的类的</li>
<li>Jar包也是一个目录</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> baichi.shabi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//可以把protected改为public,但却不能改为private,也不能在void前面什么都不写</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;AAAAin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aa = <span class="keyword">new</span> A();</span><br><span class="line">		aa.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zhangsan.lisi;</span><br><span class="line"><span class="keyword">import</span> baichi.shabi.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">		System.out.printf(<span class="string">&quot;GGGGin&quot;</span>);)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		B bb = <span class="keyword">new</span> B();</span><br><span class="line">        bb.g(); <span class="comment">//OK</span></span><br><span class="line">		<span class="comment">//bb.f(); //error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本程序证明了:<br>    在不同包中有继承关系的两个类，只有public类的public成员和public类的protected成员可以被另一个包中的子类在内部使用，但是在子类的外部，通过子类对象名只能访问父类的public成员</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-1基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/09/Java-1%E5%9F%BA%E7%A1%80/"
    >Java 1基础</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/09/Java-1%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2021-04-09T02:24:20.000Z" itemprop="datePublished">2021-04-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>​        数值类型：</p>
<p>​                整数类型(byte, short,int,long)    </p>
<p>​                浮点类型（float,double)</p>
<p>​        字符型（char）</p>
<p>​        布尔型(boolean)</p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>​    类(class)    接口（interface)    数组</p>
<h1 id="输出数据的格式控制"><a href="#输出数据的格式控制" class="headerlink" title="输出数据的格式控制"></a>输出数据的格式控制</h1><table>
<thead>
<tr>
<th align="center">输出控制符</th>
<th align="center">针对的数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%d</td>
<td align="center">int, long int , short, byte</td>
</tr>
<tr>
<td align="center">%x，%#x，%X，%#X</td>
<td align="center">int, long int</td>
</tr>
<tr>
<td align="center">%c</td>
<td align="center">char</td>
</tr>
<tr>
<td align="center">%f</td>
<td align="center">float，double</td>
</tr>
<tr>
<td align="center">%s</td>
<td align="center">String</td>
</tr>
</tbody></table>
<p><strong>注意：</strong></p>
<p>​    在java中没有%ld和%If,比如float和double都用%f输出，这是与C/C++不同的</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="1-整型常量"><a href="#1-整型常量" class="headerlink" title="1.整型常量"></a>1.整型常量</h4><p>十进制(12)，十六进制(0x12)，八进制（012)<br>    <strong>一个常量整数默认是int类型，如果数字过大，则必须的在末尾加L，否则会出错!</strong></p>
<p>例如：</p>
<pre><code> long i = 9223372036854775807; //error  编译报错,提示数字过大，
</code></pre>
<p>​        但是如果改为:long i= 9223372036854775807L;   就可以了</p>
<h4 id="2-浮点常量"><a href="#2-浮点常量" class="headerlink" title="2.浮点常量"></a>2.浮点常量</h4><p>​    一个实数默认是double类型，如果希望一个<strong>实数是float类型，可以在数字后面加f(F)</strong><br>​        将一个double类型数值赋给float类型变量，编译是会报错例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float x &#x3D; 2.2; &#x2F;&#x2F;error</span><br><span class="line">float x &#x3D; 2.2f; &#x2F;&#x2F;OK</span><br></pre></td></tr></table></figure>

<h4 id="3-字符常量"><a href="#3-字符常量" class="headerlink" title="3.字符常量"></a>3.字符常量</h4><p>​    必须用单引号括起来</p>
<p>​    Java中字符和字符串都用Unicode编码表示</p>
<p>​    在Uniede编码中一个字符占两个字节  \u表示unicode编码</p>
<p>​        ‘a’ ‘B’ ‘\n’ ‘\u0030’</p>
<h4 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4.布尔类型"></a>4.布尔类型</h4><p>​    用boolean表示，不能写成bool<br>​    布尔型数据<strong>只有两个值true和false</strong>，且它们不对应于任何整数值</p>
<p>​    布尔型变量的定义如:</p>
<p>​        boolean b = trye;</p>
<p><strong>注意：</strong></p>
<p>​    <strong>lf  while  for  中进行真假判断时只能使用逻辑表达式</strong></p>
<pre><code>## 数据类型的转换
</code></pre>
<ul>
<li><p>不能对boolean类型进行类型转换。</p>
</li>
<li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
<li><p>整型、实型、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算，转换从低级到高级:</p>
<p>低 ———————————&gt; 高</p>
<p>byte -&gt; char -&gt; int-&gt; long -&gt; float -&gt; double</p>
</li>
</ul>
<h2 id="算术运输符"><a href="#算术运输符" class="headerlink" title="算术运输符"></a>算术运输符</h2><ul>
<li>+可以表示数值的相加</li>
<li>+可以表示字符串的联接<pre><code>如:“123”+&quot;“abc”的结果是“123abc”
</code></pre>
</li>
<li>+还能把非字符串转换成字符串<pre><code>如:“&quot;+123;的结果是“x123”
</code></pre>
</li>
<li>分析 System.out.println(‘a’+1)与System.out.println(“”+’a’+1)的区别</li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li><strong>把一类事物的静态属性和动态可以执行的操作组合在一起</strong>所得的这个概念就是类</li>
<li>类是抽象的，用来模拟一类事物，是一个概念</li>
<li>一旦被定义，类的概念就永远存在了</li>
</ul>
<h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> aqe;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;oh,my god!I am&quot;</span> + age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    age是类的属性,也叫类数据成员，也叫字段,也叫域。</p>
<p>​    shout是方法,也叫类的成员函数<br>​    shout方法可以直接访问同一个类中的age变量。</p>
<h2 id="内存分配问题"><a href="#内存分配问题" class="headerlink" title="内存分配问题"></a>内存分配问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestHemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> stat ic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	aa </span>= <span class="keyword">new</span> A(); <span class="comment">//(A*)malloc(sizeof(A));</span></span><br><span class="line">		<span class="comment">//new A(); 在堆中动态分配一块区域，被当做了A对象</span></span><br><span class="line">		<span class="comment">//aa本身的内存是在栈中分配的</span></span><br><span class="line">		<span class="comment">//堆中内存的地址付给了aa</span></span><br><span class="line">		<span class="comment">//aa指向堆中的内存,aa代表了堆中的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h1><p>​    在一个类的内部，所有的成员可以相互访问,访问控制符是透明的；<strong>访问控制符是针对外部访问</strong>而言的</p>
<p><strong>外部访问包括两种方式</strong></p>
<ul>
<li>通过类名访问类内部的成员</li>
<li>通过类对象名访问类内部成员</li>
</ul>
<h2 id="public-公有"><a href="#public-公有" class="headerlink" title="public 公有"></a>public 公有</h2><p>​    可以通过外部访问方式访问类内部的public成员</p>
<h2 id="protect-保护"><a href="#protect-保护" class="headerlink" title="protect 保护"></a>protect 保护</h2><p>​    <strong>不可以</strong>通过外部访问方式访问类内部的priavate成员</p>
<h2 id="默认【即不加任何修饰符】"><a href="#默认【即不加任何修饰符】" class="headerlink" title="默认【即不加任何修饰符】"></a>默认【即不加任何修饰符】</h2><h2 id="private-私有"><a href="#private-私有" class="headerlink" title="private 私有"></a>private 私有</h2><p>​    一个类的外部：通过 <strong>类对象名.私有成员名</strong> 的方式是无法访问该对象中的私有成员</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><strong>定义：</strong></p>
<p>​    名字和类名一样<br>​    无返回值</p>
<p><strong>注意事项：</strong><br>    一个类对象只能调用一个构造方法<br>    一个类至少有一个构适方法<br>    如果自己定义了构造方法，编译器将不再提供默认的够方法</p>
<p><strong>同类名相同</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i = a;</span><br><span class="line">	j = b;</span><br><span class="line">	system.out.printf(”无参构造函数被调用了! \n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数的返回值问题"><a href="#构造函数的返回值问题" class="headerlink" title="构造函数的返回值问题"></a>构造函数的返回值问题</h2><ul>
<li>在一个类中可以定义多个函数名与类名相同但却有返回值的函数，返回值为void或int或double都可以，这些有返回值的函数只要能满足重载特点，就可以同时存在一个类中，不过要注意:这些有返回值的函数(包括返回值为void的函数)都不是构造函数，都不会被类对象自动调用</li>
<li>当然也可以定义多个没有任何返回值的函数，注意连void都不可以加，这些函数才是构造函数,无返回值的函数才会被对象自动调用</li>
<li>如果定义了有返回值并且方法名与类名相同的方法，程序并不会报错，但容易产生歧义，所以<strong>强烈建议不要在构造方法前面加返回值（构造函数与类名相同）</strong></li>
</ul>
<h2 id="构造函数数据成员的赋值问题"><a href="#构造函数数据成员的赋值问题" class="headerlink" title="构造函数数据成员的赋值问题"></a>构造函数数据成员的赋值问题</h2><p>​    当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。</p>
<p><strong>局部变量没有初始化就是垃圾值</strong> <strong>，局部变量编译器是不会自动进行初始化的，java要求所有的局部变量在使用之前都<code>必须的初始化</code></strong></p>
<p><strong>类的属性没有初始化会自动建立默认值</strong></p>
<table>
<thead>
<tr>
<th>成员变量类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float   double</td>
<td>0.0F  0.0D</td>
</tr>
<tr>
<td>char  boolean</td>
<td>‘\u000’(表示为空)   False</td>
</tr>
<tr>
<td>A1l ref erence type</td>
<td>Null</td>
</tr>
</tbody></table>
<ul>
<li>如果在定义的时候不初始化，则它的值是系统自动分配好的默认值!</li>
<li>如果在定义的同时赋初值，则是可以的， 也就是说该值是生效的.注意在C++中则不可以，在C++中一个类的数据成员不能在定义的同时初始化，它只能在构造函数中初始化</li>
<li>如果在定义的同时赋初值，当然生效，但如果在构造函数中又改变了定义时赋的初值，则该数据成员最终的值就是构造函数中修改之后的那个值,因为:</li>
<li><strong>系统会先执行定义时赋的初值，然后再执行构造函数中赋的初值</strong></li>
</ul>
<h1 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h1><p>​    同名的函数通过<strong>不同的形参</strong>做类似的事情，这就叫函数的重载</p>
<p><strong>函数重载要求</strong><br>    1.函数的形参个数<br>    2.函数的形参顺序<br>    3.函数的形参数据类型<br>■这三个至少有一个是不一样的</p>
<p>如果两个函数只是函数的返回值不一样，其他都一样，这构不成函数的重载，并且编译时会报错!</p>
<h1 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h1><ul>
<li>是一个系统隐含的指针被自动附加在非静态的成员函数参数列表中</li>
<li>当前时刻，哪个对象<strong>调用该函数</strong>，那么this就指向当前调用该函数的对象，系统会自动在该函数的参数列表中添加一个隐藏的this指针，并且把调用该函数的对象的地址赋给this指针，这样一来，在函数的内部通过this就可访问当前正在调用该函数的对象的成员。</li>
<li>静态函数内部，没有this指针</li>
<li>一个对象只含有属性的空间，n个对象公共一份方法的拷贝</li>
</ul>
<p>例子：TestThis1.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		i=j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;i=&quot;</span>+ i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		A aa1 = <span class="keyword">new</span> A(<span class="number">5</span>);</span><br><span class="line">		A aa2 = <span class="keyword">new</span> A(<span class="number">8</span>);</span><br><span class="line">		aa1.show0;</span><br><span class="line">		aa2.show0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    aa1和aa2 在内存中分别有各自的数据成员i；但是aa1和aa2公用show()方法，show方 法如何知道输出的i应该是哪那个对象中的i？<br>​    实际上每个非static方法中都隐含这一个this指针，指向当前正在调用该方法的对象</p>
<h1 id="静态static"><a href="#静态static" class="headerlink" title="静态static"></a>静态static</h1><p>​    属性i是属于类本身，或者讲：没有对象，我们仍然可以直接通过类名的方式访问该类内部的static属性</p>
<p>​    static只是表明了该成员具有了可以通过类名访问的潜在特征但是否可以通过类名访问，还必须满足一个条件：该成员必须是非private</p>
<p>​    静态方法不能访问非静态成员</p>
<p>​    非静态方法可以访问静态成员</p>
<p>创建新对象时属性是在不同空间但是类方法是公用的，静态方法没有this指针</p>
<p>Static可以修饰普通方法不能修饰构造方法，构造方法如果是私有private的就不能new出对象</p>
<ul>
<li>一个类的属性可以是个类对象</li>
</ul>
<p>例子：创建只有一个对象的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> A aa = <span class="keyword">new</span> A(); <span class="comment">//aa是否是A对象的属性创建对象  创建对象</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">A</span><span class="params">()</span>  <span class="comment">//私有不能new出新对象</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getA</span><span class="params">()</span> <span class="comment">//访问接口 static 一定不能省略</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> aa;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>静态成员属于类本身的，而不是属于对象，被类的所有对象所共有</p>
</li>
<li><p><strong>即便不创建对象，也可以使用类本身的静态成员</strong></p>
</li>
<li><p>静态成员分为</p>
<pre><code>静态数据成员
静态方法成员
</code></pre>
</li>
<li><p>使用静态成员的两种方法</p>
<pre><code>类名.静态成员名
类对象名.静态成员名
</code></pre>
</li>
<li><p>编写使用静态变量统计一个类产生的实例对象的个数的程序</p>
</li>
<li><p><strong>在静态方法里只能直接调用同类中其它的静态成员(包括变量和方法)，而不能直接访问类中的非静态成员</strong>。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才<br>可使用，而静态方法在使用前不用创建任何对象</p>
</li>
<li><p><strong>静态方法不能以任何方式引用this和super关键字</strong>。与上面的道理一样，因为静态方法在使用前不用创建任何实例对象，当静态方法被调用时，this所引用的对象根本就没有产生。</p>
</li>
<li><p>静态方法只能访问类的静态成员，但<strong>非静态方法却可以访问类中所有成员，包括静态成员</strong></p>
</li>
</ul>
<p>例子：</p>
<p>本程序证明了：</p>
<p>​    只有非private的static成员才可以通过类名的方式访问;</p>
<p>​    static只是表明了该成员具有了可以通过类名访问的潜在特征</p>
<p>​    但是否可以通过类名访问，还必须满足-个条件:该成 员必须是非private</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i= <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">&quot;2009年5月29日15:15:50\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStatic_4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//A.f(); //error</span></span><br><span class="line">		<span class="comment">//A.i= 22; //error</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承  extends"></a>继承  extends</h1><ul>
<li><p>一个新类从已有的类那里获得其已有的属性和方法，这中现象叫类的继承</p>
</li>
<li><p>这个新类被称为子类，也叫派生类，已有的那个类叫做父类，也叫做基类</p>
</li>
<li><p>继承的好处<br>■<strong>代码得到极大的重用</strong><br>■<strong>形成一种类的层次体系结构，为多态创造条件</strong></p>
</li>
<li><p>继承的实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="同包继承权限（重点）"><a href="#同包继承权限（重点）" class="headerlink" title="同包继承权限（重点）"></a>同包继承权限（重点）</h2><ul>
<li>子类的所有方法内部都可以访问父类除私有成员以外的所有成员，所谓子类的所有方法也包括子类的私有方法</li>
<li>通过子类对象名可以访问<br>1.父类除私有成员外的所有成员<br>2.子类本身的除私有成员外的所有成员<br>■附注:私有成员包括私有属性和私有方法</li>
<li>子类可以继承父类除私有成员以外的所有成员</li>
<li><strong>父类的私有成员不可以被子类继承，其他的成员都可以被子类继承</strong></li>
</ul>
<p><strong>1、子类内部可以访问父类非私有的成员</strong><br>        <strong>私有成员无法被子类方法访问</strong><br><strong>2、 通过子类对象名只能访问从父类继承过来的非私有成员</strong><br><strong>总结:</strong><br>    <strong>私有不能被继承</strong><br>    <strong>私有物理上已经被继承过来，只不过逻辑上程序员不能去访问它</strong><br>    <strong>因此继承必须慎重，否则会浪费内存</strong></p>
<h2 id="继承原则"><a href="#继承原则" class="headerlink" title="继承原则"></a>继承原则</h2><p>三种关系</p>
<p>​    1.一般到特殊</p>
<p>​    2.包含</p>
<p>​    3.使用</p>
<h2 id="不同访问修饰符"><a href="#不同访问修饰符" class="headerlink" title="不同访问修饰符"></a>不同访问修饰符</h2><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同包同类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>访问同包不同类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>同包不同类继承</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>不同包继承</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>访问不同包无任何关系的类</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>Java只支持单继承，不允许多重继承。</li>
<li>单继承就是一个类只能有一个父类</li>
<li>多继承就是一个类可以有多个父类</li>
<li>可以有多层继承，即一个类可以继承某一个类的子类，如类B<br>继承了类A，类C又可以继承类B，那么类C也间接继承了类A</li>
<li>子类可以继承父类所有的成员变量和成员方法，但<strong>子类永远无法继承父类的构造方法</strong>。在子类的构造方法中可使用语句**super(参数列表)**调用父类的构造方法。</li>
</ul>
<h2 id="super-子类无法继承父类构造方法"><a href="#super-子类无法继承父类构造方法" class="headerlink" title="super() 子类无法继承父类构造方法"></a>super() 子类无法继承父类构造方法</h2><h2 id="子类访问父类成员的三种方式"><a href="#子类访问父类成员的三种方式" class="headerlink" title="子类访问父类成员的三种方式"></a>子类访问父类成员的三种方式</h2><ul>
<li>在子类内部访问父类成员</li>
<li>通过子类对象名访问父类成员</li>
<li>通过子类的类名访问父类成员</li>
</ul>
<p>经验证，子类通过上述三种方式的任何一种，都无法访问父类私有成员，因此我们可以得出结果:<br>            私有成员无法被子类继承，物理继承但语法无法访问</p>
<p><strong>可以使用super()调用父类构造方法</strong></p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>. i = i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> j;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(i);</span><br><span class="line">        <span class="keyword">this</span>. j = j;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>普通方法中不能调用父类的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//super(i); //普通方法中不能调用父类的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造方法只能调用一个</strong></p>
<p><strong>总结：</strong></p>
<p>1、每个子类构造方法的第一条语句都是隐含地调用super(), 如父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>2、如果显示的写出super()；语句，则必须保证该语句是第一条语句，否则会出错<br>3、super() ;如果不写，则编译器会自动添加，所以此时如果父类没有无参的构造函数就会出错<br>4、既可以显示写super()；前提是父类必须有无参的构造函数<br>    也可以显示写super(实参)；前提是父类必须有帶参的构造函数<br>5、调用父类的构造函数的语句必须借助于super,不能直接写父类的类名，这与c++不同</p>
<p>6、一个构造函数中不能写多个super(参数列表)语句；</p>
<h1 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h1><ul>
<li>方法重写<pre><code>■指在子类中重所定义父类中已有的方法
</code></pre>
</li>
<li><strong>重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型</strong></li>
<li>子类中不允许出现与父类同名同参但不同返回值的方法,如果出现了，编译时会报错</li>
<li>覆盖方法时，<strong>不能</strong>使用比父类中被覆盖的方法<strong>更严格的访问校限【子类权限不能变低（保证多态任何时候可以实现）】</strong></li>
</ul>
<p>重写的意义</p>
<p>​    如果子类对继承自父类的方法不满意，就应该重写父类的方法</p>
<p><strong>注意：</strong></p>
<p>​    方法名和参数列表和返回子必须一样</p>
<p>​    访问权限不能过低</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>同一代码做不一样的事情</p>
<p>多态：不同对象对同一刺激有不同反应</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoly</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A aa = <span class="keyword">new</span>(); <span class="comment">//A是父类</span></span><br><span class="line">	B bb = <span class="keyword">new</span>(); <span class="comment">//B是子类</span></span><br><span class="line"></span><br><span class="line">	aa.f();</span><br><span class="line">	bb.f();</span><br><span class="line">	aa = bb; <span class="comment">// 把bb当做aa来看待,因为子类可以当做父类看待，所以本语旬0K</span></span><br><span class="line">	<span class="comment">//bb = aa; //把aa当做bb来看待,因为父类不能当做子类看待，所以本语句error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类当成父类看，aa保存了这个对象的地址就代表这个对象</p>
<ul>
<li>一个父类的引用类型变量它既可以指向父类对象也可以指向子类对象，它可以根据当前时刻指向的不同，自动调用不同对象的方法，这就是多态</li>
</ul>
<h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><p>利用多态可以实现:<br>        同一段代码做不同事情<br>如:<br>    ■假设A派生出B，B派生出C<br>    ■试着编写一个函数实现调用整个A类族所有对象f方法<br>    ■所谓A类族就是A类及其A的子孙类所形成的一个族群</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoly_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(A aa)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		aa.f(); <span class="comment">//类似于C语言的: (*aa).f();</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		A aa = <span class="keyword">new</span> A();</span><br><span class="line">		B bb = <span class="keyword">new</span> B();</span><br><span class="line">		C cc = <span class="keyword">new</span> C();</span><br><span class="line">		D dd = <span class="keyword">new</span> D();</span><br><span class="line">		</span><br><span class="line">		g(aa);</span><br><span class="line">		g(bb);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>父类不能强制转换为子类，但是先把子类赋给父类就可以强制转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A aa = <span class="keyword">new</span> A();</span><br><span class="line">	B bb = <span class="keyword">new</span> B();</span><br><span class="line">	</span><br><span class="line">	aa = bb;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//bb = aa; //error</span></span><br><span class="line">	bb = (B)aa;</span><br><span class="line">	bb.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多态：aa只能调用父类继承的方法，不能调用子类特有的方法</p>
<h3 id="多态注意事项"><a href="#多态注意事项" class="headerlink" title="多态注意事项"></a>多态注意事项</h3><ul>
<li><strong>子类对象可以直接赋给父类引用，但父类对象在任何情况下都不可以直接赋给子类引用</strong>，因为子类是父类的一种，但父类不是子类的一种,或者讲“子类可以当做父类看待，但父类不可以当做子类看待”,“狗可以当做动物看待，但动物不可以当做狗来看待”</li>
<li>通过父类引用只能访问子类对象从父类继承过来的成员</li>
<li>通过父类引用不能访问子类对象所特有的成员</li>
<li>父类引用永远不可能直接赋给子类引用<ul>
<li><strong>只有在父类引用本身指向的就是一个子类对象时，才可以把父类引用强制转化为子类引用</strong></li>
<li>其他情况下不允许把父类引用强制转化为子类引用，否则运行时会出</li>
</ul>
</li>
</ul>
<h1 id="抽象类-（不能构造事物）"><a href="#抽象类-（不能构造事物）" class="headerlink" title="抽象类 （不能构造事物）"></a>抽象类 （不能构造事物）</h1><ul>
<li>抽象类的由来<pre><code>利用抽象类是为了更好的对类加以分类，就如同人类不但给各种具体植物取了名字还发明了“植物”这个抽象的词对所有具体植物进行归类一样
</code></pre>
</li>
<li>Java用来模拟现实世界，所以也存在抽象类</li>
<li>抽象类通常用来作为一个类族的最顶层的父类，用最底层的类表示现实中的具体事物，用最顶层的类表示该类族所有事物的共性</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有抽象方法的类一定是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//没有方法体的方法叫做抽象方法，抽象方法要求末尾必须得加分号，前面必须得加abstract</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类不一定有抽象方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="抽象方法与抽象类"><a href="#抽象方法与抽象类" class="headerlink" title="抽象方法与抽象类"></a>抽象方法与抽象类</h2><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul>
<li>在定义Java方法时可以只给出方法头,而不给出方法内部实现代码这样的方法称为抽象方法。</li>
<li>凡是没有方法体的方法必须的使用关键字<code>abstract</code>修饰为抽象方法</li>
<li>凡是含有抽象方法的类都必须的声明为抽象类</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>用<code>abstract</code>关键字来修饰一个类时，该类叫做抽象类;</li>
<li>包含抽象方法的类必须声明为抽象类。</li>
<li>但是一个抽象类中却可以不包含任何抽象方法，尽管比较少见</li>
<li>抽象类不一定有抽象方法</li>
<li>有抽象方法的一定是抽象类</li>
</ul>
<p><strong>父类不是抽象类，子类可以是抽象类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>父类是抽象类，子类也是抽象类，如果不是抽象类就要实现它</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbsPoly_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// A aa = new A(); //error 18行</span></span><br><span class="line">        B bb = <span class="keyword">new</span> B(); <span class="comment">//0K</span></span><br><span class="line">		bb.f(); <span class="comment">//OK</span></span><br><span class="line">		A aa; <span class="comment">//23行  OK可以定义一个抽象类的引用，但是不可以定义一个抽象类的对象，所以18行error，本行OK</span></span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="final-最后的类，不能被继承"><a href="#final-最后的类，不能被继承" class="headerlink" title="final  最后的类，不能被继承"></a>final  最后的类，不能被继承</h1><h3 id="final可以修饰"><a href="#final可以修饰" class="headerlink" title="final可以修饰"></a>final可以修饰</h3><ul>
<li>整个类</li>
<li>类中的若干个属性</li>
<li>类中的若干个方法</li>
</ul>
<p><strong>Final修饰整个类，类每个单词的首字母大写</strong><br><strong>■表示该类不能被继承</strong><br><strong>■如果认为一个类己经很完美且不需要定义子类来继承它时，可以使用它</strong><br><strong>■格式:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puplic <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 和 <span class="keyword">final</span> 可以互换</span><br></pre></td></tr></table></figure>



<h3 id="Final修饰类中的若干属性"><a href="#Final修饰类中的若干属性" class="headerlink" title="Final修饰类中的若干属性"></a>Final修饰类中的若干属性</h3><ul>
<li>Final修饰类中的若干属性表示该属性<strong>必须被赋值</strong>并且<strong>只能被赋一次值</strong></li>
<li>初始化方式有两种:(只能选择其中的一种)<ul>
<li>在定义成员变量的同时初始化</li>
<li>在类中所有的构造函数中初始化</li>
</ul>
</li>
<li>注意:<br>一个类的所有普通方法内部都不可以修改final修饰过的成员变量的值</li>
</ul>
<p>例子：表示该方法可以被子类继承，但不可以被子类重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="comment">//如果在public前面加final，则编译时就会报错</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="comment">//重写父类的f方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p><strong>内部类可直接访问外部类属性</strong></p>
<p><strong>我们可以把内部类当做外部类的一个成员</strong></p>
<ul>
<li>内部类定义:<ul>
<li>在A类的内部但是所有方法的外部定义了一个B类，则B类就是A类的<br>内部类,A是B的外部类</li>
</ul>
</li>
<li>内部类访问原则<ul>
<li><strong>内部类的方法可以访问外部类所有的成员</strong></li>
<li><strong>外部类的方法不可以直接访问内部类的成员</strong></li>
</ul>
</li>
<li>内部类的优点:<ul>
<li>可以让一个类方便的访问另一个类中的所有成员</li>
<li>增加程序的安全性,有效避免其他不相关类对该类的访问</li>
</ul>
</li>
<li>何时使用内部类<ul>
<li>如果一个<strong>A类要使用B类的所有成员，并且A类不需要被除B类以外的其他类访问</strong>，则我们应当把A类定义为B类的内部类</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TF</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> TextField tf1，tf2，tf3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyMonitor</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt( tf1.getText() );</span><br><span class="line">        	<span class="keyword">int</span> num2 = Integer.parseInt( tf2.getText() );</span><br><span class="line">            <span class="keyword">int</span> num3 = num1 + num2;</span><br><span class="line">        	tf3.setText(num3 + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h1><ul>
<li>匿名类是一种特殊的内部类</li>
<li>如果在一个方法内部定义了一个匿名类，则该匿名类可以访问<ul>
<li><strong>外部类的所有成员</strong></li>
<li><strong>包裹该匿名类的方法中的所有final类型的局部变量</strong><ul>
<li>注意：非fianl类型的局部变量无法被匿名类访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="创建匿名类的三种方式"><a href="#创建匿名类的三种方式" class="headerlink" title="创建匿名类的三种方式"></a>创建匿名类的三种方式</h2><ul>
<li>继承父类</li>
<li>实现接口</li>
<li>实现抽象类</li>
</ul>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>假设A是接口名</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A()</span><br><span class="line">&#123;</span><br><span class="line">	实现接口中方法的代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>功能：<br>    生成一个实现了A接口的匿名类对象</p>
<h3 id="实现抽象类"><a href="#实现抽象类" class="headerlink" title="实现抽象类"></a>实现抽象类</h3><p>假设A是抽象类</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A()</span><br><span class="line">&#123;·</span><br><span class="line">	实现了A类的所有抽象类的方法代码</span><br><span class="line">	添加自己的方法或属性代码【不建议，因为没有实际意义】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能:<br>    生成一个匿名类，该匿名类<strong>必须得实现了A类的所有抽象方法</strong>，当然该匿名类也可以定义自己的属性和方法</p>
<p><strong>如果A是抽象类，就必须A这个抽象类中所有的抽象方法都实现</strong></p>
<h3 id="创建匿名类之继承父类"><a href="#创建匿名类之继承父类" class="headerlink" title="创建匿名类之继承父类"></a>创建匿名类之继承父类</h3><p>假设A是个类名</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A()</span><br><span class="line">&#123;</span><br><span class="line">    重写了A类的方法代码</span><br><span class="line">	添加自己的属性和法【不建议，因为没有实际意义】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>功能：<br>    生成一个A类的子类对象，该匿名类对象继承了A的所有非private成员</p>
<p>匿名类可以访问包裹该匿名类的这个外部方法的局部变量不过局部变量的类型是final类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWindowf</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果把10行的final去掉，本程序在18行就会报错，</span></span><br><span class="line">        <span class="comment">//因为匿名类只能访问包裹它的方法中的final类型的局部变量</span></span><br><span class="line">        <span class="keyword">final</span> Frame f = <span class="keyword">new</span> Frame(); <span class="comment">//10</span></span><br><span class="line">        f.setSize(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        f.addWindowListener</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">new</span> WindowAdapter()</span><br><span class="line">             &#123;</span><br><span class="line">        		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">        			f.setVisible(<span class="keyword">false</span>); <span class="comment">//18行</span></span><br><span class="line">                    System.exit(-<span class="number">1</span>);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名类的优缺点"><a href="#匿名类的优缺点" class="headerlink" title="匿名类的优缺点"></a>匿名类的优缺点</h3><ul>
<li>如果一个类的语句比较少，逻辑比较简单，而且不经常变动，这个时侯可以使用匿名类</li>
<li>如果一个类包含了很重要的逻辑，将来要经常修改，则这个类就不应该当做匿名类来使用，匿名类会导致代码的混乱</li>
</ul>
<h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口  interface"></a>接口  interface</h1><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>​    就是批象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类，只允许有一些常量，特殊方法，不允许被修改</p>
<h3 id="接口的格式"><a href="#接口的格式" class="headerlink" title="接口的格式"></a>接口的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[public] interface interfaceName [extends SuperInterfaceList]</span><br><span class="line">&#123;</span><br><span class="line">	.....	<span class="comment">//常量定义和方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="详细知识"><a href="#详细知识" class="headerlink" title="详细知识"></a>详细知识</h3><ul>
<li>接口中定义的属性必须是<code>public static final</code>的，而接口中定义的方法则必须是<code>public abstract</code>的，因此这些修饰符可以部分或全部省略</li>
<li>接口中定义的属性的值在实现类中不能被更改</li>
<li>一个类只能实现某个接口，不能继承某个接口</li>
<li>但接口可以继承接口</li>
<li>接口不但可以继承接口，而且<strong>可以继承多个接口</strong>，即接口允许多继承</li>
<li>如果一个类只实现了一个接口的部分方法，则该类必须的声明为抽象类</li>
<li>一个类可以在继承一个父类的同时实现一个或多个接口，但<strong>extends关键字必须的在implements之前</strong></li>
</ul>
<h3 id="接口的实现-implements"><a href="#接口的实现-implements" class="headerlink" title="接口的实现 implements"></a>接口的实现 implements</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span> <span class="params">()</span> <span class="comment">//implements不能改为extends因为类可以继承类，但类不能继承接口,逻辑意义不通，类可以实现接口</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//i=99; //error</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;i = %d\n&quot;</span>，i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p><strong>如果一个类只实现了一个接口的部分方法，则该类必须的声明为抽象类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">void</span> g0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It1</span> //去掉了<span class="title">abstract</span> 就会报错!</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInter_5</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String0 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	System.out.printIn(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>一个类要想实现某接口中的方法时，必须得在方法返回值前加上public</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">void</span> f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//public不能丢，也不能改为其他修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	System.out.printn(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//lt it= new lt(); //error</span></span><br><span class="line">        lt it= <span class="keyword">new</span> A();</span><br><span class="line">        it.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><ul>
<li>通过接口可以实现不相关类的相同行为<pre><code>如:Java规定所有可以完成自我复制功能的类都必须得实现java.lang.Colneable接口，但该接口却是空的，该接口中没有任何内容,目的只是为了起个标志作用
</code></pre>
</li>
<li>接口提供了不同对象进行协作的平台<pre><code>如事件处理
</code></pre>
</li>
<li>接口可以实现多继承,从一定程序上弥补了类只能单继承的缺陷</li>
<li>接口是我们了解-一个类功能的重要途径<pre><code>如: Java整个容器框架就是以接口的方式建立起来的，实现不同接口的类完成的是不同的功能，接口使我们了解一个类功能的重要途径
</code></pre>
</li>
</ul>
<h3 id="接口与抽象类区别"><a href="#接口与抽象类区别" class="headerlink" title="接口与抽象类区别"></a>接口与抽象类区别</h3><ul>
<li>接口中的方法不允许有方法体，但抽象类却允许</li>
<li>Java类不允许多继承，接口却允许多继承<br>■ 接口可以实现多继承，即一个接口可以有多个父类<br>■ 但Java类只允许单继承，即一个类只能有一个父类</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-扫描器V1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/"
    >扫描器V1</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/" class="article-date">
  <time datetime="2021-04-03T15:10:17.000Z" itemprop="datePublished">2021-04-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="目录扫描器"><a href="#目录扫描器" class="headerlink" title="目录扫描器"></a>目录扫描器</h2><p>命令行界面，可显示200和403网页网址</p>
<p><img src="/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/55.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-模块"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/03/26/%E6%A8%A1%E5%9D%97/"
    >模块</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/03/26/%E6%A8%A1%E5%9D%97/" class="article-date">
  <time datetime="2021-03-26T13:25:21.000Z" itemprop="datePublished">2021-03-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="导入模块-import-xx"><a href="#导入模块-import-xx" class="headerlink" title="导入模块 import xx"></a>导入模块 import xx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>​    当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<p>​    类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等</p>
<h3 id="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"><a href="#外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。" class="headerlink" title="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"></a>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</h3><h1 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h1><p>​    Windows确保安装时勾选了<code>pip</code>和<code>Add python.exe to Path</code></p>
<p>​    命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 模块名</span><br></pre></td></tr></table></figure>

<p>​    推荐直接使用<a target="_blank" rel="noopener" href="https://www.anaconda.com/">Anaconda</a>，内置了许多非常有用的第三方库，装上Anaconda，就相当于把数十个第三方模块自动安装好</p>
<h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>​    当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p>
<p>​    默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#39;&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python36.zip&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#39;, ..., &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#39;]</span><br></pre></td></tr></table></figure>

<h4 id="要添加自己的搜索目录，有两种方法："><a href="#要添加自己的搜索目录，有两种方法：" class="headerlink" title="要添加自己的搜索目录，有两种方法："></a>要添加自己的搜索目录，有两种方法：</h4><p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&#39;&#x2F;Users&#x2F;michael&#x2F;my_py_scripts&#39;)</span><br></pre></td></tr></table></figure>

<p>这种方法是在运行时修改，运行结束后失效。</p>
<p>​    第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-迭代器和生成器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/03/26/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/" class="article-date">
  <time datetime="2021-03-26T12:11:48.085Z" itemprop="datePublished">2021-03-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-模块1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/03/26/%E6%A8%A1%E5%9D%971/" class="article-date">
  <time datetime="2021-03-26T12:11:48.061Z" itemprop="datePublished">2021-03-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="导入模块-import-xx"><a href="#导入模块-import-xx" class="headerlink" title="导入模块 import xx"></a>导入模块 import xx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>

<p>​    当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<p>​    类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等</p>
<h3 id="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"><a href="#外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。" class="headerlink" title="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"></a>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</h3><h1 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h1><p>​    Windows确保安装时勾选了<code>pip</code>和<code>Add python.exe to Path</code></p>
<p>​    命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 模块名</span><br></pre></td></tr></table></figure>

<p>​    推荐直接使用<a target="_blank" rel="noopener" href="https://www.anaconda.com/">Anaconda</a>，内置了许多非常有用的第三方库，装上Anaconda，就相当于把数十个第三方模块自动安装好</p>
<h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>​    当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p>
<p>​    默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#39;&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python36.zip&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#39;, ..., &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#39;]</span><br></pre></td></tr></table></figure>

<h4 id="要添加自己的搜索目录，有两种方法："><a href="#要添加自己的搜索目录，有两种方法：" class="headerlink" title="要添加自己的搜索目录，有两种方法："></a>要添加自己的搜索目录，有两种方法：</h4><p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&#39;&#x2F;Users&#x2F;michael&#x2F;my_py_scripts&#39;)</span><br></pre></td></tr></table></figure>

<p>这种方法是在运行时修改，运行结束后失效。</p>
<p>​    第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-函数式编程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/03/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2021-03-26T12:11:48.048Z" itemprop="datePublished">2021-03-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><p>Q：函数本身赋值给变量呢？</p>
<p>A：函数本身也可以赋值给变量，即：变量可以指向函数。</p>
<p>​    函数名也是变量，把函数名指向其他对象，函数名()就不能执行函数体</p>
<h2 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h2><p>​    一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<p>一个最简单的高阶函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">    return f(x) + f(y)</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，根据函数定义，我们可以推导计算过程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; -5</span><br><span class="line">y &#x3D; 6</span><br><span class="line">f &#x3D; abs</span><br><span class="line">f(x) + f(y) &#x3D;&#x3D;&gt; abs(-5) + abs(6) &#x3D;&#x3D;&gt; 11</span><br><span class="line">return 11</span><br></pre></td></tr></table></figure>



<h1 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h1><p>​    <code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r &#x3D; map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure>

<p>把这个list所有数字转为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</span><br></pre></td></tr></table></figure>



<p>​    <code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数</p>
<p>对一个序列求和，就可以用<code>reduce</code>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p>当然求和运算可以直接用Python内建函数<code>sum()</code>，没必要动用<code>reduce</code>。</p>
<p>但是如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>，<code>reduce</code>就可以派上用场：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])</span><br><span class="line">13579</span><br></pre></td></tr></table></figure>





<h1 id="filter-筛选"><a href="#filter-筛选" class="headerlink" title="filter()  筛选"></a>filter()  筛选</h1><p>​    <code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p>
<p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure>

<p>把一个序列中的空字符串删掉，可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def not_empty(s):</span><br><span class="line">    return s and s.strip()</span><br><span class="line"></span><br><span class="line">list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))</span><br><span class="line"># 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br></pre></td></tr></table></figure>



<h1 id="sorted-排序"><a href="#sorted-排序" class="headerlink" title="sorted  排序"></a>sorted  排序</h1><p><code>sorted()</code>函数就可以对list进行排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])</span><br><span class="line">[-21, -12, 5, 9, 36]</span><br></pre></td></tr></table></figure>

<p>​    以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key&#x3D;abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure>

<p><strong>字符串排序</strong></p>
<p>​    默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面。</p>
<p>给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key&#x3D;str.lower)</span><br><span class="line">[&#39;about&#39;, &#39;bob&#39;, &#39;Credit&#39;, &#39;Zoo&#39;]</span><br></pre></td></tr></table></figure>

<p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key&#x3D;str.lower, reverse&#x3D;True)</span><br><span class="line">[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]</span><br></pre></td></tr></table></figure>



<h1 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h1><p>​    高阶函数除了可以接受函数作为参数外，还可以<strong>把函数作为结果值返回</strong></p>
<p>​    返回求和的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax &#x3D; 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax &#x3D; ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</span><br></pre></td></tr></table></figure>

<p>调用函数<code>f</code>时，才真正计算求和的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p>​    在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为<strong>闭包</strong></p>
<p><strong>每次调用都会返回一个新的函数</strong></p>
<h3 id="返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。"><a href="#返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。" class="headerlink" title="返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。"></a>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</h3><p>​    如果一<strong>定要引用循环变量</strong>怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs &#x3D; []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br></pre></td></tr></table></figure>

<p>再看看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1, f2, f3 &#x3D; count()</span><br><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">9</span><br></pre></td></tr></table></figure>



<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>​    关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p>
<p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p>
<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;</span><br><span class="line">&gt;&gt;&gt; f(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p>同样，也可以把匿名函数作为返回值返回，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def build(x, y):</span><br><span class="line">    return lambda: x * x + y * y</span><br></pre></td></tr></table></figure>



<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><p>​    <code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）</p>
<p>​    <code>int()</code>函数还提供额外的<code>base</code>参数，默认值为<code>10</code>。如果传入<code>base</code>参数，就可以做N进制的转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#39;12345&#39;, base&#x3D;8)</span><br><span class="line">5349</span><br><span class="line">&gt;&gt;&gt; int(&#39;12345&#39;, 16)</span><br><span class="line">74565</span><br></pre></td></tr></table></figure>

<p>​    <code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import functools</span><br><span class="line">&gt;&gt;&gt; int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br><span class="line">&gt;&gt;&gt; int2(&#39;1000000&#39;)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; int2(&#39;1010101&#39;)</span><br><span class="line">85</span><br></pre></td></tr></table></figure>

<p>所以，简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p>
<p>注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为<code>2</code>，但也可以在函数调用时传入其他值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int2(&#39;1000000&#39;, base&#x3D;10)</span><br><span class="line">1000000</span><br></pre></td></tr></table></figure>

<p>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br></pre></td></tr></table></figure>

<p>实际上固定了int()函数的关键字参数<code>base</code>，也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2(&#39;10010&#39;)</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kw &#x3D; &#123; &#39;base&#39;: 2 &#125;</span><br><span class="line">int(&#39;10010&#39;, **kw)</span><br></pre></td></tr></table></figure>

<p>当传入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2 &#x3D; functools.partial(max, 10)</span><br></pre></td></tr></table></figure>

<p>实际上会把<code>10</code>作为<code>*args</code>的一部分自动加到左边，也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2(5, 6, 7)</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args &#x3D; (10, 5, 6, 7)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure>

<p>结果为<code>10</code>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-字典"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/03/26/%E5%AD%97%E5%85%B8/" class="article-date">
  <time datetime="2021-03-26T10:19:45.505Z" itemprop="datePublished">2021-03-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;] &#x3D; 90</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;]</span><br><span class="line">90</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;] &#x3D; 88</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;]</span><br><span class="line">88</span><br></pre></td></tr></table></figure>

<p>如果key不存在，dict就会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#39;Thomas&#39;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#39;Thomas&#39;</span><br></pre></td></tr></table></figure>

<p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Thomas&#39; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&#39;Thomas&#39;)</span><br><span class="line">&gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#39;Bob&#39;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85&#125;</span><br></pre></td></tr></table></figure>

<p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p>
<p>和list比较，dict有以下几个特点：</p>
<ol>
<li>查找和插入的速度极快，不会随着key的增加而变慢；</li>
<li>需要占用大量的内存，内存浪费多。</li>
</ol>
<p>而list相反：</p>
<ol>
<li>查找和插入的时间随着元素的增加而增加；</li>
<li>占用空间小，浪费内存很少。</li>
</ol>
<p>dict的key必须是<strong>不可变对象</strong></p>
<p>​    在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; d[key] &#x3D; &#39;a list&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &#39;list&#39;</span><br></pre></td></tr></table></figure>





























 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-执行顺序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
     
    <div class="article-meta">
      <a href="/2021/03/26/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" class="article-date">
  <time datetime="2021-03-26T10:19:45.500Z" itemprop="datePublished">2021-03-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age &#x3D; 20</span><br><span class="line">if age &gt;&#x3D; 18:</span><br><span class="line">    print(&#39;your age is&#39;, age)</span><br><span class="line">    print(&#39;adult&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age &#x3D; 3</span><br><span class="line">if age &gt;&#x3D; 18:</span><br><span class="line">    print(&#39;your age is&#39;, age)</span><br><span class="line">    print(&#39;adult&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;your age is&#39;, age)</span><br><span class="line">    print(&#39;teenager&#39;)</span><br></pre></td></tr></table></figure>

<h3 id="if…elif…else"><a href="#if…elif…else" class="headerlink" title="if…elif…else"></a>if…elif…else</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h3 id="for-x-in-…"><a href="#for-x-in-…" class="headerlink" title="for x in …"></a>for x in …</h3><p>​    把每个元素代入变量<code>x</code>，然后执行缩进块的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum &#x3D; 0</span><br><span class="line">for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">    sum &#x3D; sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p><code>rabge(x)</code>：生成序列从0开始小于x的整数</p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>​    只要条件满足，就不断循环，条件不满足时退出循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum &#x3D; 0</span><br><span class="line">n &#x3D; 99</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum &#x3D; sum + n</span><br><span class="line">    n &#x3D; n - 2</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p><code>break</code>语句可以提前退出循环</p>
<p>通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> 大白菜
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/22.jpg" alt="困困"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

</html>