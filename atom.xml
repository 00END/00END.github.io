<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>困困</title>
  
  <subtitle>一只忧伤的小菜鸡</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-09T02:52:51.705Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>大白菜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础</title>
    <link href="http://example.com/2021/04/09/java%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/04/09/java%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-09T02:24:20.000Z</published>
    <updated>2021-04-09T02:52:51.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>​        数值类型：</p><p>​                整数类型(byte, short,int,long)    </p><p>​                浮点类型（float,double)</p><p>​        字符型（char）</p><p>​        布尔型(boolean)</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>​    类(class)    接口（interface)    数组</p><h1 id="输出数据的格式控制"><a href="#输出数据的格式控制" class="headerlink" title="输出数据的格式控制"></a>输出数据的格式控制</h1><table><thead><tr><th align="center">输出控制符</th><th align="center">针对的数据类型</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">int, long int , short, byte</td></tr><tr><td align="center">%x，%#x，%X，%#X</td><td align="center">int, long int</td></tr><tr><td align="center">%c</td><td align="center">char</td></tr><tr><td align="center">%f</td><td align="center">float，double</td></tr><tr><td align="center">%s</td><td align="center">String</td></tr></tbody></table><p><strong>注意：</strong></p><p>​    在java中没有%ld和%If,比如float和double都用%f输出，这是与C/C++不同的</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="1-整型常量"><a href="#1-整型常量" class="headerlink" title="1.整型常量"></a>1.整型常量</h4><p>十进制(12)，十六进制(0x12)，八进制（012)<br>    <strong>一个常量整数默认是int类型，如果数字过大，则必须的在末尾加L，否则会出错!</strong></p><p>例如：</p><pre><code> long i = 9223372036854775807; //error  编译报错,提示数字过大，</code></pre><p>​        但是如果改为:long i= 9223372036854775807L;   就可以了</p><h4 id="2-浮点常量"><a href="#2-浮点常量" class="headerlink" title="2.浮点常量"></a>2.浮点常量</h4><p>​    一个实数默认是double类型，如果希望一个<strong>实数是float类型，可以在数字后面加f(F)</strong><br>​        将一个double类型数值赋给float类型变量，编译是会报错例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float x &#x3D; 2.2; &#x2F;&#x2F;error</span><br><span class="line">float x &#x3D; 2.2f; &#x2F;&#x2F;OK</span><br></pre></td></tr></table></figure><h4 id="3-字符常量"><a href="#3-字符常量" class="headerlink" title="3.字符常量"></a>3.字符常量</h4><p>​    必须用单引号括起来</p><p>​    Java中字符和字符串都用Unicode编码表示</p><p>​    在Uniede编码中一个字符占两个字节  \u表示unicode编码</p><p>​        ‘a’ ‘B’ ‘\n’ ‘\u0030’</p><h4 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4.布尔类型"></a>4.布尔类型</h4><p>​    用boolean表示，不能写成bool<br>​    布尔型数据<strong>只有两个值true和false</strong>，且它们不对应于任何整数值</p><p>​    布尔型变量的定义如:</p><p>​        boolean b = trye;</p><p><strong>注意：</strong></p><p>​    <strong>lf  while  for  中进行真假判断时只能使用逻辑表达式</strong></p><pre><code>## 数据类型的转换</code></pre><ul><li><p>不能对boolean类型进行类型转换。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>整型、实型、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算，转换从低级到高级:</p><p>低 ———————————&gt; 高</p><p>byte -&gt; char -&gt; int-&gt; long -&gt; float -&gt; double</p></li></ul><h2 id="算术运输符"><a href="#算术运输符" class="headerlink" title="算术运输符"></a>算术运输符</h2><ul><li>+可以表示数值的相加</li><li>+可以表示字符串的联接<pre><code>如:“123”+&quot;“abc”的结果是“123abc”</code></pre></li><li>+还能把非字符串转换成字符串<pre><code>如:“&quot;+123;的结果是“x123”</code></pre></li><li>分析 System.out.println(‘a’+1)与System.out.println(“”+’a’+1)的区别</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><strong>把一类事物的静态属性和动态可以执行的操作组合在一起</strong>所得的这个概念就是类</li><li>类是抽象的，用来模拟一类事物，是一个概念</li><li>一旦被定义，类的概念就永远存在了</li></ul><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aqe;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;oh,my god!I am&quot;</span> + age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    age是类的属性,也叫类数据成员，也叫字段,也叫域。</p><p>​    shout是方法,也叫类的成员函数<br>​    shout方法可以直接访问同一个类中的age变量。</p><h2 id="内存分配问题"><a href="#内存分配问题" class="headerlink" title="内存分配问题"></a>内存分配问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestHemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> stat ic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">aa </span>= <span class="keyword">new</span> A(); <span class="comment">//(A*)malloc(sizeof(A));</span></span><br><span class="line"><span class="comment">//new A(); 在堆中动态分配一块区域，被当做了A对象</span></span><br><span class="line"><span class="comment">//aa本身的内存是在栈中分配的</span></span><br><span class="line"><span class="comment">//堆中内存的地址付给了aa</span></span><br><span class="line"><span class="comment">//aa指向堆中的内存,aa代表了堆中的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h1><p>​    在一个类的内部，所有的成员可以相互访问,访问控制符是透明的；<strong>访问控制符是针对外部访问</strong>而言的</p><p><strong>外部访问包括两种方式</strong></p><ul><li>通过类名访问类内部的成员</li><li>通过类对象名访问类内部成员</li></ul><h2 id="public-公有"><a href="#public-公有" class="headerlink" title="public 公有"></a>public 公有</h2><p>​    可以通过外部访问方式访问类内部的public成员</p><h2 id="protect-保护"><a href="#protect-保护" class="headerlink" title="protect 保护"></a>protect 保护</h2><p>​    <strong>不可以</strong>通过外部访问方式访问类内部的priavate成员</p><h2 id="默认【即不加任何修饰符】"><a href="#默认【即不加任何修饰符】" class="headerlink" title="默认【即不加任何修饰符】"></a>默认【即不加任何修饰符】</h2><h2 id="private-私有"><a href="#private-私有" class="headerlink" title="private 私有"></a>private 私有</h2><p>​    一个类的外部：通过 <strong>类对象名.私有成员名</strong> 的方式是无法访问该对象中的私有成员</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><strong>定义：</strong></p><p>​    名字和类名一样<br>​    无返回值</p><p><strong>注意事项：</strong><br>    一个类对象只能调用一个构造方法<br>    一个类至少有一个构适方法<br>    如果自己定义了构造方法，编译器将不再提供默认的够方法</p><p><strong>同类名相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i = a;</span><br><span class="line">j = b;</span><br><span class="line">system.out.printf(”无参构造函数被调用了! \n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="构造函数的返回值问题"><a href="#构造函数的返回值问题" class="headerlink" title="构造函数的返回值问题"></a>构造函数的返回值问题</h2><ul><li>在一个类中可以定义多个函数名与类名相同但却有返回值的函数，返回值为void或int或double都可以，这些有返回值的函数只要能满足重载特点，就可以同时存在一个类中，不过要注意:这些有返回值的函数(包括返回值为void的函数)都不是构造函数，都不会被类对象自动调用</li><li>当然也可以定义多个没有任何返回值的函数，注意连void都不可以加，这些函数才是构造函数,无返回值的函数才会被对象自动调用</li><li>如果定义了有返回值并且方法名与类名相同的方法，程序并不会报错，但容易产生歧义，所以<strong>强烈建议不要在构造方法前面加返回值（构造函数与类名相同）</strong></li></ul><h2 id="构造函数数据成员的赋值问题"><a href="#构造函数数据成员的赋值问题" class="headerlink" title="构造函数数据成员的赋值问题"></a>构造函数数据成员的赋值问题</h2><p>​    当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。</p><p><strong>局部变量没有初始化就是垃圾值</strong> <strong>，局部变量编译器是不会自动进行初始化的，java要求所有的局部变量在使用之前都<code>必须的初始化</code></strong></p><p><strong>类的属性没有初始化会自动建立默认值</strong></p><table><thead><tr><th>成员变量类型</th><th>初始值</th></tr></thead><tbody><tr><td>byte</td><td>0</td></tr><tr><td>short</td><td>0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float   double</td><td>0.0F  0.0D</td></tr><tr><td>char  boolean</td><td>‘\u000’(表示为空)   False</td></tr><tr><td>A1l ref erence type</td><td>Null</td></tr></tbody></table><ul><li>如果在定义的时候不初始化，则它的值是系统自动分配好的默认值!</li><li>如果在定义的同时赋初值，则是可以的， 也就是说该值是生效的.注意在C++中则不可以，在C++中一个类的数据成员不能在定义的同时初始化，它只能在构造函数中初始化</li><li>如果在定义的同时赋初值，当然生效，但如果在构造函数中又改变了定义时赋的初值，则该数据成员最终的值就是构造函数中修改之后的那个值,因为:</li><li><strong>系统会先执行定义时赋的初值，然后再执行构造函数中赋的初值</strong></li></ul><h1 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h1><p>​    同名的函数通过<strong>不同的形参</strong>做类似的事情，这就叫函数的重载</p><p><strong>函数重载要求</strong><br>    1.函数的形参个数<br>    2.函数的形参顺序<br>    3.函数的形参数据类型<br>■这三个至少有一个是不一样的</p><p>如果两个函数只是函数的返回值不一样，其他都一样，这构不成函数的重载，并且编译时会报错!</p><h1 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h1><ul><li>是一个系统隐含的指针被自动附加在非静态的成员函数参数列表中</li><li>当前时刻，哪个对象<strong>调用该函数</strong>，那么this就指向当前调用该函数的对象，系统会自动在该函数的参数列表中添加一个隐藏的this指针，并且把调用该函数的对象的地址赋给this指针，这样一来，在函数的内部通过this就可访问当前正在调用该函数的对象的成员。</li><li>静态函数内部，没有this指针</li><li>一个对象只含有属性的空间，n个对象公共一份方法的拷贝</li></ul><p>例子：TestThis1.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;i=&quot;</span>+ i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa1 = <span class="keyword">new</span> A(<span class="number">5</span>);</span><br><span class="line">A aa2 = <span class="keyword">new</span> A(<span class="number">8</span>);</span><br><span class="line">aa1.show0;</span><br><span class="line">aa2.show0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    aa1和aa2 在内存中分别有各自的数据成员i；但是aa1和aa2公用show()方法，show方 法如何知道输出的i应该是哪那个对象中的i？<br>​    实际上每个非static方法中都隐含这一个this指针，指向当前正在调用该方法的对象</p><h1 id="静态static"><a href="#静态static" class="headerlink" title="静态static"></a>静态static</h1><p>​    属性i是属于类本身，或者讲：没有对象，我们仍然可以直接通过类名的方式访问该类内部的static属性</p><p>​    static只是表明了该成员具有了可以通过类名访问的潜在特征但是否可以通过类名访问，还必须满足一个条件：该成员必须是非private</p><p>​    静态方法不能访问非静态成员</p><p>​    非静态方法可以访问静态成员</p><p>创建新对象时属性是在不同空间但是类方法是公用的，静态方法没有this指针</p><p>Static可以修饰普通方法不能修饰构造方法，构造方法如果是私有private的就不能new出对象</p><ul><li>一个类的属性可以是个类对象</li></ul><p>例子：创建只有一个对象的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> A aa = <span class="keyword">new</span> A(); <span class="comment">//aa是否是A对象的属性创建对象  创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">A</span><span class="params">()</span>  <span class="comment">//私有不能new出新对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getA</span><span class="params">()</span> <span class="comment">//访问接口 static 一定不能省略</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>静态成员属于类本身的，而不是属于对象，被类的所有对象所共有</p></li><li><p><strong>即便不创建对象，也可以使用类本身的静态成员</strong></p></li><li><p>静态成员分为</p><pre><code>静态数据成员静态方法成员</code></pre></li><li><p>使用静态成员的两种方法</p><pre><code>类名.静态成员名类对象名.静态成员名</code></pre></li><li><p>编写使用静态变量统计一个类产生的实例对象的个数的程序</p></li><li><p><strong>在静态方法里只能直接调用同类中其它的静态成员(包括变量和方法)，而不能直接访问类中的非静态成员</strong>。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才<br>可使用，而静态方法在使用前不用创建任何对象</p></li><li><p><strong>静态方法不能以任何方式引用this和super关键字</strong>。与上面的道理一样，因为静态方法在使用前不用创建任何实例对象，当静态方法被调用时，this所引用的对象根本就没有产生。</p></li><li><p>静态方法只能访问类的静态成员，但<strong>非静态方法却可以访问类中所有成员，包括静态成员</strong></p></li></ul><p>例子：</p><p>本程序证明了：</p><p>​    只有非private的static成员才可以通过类名的方式访问;</p><p>​    static只是表明了该成员具有了可以通过类名访问的潜在特征</p><p>​    但是否可以通过类名访问，还必须满足-个条件:该成 员必须是非private</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i= <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;2009年5月29日15:15:50\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStatic_4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//A.f(); //error</span></span><br><span class="line"><span class="comment">//A.i= 22; //error</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承  extends"></a>继承  extends</h1><ul><li><p>一个新类从已有的类那里获得其已有的属性和方法，这中现象叫类的继承</p></li><li><p>这个新类被称为子类，也叫派生类，已有的那个类叫做父类，也叫做基类</p></li><li><p>继承的好处<br>■<strong>代码得到极大的重用</strong><br>■<strong>形成一种类的层次体系结构，为多态创造条件</strong></p></li><li><p>继承的实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="同包继承权限（重点）"><a href="#同包继承权限（重点）" class="headerlink" title="同包继承权限（重点）"></a>同包继承权限（重点）</h2><ul><li>子类的所有方法内部都可以访问父类除私有成员以外的所有成员，所谓子类的所有方法也包括子类的私有方法</li><li>通过子类对象名可以访问<br>1.父类除私有成员外的所有成员<br>2.子类本身的除私有成员外的所有成员<br>■附注:私有成员包括私有属性和私有方法</li><li>子类可以继承父类除私有成员以外的所有成员</li><li><strong>父类的私有成员不可以被子类继承，其他的成员都可以被子类继承</strong></li></ul><p><strong>1、子类内部可以访问父类非私有的成员</strong><br>        <strong>私有成员无法被子类方法访问</strong><br><strong>2、 通过子类对象名只能访问从父类继承过来的非私有成员</strong><br><strong>总结:</strong><br>    <strong>私有不能被继承</strong><br>    <strong>私有物理上已经被继承过来，只不过逻辑上程序员不能去访问它</strong><br>    <strong>因此继承必须慎重，否则会浪费内存</strong></p><h2 id="继承原则"><a href="#继承原则" class="headerlink" title="继承原则"></a>继承原则</h2><p>三种关系</p><p>​    1.一般到特殊</p><p>​    2.包含</p><p>​    3.使用</p><h2 id="不同访问修饰符"><a href="#不同访问修饰符" class="headerlink" title="不同访问修饰符"></a>不同访问修饰符</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>default</th><th>private</th></tr></thead><tbody><tr><td>同包同类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>访问同包不同类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>同包不同类继承</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包继承</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>访问不同包无任何关系的类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>Java只支持单继承，不允许多重继承。</li><li>单继承就是一个类只能有一个父类</li><li>多继承就是一个类可以有多个父类</li><li>可以有多层继承，即一个类可以继承某一个类的子类，如类B<br>继承了类A，类C又可以继承类B，那么类C也间接继承了类A</li><li>子类可以继承父类所有的成员变量和成员方法，但<strong>子类永远无法继承父类的构造方法</strong>。在子类的构造方法中可使用语句**super(参数列表)**调用父类的构造方法。</li></ul><h2 id="super-子类无法继承父类构造方法"><a href="#super-子类无法继承父类构造方法" class="headerlink" title="super() 子类无法继承父类构造方法"></a>super() 子类无法继承父类构造方法</h2><h2 id="子类访问父类成员的三种方式"><a href="#子类访问父类成员的三种方式" class="headerlink" title="子类访问父类成员的三种方式"></a>子类访问父类成员的三种方式</h2><ul><li>在子类内部访问父类成员</li><li>通过子类对象名访问父类成员</li><li>通过子类的类名访问父类成员</li></ul><p>经验证，子类通过上述三种方式的任何一种，都无法访问父类私有成员，因此我们可以得出结果:<br>            私有成员无法被子类继承，物理继承但语法无法访问</p><p><strong>可以使用super()调用父类构造方法</strong></p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>. i = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(i);</span><br><span class="line">        <span class="keyword">this</span>. j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>普通方法中不能调用父类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//super(i); //普通方法中不能调用父类的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造方法只能调用一个</strong></p><p><strong>总结：</strong></p><p>1、每个子类构造方法的第一条语句都是隐含地调用super(), 如父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>2、如果显示的写出super()；语句，则必须保证该语句是第一条语句，否则会出错<br>3、super() ;如果不写，则编译器会自动添加，所以此时如果父类没有无参的构造函数就会出错<br>4、既可以显示写super()；前提是父类必须有无参的构造函数<br>    也可以显示写super(实参)；前提是父类必须有帶参的构造函数<br>5、调用父类的构造函数的语句必须借助于super,不能直接写父类的类名，这与c++不同</p><p>6、一个构造函数中不能写多个super(参数列表)语句；</p><h1 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h1><ul><li>方法重写<pre><code>■指在子类中重所定义父类中已有的方法</code></pre></li><li><strong>重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型</strong></li><li>子类中不允许出现与父类同名同参但不同返回值的方法,如果出现了，编译时会报错</li><li>覆盖方法时，<strong>不能</strong>使用比父类中被覆盖的方法<strong>更严格的访问校限【子类权限不能变低（保证多态任何时候可以实现）】</strong></li></ul><p>重写的意义</p><p>​    如果子类对继承自父类的方法不满意，就应该重写父类的方法</p><p><strong>注意：</strong></p><p>​    方法名和参数列表和返回子必须一样</p><p>​    访问权限不能过低</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>同一代码做不一样的事情</p><p>多态：不同对象对同一刺激有不同反应</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoly</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span>(); <span class="comment">//A是父类</span></span><br><span class="line">B bb = <span class="keyword">new</span>(); <span class="comment">//B是子类</span></span><br><span class="line"></span><br><span class="line">aa.f();</span><br><span class="line">bb.f();</span><br><span class="line">aa = bb; <span class="comment">// 把bb当做aa来看待,因为子类可以当做父类看待，所以本语旬0K</span></span><br><span class="line"><span class="comment">//bb = aa; //把aa当做bb来看待,因为父类不能当做子类看待，所以本语句error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类当成父类看，aa保存了这个对象的地址就代表这个对象</p><ul><li>一个父类的引用类型变量它既可以指向父类对象也可以指向子类对象，它可以根据当前时刻指向的不同，自动调用不同对象的方法，这就是多态</li></ul><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><p>利用多态可以实现:<br>        同一段代码做不同事情<br>如:<br>    ■假设A派生出B，B派生出C<br>    ■试着编写一个函数实现调用整个A类族所有对象f方法<br>    ■所谓A类族就是A类及其A的子孙类所形成的一个族群</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoly_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(A aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">aa.f(); <span class="comment">//类似于C语言的: (*aa).f();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A();</span><br><span class="line">B bb = <span class="keyword">new</span> B();</span><br><span class="line">C cc = <span class="keyword">new</span> C();</span><br><span class="line">D dd = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">g(aa);</span><br><span class="line">g(bb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类不能强制转换为子类，但是先把子类赋给父类就可以强制转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A();</span><br><span class="line">B bb = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">aa = bb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bb = aa; //error</span></span><br><span class="line">bb = (B)aa;</span><br><span class="line">bb.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态：aa只能调用父类继承的方法，不能调用子类特有的方法</p><h3 id="多态注意事项"><a href="#多态注意事项" class="headerlink" title="多态注意事项"></a>多态注意事项</h3><ul><li><strong>子类对象可以直接赋给父类引用，但父类对象在任何情况下都不可以直接赋给子类引用</strong>，因为子类是父类的一种，但父类不是子类的一种,或者讲“子类可以当做父类看待，但父类不可以当做子类看待”,“狗可以当做动物看待，但动物不可以当做狗来看待”</li><li>通过父类引用只能访问子类对象从父类继承过来的成员</li><li>通过父类引用不能访问子类对象所特有的成员</li><li>父类引用永远不可能直接赋给子类引用<ul><li><strong>只有在父类引用本身指向的就是一个子类对象时，才可以把父类引用强制转化为子类引用</strong></li><li>其他情况下不允许把父类引用强制转化为子类引用，否则运行时会出</li></ul></li></ul><h1 id="抽象类-（不能构造事物）"><a href="#抽象类-（不能构造事物）" class="headerlink" title="抽象类 （不能构造事物）"></a>抽象类 （不能构造事物）</h1><ul><li>抽象类的由来<pre><code>利用抽象类是为了更好的对类加以分类，就如同人类不但给各种具体植物取了名字还发明了“植物”这个抽象的词对所有具体植物进行归类一样</code></pre></li><li>Java用来模拟现实世界，所以也存在抽象类</li><li>抽象类通常用来作为一个类族的最顶层的父类，用最底层的类表示现实中的具体事物，用最顶层的类表示该类族所有事物的共性</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有抽象方法的类一定是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//没有方法体的方法叫做抽象方法，抽象方法要求末尾必须得加分号，前面必须得加abstract</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类不一定有抽象方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象方法与抽象类"><a href="#抽象方法与抽象类" class="headerlink" title="抽象方法与抽象类"></a>抽象方法与抽象类</h2><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul><li>在定义Java方法时可以只给出方法头,而不给出方法内部实现代码这样的方法称为抽象方法。</li><li>凡是没有方法体的方法必须的使用关键字<code>abstract</code>修饰为抽象方法</li><li>凡是含有抽象方法的类都必须的声明为抽象类</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>用<code>abstract</code>关键字来修饰一个类时，该类叫做抽象类;</li><li>包含抽象方法的类必须声明为抽象类。</li><li>但是一个抽象类中却可以不包含任何抽象方法，尽管比较少见</li><li>抽象类不一定有抽象方法</li><li>有抽象方法的一定是抽象类</li></ul><p><strong>父类不是抽象类，子类可以是抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父类是抽象类，子类也是抽象类，如果不是抽象类就要实现它</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbsPoly_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// A aa = new A(); //error 18行</span></span><br><span class="line">        B bb = <span class="keyword">new</span> B(); <span class="comment">//0K</span></span><br><span class="line">bb.f(); <span class="comment">//OK</span></span><br><span class="line">A aa; <span class="comment">//23行  OK可以定义一个抽象类的引用，但是不可以定义一个抽象类的对象，所以18行error，本行OK</span></span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="final-最后的类，不能被继承"><a href="#final-最后的类，不能被继承" class="headerlink" title="final  最后的类，不能被继承"></a>final  最后的类，不能被继承</h1><h3 id="final可以修饰"><a href="#final可以修饰" class="headerlink" title="final可以修饰"></a>final可以修饰</h3><ul><li>整个类</li><li>类中的若干个属性</li><li>类中的若干个方法</li></ul><p><strong>Final修饰整个类，类每个单词的首字母大写</strong><br><strong>■表示该类不能被继承</strong><br><strong>■如果认为一个类己经很完美且不需要定义子类来继承它时，可以使用它</strong><br><strong>■格式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puplic <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 和 <span class="keyword">final</span> 可以互换</span><br></pre></td></tr></table></figure><h3 id="Final修饰类中的若干属性"><a href="#Final修饰类中的若干属性" class="headerlink" title="Final修饰类中的若干属性"></a>Final修饰类中的若干属性</h3><ul><li>Final修饰类中的若干属性表示该属性<strong>必须被赋值</strong>并且<strong>只能被赋一次值</strong></li><li>初始化方式有两种:(只能选择其中的一种)<ul><li>在定义成员变量的同时初始化</li><li>在类中所有的构造函数中初始化</li></ul></li><li>注意:<br>一个类的所有普通方法内部都不可以修改final修饰过的成员变量的值</li></ul><p>例子：表示该方法可以被子类继承，但不可以被子类重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="comment">//如果在public前面加final，则编译时就会报错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="comment">//重写父类的f方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口  interface"></a>接口  interface</h1><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>​    就是批象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类，只允许有一些常量，特殊方法，不允许被修改</p><h3 id="接口的格式"><a href="#接口的格式" class="headerlink" title="接口的格式"></a>接口的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[public] interface interfaceName [extends SuperInterfaceList]</span><br><span class="line">&#123;</span><br><span class="line">.....<span class="comment">//常量定义和方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细知识"><a href="#详细知识" class="headerlink" title="详细知识"></a>详细知识</h3><ul><li>接口中定义的属性必须是<code>public static final</code>的，而接口中定义的方法则必须是<code>public abstract</code>的，因此这些修饰符可以部分或全部省略</li><li>接口中定义的属性的值在实现类中不能被更改</li><li>一个类只能实现某个接口，不能继承某个接口</li><li>但接口可以继承接口</li><li>接口不但可以继承接口，而且<strong>可以继承多个接口</strong>，即接口允许多继承</li><li>如果一个类只实现了一个接口的部分方法，则该类必须的声明为抽象类</li><li>一个类可以在继承一个父类的同时实现一个或多个接口，但<strong>extends关键字必须的在implements之前</strong></li></ul><h3 id="接口的实现-implements"><a href="#接口的实现-implements" class="headerlink" title="接口的实现 implements"></a>接口的实现 implements</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span> <span class="params">()</span> <span class="comment">//implements不能改为extends因为类可以继承类，但类不能继承接口,逻辑意义不通，类可以实现接口</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//i=99; //error</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;i = %d\n&quot;</span>，i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p><strong>如果一个类只实现了一个接口的部分方法，则该类必须的声明为抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">void</span> g0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It1</span> //去掉了<span class="title">abstract</span> 就会报错!</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInter_5</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String0 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    System.out.printIn(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个类要想实现某接口中的方法时，必须得在方法返回值前加上public</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//public不能丢，也不能改为其他修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    System.out.printn(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//lt it= new lt(); //error</span></span><br><span class="line">        lt it= <span class="keyword">new</span> A();</span><br><span class="line">        it.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><ul><li>通过接口可以实现不相关类的相同行为<pre><code>如:Java规定所有可以完成自我复制功能的类都必须得实现java.lang.Colneable接口，但该接口却是空的，该接口中没有任何内容,目的只是为了起个标志作用</code></pre></li><li>接口提供了不同对象进行协作的平台<pre><code>如事件处理</code></pre></li><li>接口可以实现多继承,从一定程序上弥补了类只能单继承的缺陷</li><li>接口是我们了解-一个类功能的重要途径<pre><code>如: Java整个容器框架就是以接口的方式建立起来的，实现不同接口的类完成的是不同的功能，接口使我们了解一个类功能的重要途径</code></pre></li></ul><h3 id="接口与抽象类区别"><a href="#接口与抽象类区别" class="headerlink" title="接口与抽象类区别"></a>接口与抽象类区别</h3><ul><li>接口中的方法不允许有方法体，但抽象类却允许</li><li>Java类不允许多继承，接口却允许多继承<br>■ 接口可以实现多继承，即一个接口可以有多个父类<br>■ 但Java类只允许单继承，即一个类只能有一个父类</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;h3 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>扫描器V1</title>
    <link href="http://example.com/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/"/>
    <id>http://example.com/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/</id>
    <published>2021-04-03T15:10:17.000Z</published>
    <updated>2021-04-03T15:12:51.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录扫描器"><a href="#目录扫描器" class="headerlink" title="目录扫描器"></a>目录扫描器</h2><p>命令行界面，可显示200和403网页网址</p><p><img src="/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/55.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录扫描器&quot;&gt;&lt;a href=&quot;#目录扫描器&quot; class=&quot;headerlink&quot; title=&quot;目录扫描器&quot;&gt;&lt;/a&gt;目录扫描器&lt;/h2&gt;&lt;p&gt;命令行界面，可显示200和403网页网址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/04/03/%E6%89%A</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>模块</title>
    <link href="http://example.com/2021/03/26/%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2021/03/26/%E6%A8%A1%E5%9D%97/</id>
    <published>2021-03-26T13:25:21.000Z</published>
    <updated>2021-03-26T13:34:16.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导入模块-import-xx"><a href="#导入模块-import-xx" class="headerlink" title="导入模块 import xx"></a>导入模块 import xx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>​    当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p>​    类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等</p><h3 id="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"><a href="#外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。" class="headerlink" title="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"></a>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</h3><h1 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h1><p>​    Windows确保安装时勾选了<code>pip</code>和<code>Add python.exe to Path</code></p><p>​    命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 模块名</span><br></pre></td></tr></table></figure><p>​    推荐直接使用<a href="https://www.anaconda.com/">Anaconda</a>，内置了许多非常有用的第三方库，装上Anaconda，就相当于把数十个第三方模块自动安装好</p><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>​    当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p><p>​    默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#39;&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python36.zip&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#39;, ..., &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#39;]</span><br></pre></td></tr></table></figure><h4 id="要添加自己的搜索目录，有两种方法："><a href="#要添加自己的搜索目录，有两种方法：" class="headerlink" title="要添加自己的搜索目录，有两种方法："></a>要添加自己的搜索目录，有两种方法：</h4><p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&#39;&#x2F;Users&#x2F;michael&#x2F;my_py_scripts&#39;)</span><br></pre></td></tr></table></figure><p>这种方法是在运行时修改，运行结束后失效。</p><p>​    第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导入模块-import-xx&quot;&gt;&lt;a href=&quot;#导入模块-import-xx&quot; class=&quot;headerlink&quot; title=&quot;导入模块 import xx&quot;&gt;&lt;/a&gt;导入模块 import xx&lt;/h2&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://example.com/2021/03/26/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2021-03-26T12:11:48.085Z</published>
    <updated>2021-03-26T12:07:13.683Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E6%A8%A1%E5%9D%971/"/>
    <id>http://example.com/2021/03/26/%E6%A8%A1%E5%9D%971/</id>
    <published>2021-03-26T12:11:48.061Z</published>
    <updated>2021-03-26T12:07:23.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导入模块-import-xx"><a href="#导入模块-import-xx" class="headerlink" title="导入模块 import xx"></a>导入模块 import xx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>​    当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p>​    类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等</p><h3 id="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"><a href="#外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。" class="headerlink" title="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"></a>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</h3><h1 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h1><p>​    Windows确保安装时勾选了<code>pip</code>和<code>Add python.exe to Path</code></p><p>​    命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 模块名</span><br></pre></td></tr></table></figure><p>​    推荐直接使用<a href="https://www.anaconda.com/">Anaconda</a>，内置了许多非常有用的第三方库，装上Anaconda，就相当于把数十个第三方模块自动安装好</p><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>​    当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p><p>​    默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#39;&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python36.zip&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#39;, ..., &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#39;]</span><br></pre></td></tr></table></figure><h4 id="要添加自己的搜索目录，有两种方法："><a href="#要添加自己的搜索目录，有两种方法：" class="headerlink" title="要添加自己的搜索目录，有两种方法："></a>要添加自己的搜索目录，有两种方法：</h4><p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&#39;&#x2F;Users&#x2F;michael&#x2F;my_py_scripts&#39;)</span><br></pre></td></tr></table></figure><p>这种方法是在运行时修改，运行结束后失效。</p><p>​    第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导入模块-import-xx&quot;&gt;&lt;a href=&quot;#导入模块-import-xx&quot; class=&quot;headerlink&quot; title=&quot;导入模块 import xx&quot;&gt;&lt;/a&gt;导入模块 import xx&lt;/h2&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/03/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-03-26T12:11:48.048Z</published>
    <updated>2021-03-26T11:46:07.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><p>Q：函数本身赋值给变量呢？</p><p>A：函数本身也可以赋值给变量，即：变量可以指向函数。</p><p>​    函数名也是变量，把函数名指向其他对象，函数名()就不能执行函数体</p><h2 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h2><p>​    一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p><p>一个最简单的高阶函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">    return f(x) + f(y)</span><br></pre></td></tr></table></figure><p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，根据函数定义，我们可以推导计算过程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; -5</span><br><span class="line">y &#x3D; 6</span><br><span class="line">f &#x3D; abs</span><br><span class="line">f(x) + f(y) &#x3D;&#x3D;&gt; abs(-5) + abs(6) &#x3D;&#x3D;&gt; 11</span><br><span class="line">return 11</span><br></pre></td></tr></table></figure><h1 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h1><p>​    <code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r &#x3D; map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><p>把这个list所有数字转为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</span><br></pre></td></tr></table></figure><p>​    <code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数</p><p>对一个序列求和，就可以用<code>reduce</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>当然求和运算可以直接用Python内建函数<code>sum()</code>，没必要动用<code>reduce</code>。</p><p>但是如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>，<code>reduce</code>就可以派上用场：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])</span><br><span class="line">13579</span><br></pre></td></tr></table></figure><h1 id="filter-筛选"><a href="#filter-筛选" class="headerlink" title="filter()  筛选"></a>filter()  筛选</h1><p>​    <code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure><p>把一个序列中的空字符串删掉，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def not_empty(s):</span><br><span class="line">    return s and s.strip()</span><br><span class="line"></span><br><span class="line">list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))</span><br><span class="line"># 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br></pre></td></tr></table></figure><h1 id="sorted-排序"><a href="#sorted-排序" class="headerlink" title="sorted  排序"></a>sorted  排序</h1><p><code>sorted()</code>函数就可以对list进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])</span><br><span class="line">[-21, -12, 5, 9, 36]</span><br></pre></td></tr></table></figure><p>​    以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key&#x3D;abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure><p><strong>字符串排序</strong></p><p>​    默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面。</p><p>给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key&#x3D;str.lower)</span><br><span class="line">[&#39;about&#39;, &#39;bob&#39;, &#39;Credit&#39;, &#39;Zoo&#39;]</span><br></pre></td></tr></table></figure><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key&#x3D;str.lower, reverse&#x3D;True)</span><br><span class="line">[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]</span><br></pre></td></tr></table></figure><h1 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h1><p>​    高阶函数除了可以接受函数作为参数外，还可以<strong>把函数作为结果值返回</strong></p><p>​    返回求和的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax &#x3D; 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax &#x3D; ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</span><br></pre></td></tr></table></figure><p>调用函数<code>f</code>时，才真正计算求和的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>​    在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为<strong>闭包</strong></p><p><strong>每次调用都会返回一个新的函数</strong></p><h3 id="返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。"><a href="#返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。" class="headerlink" title="返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。"></a>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</h3><p>​    如果一<strong>定要引用循环变量</strong>怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs &#x3D; []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br></pre></td></tr></table></figure><p>再看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1, f2, f3 &#x3D; count()</span><br><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>​    关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;</span><br><span class="line">&gt;&gt;&gt; f(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>同样，也可以把匿名函数作为返回值返回，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def build(x, y):</span><br><span class="line">    return lambda: x * x + y * y</span><br></pre></td></tr></table></figure><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><p>​    <code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）</p><p>​    <code>int()</code>函数还提供额外的<code>base</code>参数，默认值为<code>10</code>。如果传入<code>base</code>参数，就可以做N进制的转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#39;12345&#39;, base&#x3D;8)</span><br><span class="line">5349</span><br><span class="line">&gt;&gt;&gt; int(&#39;12345&#39;, 16)</span><br><span class="line">74565</span><br></pre></td></tr></table></figure><p>​    <code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import functools</span><br><span class="line">&gt;&gt;&gt; int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br><span class="line">&gt;&gt;&gt; int2(&#39;1000000&#39;)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; int2(&#39;1010101&#39;)</span><br><span class="line">85</span><br></pre></td></tr></table></figure><p>所以，简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为<code>2</code>，但也可以在函数调用时传入其他值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int2(&#39;1000000&#39;, base&#x3D;10)</span><br><span class="line">1000000</span><br></pre></td></tr></table></figure><p>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br></pre></td></tr></table></figure><p>实际上固定了int()函数的关键字参数<code>base</code>，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2(&#39;10010&#39;)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kw &#x3D; &#123; &#39;base&#39;: 2 &#125;</span><br><span class="line">int(&#39;10010&#39;, **kw)</span><br></pre></td></tr></table></figure><p>当传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2 &#x3D; functools.partial(max, 10)</span><br></pre></td></tr></table></figure><p>实际上会把<code>10</code>作为<code>*args</code>的一部分自动加到左边，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2(5, 6, 7)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args &#x3D; (10, 5, 6, 7)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure><p>结果为<code>10</code>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高级函数&quot;&gt;&lt;a href=&quot;#高级函数&quot; class=&quot;headerlink&quot; title=&quot;高级函数&quot;&gt;&lt;/a&gt;高级函数&lt;/h2&gt;&lt;p&gt;Q：函数本身赋值给变量呢？&lt;/p&gt;
&lt;p&gt;A：函数本身也可以赋值给变量，即：变量可以指向函数。&lt;/p&gt;
&lt;p&gt;​    函数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E5%AD%97%E5%85%B8/"/>
    <id>http://example.com/2021/03/26/%E5%AD%97%E5%85%B8/</id>
    <published>2021-03-26T10:19:45.505Z</published>
    <updated>2021-03-26T06:12:41.030Z</updated>
    
    <content type="html"><![CDATA[<p>一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;] &#x3D; 90</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;]</span><br><span class="line">90</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;] &#x3D; 88</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;]</span><br><span class="line">88</span><br></pre></td></tr></table></figure><p>如果key不存在，dict就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#39;Thomas&#39;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#39;Thomas&#39;</span><br></pre></td></tr></table></figure><p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Thomas&#39; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&#39;Thomas&#39;)</span><br><span class="line">&gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#39;Bob&#39;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85&#125;</span><br></pre></td></tr></table></figure><p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p><p>和list比较，dict有以下几个特点：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><p>而list相反：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>dict的key必须是<strong>不可变对象</strong></p><p>​    在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; d[key] &#x3D; &#39;a list&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &#39;list&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://example.com/2021/03/26/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2021-03-26T10:19:45.500Z</published>
    <updated>2021-03-26T06:08:11.310Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age &#x3D; 20</span><br><span class="line">if age &gt;&#x3D; 18:</span><br><span class="line">    print(&#39;your age is&#39;, age)</span><br><span class="line">    print(&#39;adult&#39;)</span><br></pre></td></tr></table></figure><h3 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age &#x3D; 3</span><br><span class="line">if age &gt;&#x3D; 18:</span><br><span class="line">    print(&#39;your age is&#39;, age)</span><br><span class="line">    print(&#39;adult&#39;)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;your age is&#39;, age)</span><br><span class="line">    print(&#39;teenager&#39;)</span><br></pre></td></tr></table></figure><h3 id="if…elif…else"><a href="#if…elif…else" class="headerlink" title="if…elif…else"></a>if…elif…else</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h3 id="for-x-in-…"><a href="#for-x-in-…" class="headerlink" title="for x in …"></a>for x in …</h3><p>​    把每个元素代入变量<code>x</code>，然后执行缩进块的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum &#x3D; 0</span><br><span class="line">for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:</span><br><span class="line">    sum &#x3D; sum + x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p><code>rabge(x)</code>：生成序列从0开始小于x的整数</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>​    只要条件满足，就不断循环，条件不满足时退出循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum &#x3D; 0</span><br><span class="line">n &#x3D; 99</span><br><span class="line">while n &gt; 0:</span><br><span class="line">    sum &#x3D; sum + n</span><br><span class="line">    n &#x3D; n - 2</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure><p><code>break</code>语句可以提前退出循环</p><p>通过<code>continue</code>语句，跳过当前的这次循环，直接开始下一次循环</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;条件判断&quot;&gt;&lt;a href=&quot;#条件判断&quot; class=&quot;headerlink&quot; title=&quot;条件判断&quot;&gt;&lt;/a&gt;条件判断&lt;/h1&gt;&lt;h3 id=&quot;if&quot;&gt;&lt;a href=&quot;#if&quot; class=&quot;headerlink&quot; title=&quot;if&quot;&gt;&lt;/a&gt;if&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E5%85%83%E7%BB%84/"/>
    <id>http://example.com/2021/03/26/%E5%85%83%E7%BB%84/</id>
    <published>2021-03-26T10:19:45.496Z</published>
    <updated>2021-03-26T05:55:52.860Z</updated>
    
    <content type="html"><![CDATA[<p>​    要定义一个只有1个元素的tuple，如果你这么定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; (1)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>与数学公式中的小括号产生了歧义</p><p>应该的tuple定义时必须加一个逗号<code>,</code>，来消除歧义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t &#x3D; (1,)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1,)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    要定义一个只有1个元素的tuple，如果你这么定义&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;spa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E5%88%97%E8%A1%A8/"/>
    <id>http://example.com/2021/03/26/%E5%88%97%E8%A1%A8/</id>
    <published>2021-03-26T10:19:45.491Z</published>
    <updated>2021-03-26T05:53:34.168Z</updated>
    
    <content type="html"><![CDATA[<h4 id="列表的存储示意图"><a href="#列表的存储示意图" class="headerlink" title="列表的存储示意图"></a>列表的存储示意图</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;列表的存储示意图&quot;&gt;&lt;a href=&quot;#列表的存储示意图&quot; class=&quot;headerlink&quot; title=&quot;列表的存储示意图&quot;&gt;&lt;/a&gt;列表的存储示意图&lt;/h4&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E9%9B%86%E5%90%88/"/>
    <id>http://example.com/2021/03/26/%E9%9B%86%E5%90%88/</id>
    <published>2021-03-26T10:19:45.486Z</published>
    <updated>2021-03-26T06:21:10.039Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用花括号-表示"><a href="#使用花括号-表示" class="headerlink" title="使用花括号{}表示"></a>使用花括号{}表示</h3><p>元素不重复，是无序的</p><p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br><span class="line">&gt;&gt;&gt; s.add(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><p>通过<code>remove(key)</code>方法可以删除元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(4)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s1 &#x3D; set([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; s2 &#x3D; set([2, 3, 4])</span><br><span class="line">&gt;&gt;&gt; s1 &amp; s2</span><br><span class="line">&#123;2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; s1 | s2</span><br><span class="line">&#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p><code>a</code>是变量，而<code>&#39;abc&#39;</code>才是字符串对象！有些时候，我们经常说，对象<code>a</code>的内容是<code>&#39;abc&#39;</code>，但其实是指，<code>a</code>本身是一个变量，它指向的对象的内容才是<code>&#39;abc&#39;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌───┐                  ┌───────┐</span><br><span class="line">│ a │─────────────────&gt;│ &#39;abc&#39; │</span><br><span class="line">└───┘                  └───────┘</span><br></pre></td></tr></table></figure><p>调用<code>a.replace(&#39;a&#39;, &#39;A&#39;)</code>时，实际上调用方法<code>replace</code>是作用在字符串对象<code>&#39;abc&#39;</code>上的，而这个方法虽然名字叫<code>replace</code>，但却没有改变字符串<code>&#39;abc&#39;</code>的内容。相反，<code>replace</code>方法创建了一个新字符串<code>&#39;Abc&#39;</code>并返回，如果我们用变量<code>b</code>指向该新字符串，就容易理解了，变量<code>a</code>仍指向原有的字符串<code>&#39;abc&#39;</code>，但变量<code>b</code>却指向新字符串<code>&#39;Abc&#39;</code>了：</p><p>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;使用花括号-表示&quot;&gt;&lt;a href=&quot;#使用花括号-表示&quot; class=&quot;headerlink&quot; title=&quot;使用花括号{}表示&quot;&gt;&lt;/a&gt;使用花括号{}表示&lt;/h3&gt;&lt;p&gt;元素不重复，是无序的&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;add(key)&lt;/code&gt;方法可</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/"/>
    <id>http://example.com/2021/03/26/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/</id>
    <published>2021-03-26T10:19:45.481Z</published>
    <updated>2021-03-26T08:43:42.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h1><p><code>power(x, n)</code>，缺少一个参数就会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def power(x, n&#x3D;2):</span><br><span class="line">    s &#x3D; 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n &#x3D; n - 1</span><br><span class="line">        s &#x3D; s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure><p>调用时<code>power(5)</code>时，相当于调用<code>power(5, 2)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; power(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; power(5, 2)</span><br><span class="line">25</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>​    一是必选参数在前，默认参数在后</p><p>​    二是把变化大的参数放前面，变化小的参数放后面，变化小的参数就可以作为默认参数</p><p>​    不按顺序提供部分默认参数时，需要把参数名写上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def enroll(name, gender, age&#x3D;6, city&#x3D;&#39;Beijing&#39;):</span><br><span class="line">    print(&#39;name:&#39;, name)</span><br><span class="line">    print(&#39;gender:&#39;, gender)</span><br><span class="line">    print(&#39;age:&#39;, age)</span><br><span class="line">    print(&#39;city:&#39;, city)</span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line">enroll(&#39;Adam&#39;, &#39;M&#39;, city&#x3D;&#39;Tianjin&#39;)</span><br></pre></td></tr></table></figure><h2 id="默认参数必须指向不变对象！"><a href="#默认参数必须指向不变对象！" class="headerlink" title="默认参数必须指向不变对象！"></a>默认参数必须指向不变对象！</h2><p>默认参数有个最大的坑，演示如下：</p><p>先定义一个函数，传入一个list，添加一个<code>END</code>再返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L&#x3D;[]):</span><br><span class="line">    L.append(&#39;END&#39;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure><p>当你正常调用时，结果似乎不错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end([1, 2, 3])</span><br><span class="line">[1, 2, 3, &#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span><br><span class="line">[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;END&#39;]</span><br></pre></td></tr></table></figure><p>当你使用默认参数调用时，一开始结果也是对的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br></pre></td></tr></table></figure><p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;, &#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]</span><br></pre></td></tr></table></figure><p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了<code>&#39;END&#39;</code>后的list。</p><p>原因解释如下：</p><p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><h3 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h3><p>用<code>None</code>这个不变对象来实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def add_end(L&#x3D;None):</span><br><span class="line">    if L is None:</span><br><span class="line">        L &#x3D; []</span><br><span class="line">    L.append(&#39;END&#39;)</span><br><span class="line">    return L</span><br></pre></td></tr></table></figure><p>现在，无论调用多少次，都不会有问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br><span class="line">&gt;&gt;&gt; add_end()</span><br><span class="line">[&#39;END&#39;]</span><br></pre></td></tr></table></figure><h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def calc(*numbers):</span><br><span class="line">    sum &#x3D; 0</span><br><span class="line">    for n in numbers:</span><br><span class="line">        sum &#x3D; sum + n * n</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>​    参数前面加了一个<code>*</code>号。在函数内部，参数<code>numbers</code>接收到的是一个元组（传入任意个参数，包括0个参数）</p><p>传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])</span><br><span class="line">14</span><br><span class="line">或</span><br><span class="line">&gt;&gt;&gt; nums &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; calc(*nums)</span><br><span class="line">14</span><br></pre></td></tr></table></figure><h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p>关键字参数在函数内部自动组装为一个dict</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)    </span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line">person(&#39;Adam&#39;, 45, gender&#x3D;&#39;M&#39;,job&#x3D;&#39;Engineer&#39;)</span><br><span class="line">输出</span><br><span class="line">name: Adam age: 45 other: &#123;&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extra &#x3D; &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br><span class="line">person(&#39;Jack&#39;, 24, **extra)</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">name: Jack age: 24 other: &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;</span><br></pre></td></tr></table></figure><p>​    <code>**extra</code>表示把<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>参数，<code>kw</code>将获得一个dict，注意<code>kw</code>获得的dict是<code>extra</code>的一份拷贝，对<code>kw</code>的改动不会影响到函数外的<code>extra</code>。</p><h1 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h1><p>​    和关键字参数<code>**kw</code>不同，命名关键字参数需要一个特殊分隔符<code>*</code>，<code>*</code>后面的参数被视为命名关键字参数。</p><p>定义如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure><p>调用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, city&#x3D;&#39;Beijing&#39;, job&#x3D;&#39;Engineer&#39;)</span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure><p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; person(&#39;Jack&#39;, 24, &#39;Beijing&#39;, &#39;Engineer&#39;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: person() takes 2 positional arguments but 4 were given</span><br></pre></td></tr></table></figure><p>​    使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数</p><h1 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h1><p>​    参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f1(a, b, c&#x3D;0, *args, **kw):</span><br><span class="line">    print(&#39;a &#x3D;&#39;, a, &#39;b &#x3D;&#39;, b, &#39;c &#x3D;&#39;, c, &#39;args &#x3D;&#39;, args, &#39;kw &#x3D;&#39;, kw)</span><br><span class="line"></span><br><span class="line">def f2(a, b, c&#x3D;0, *, d, **kw):</span><br><span class="line">    print(&#39;a &#x3D;&#39;, a, &#39;b &#x3D;&#39;, b, &#39;c &#x3D;&#39;, c, &#39;d &#x3D;&#39;, d, &#39;kw &#x3D;&#39;, kw)</span><br></pre></td></tr></table></figure><p>在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1(1, 2)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 0 args &#x3D; () kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, c&#x3D;3)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; () kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &#39;a&#39;, &#39;b&#39;)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (&#39;a&#39;, &#39;b&#39;) kw &#x3D; &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(1, 2, 3, &#39;a&#39;, &#39;b&#39;, x&#x3D;99)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (&#39;a&#39;, &#39;b&#39;) kw &#x3D; &#123;&#39;x&#39;: 99&#125;</span><br><span class="line">&gt;&gt;&gt; f2(1, 2, d&#x3D;99, ext&#x3D;None)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 0 d &#x3D; 99 kw &#x3D; &#123;&#39;ext&#39;: None&#125;</span><br></pre></td></tr></table></figure><p>最神奇的是通过一个tuple和dict，你也可以调用上述函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args &#x3D; (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; kw &#x3D; &#123;&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; f1(*args, **kw)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 args &#x3D; (4,) kw &#x3D; &#123;&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; args &#x3D; (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; kw &#x3D; &#123;&#39;d&#39;: 88, &#39;x&#39;: &#39;#&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; f2(*args, **kw)</span><br><span class="line">a &#x3D; 1 b &#x3D; 2 c &#x3D; 3 d &#x3D; 88 kw &#x3D; &#123;&#39;x&#39;: &#39;#&#39;&#125;</span><br></pre></td></tr></table></figure><p>所以，对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>注意定义可变参数和关键字参数的语法：</p><p><code>*args</code>是可变参数，args接收的是一个tuple；</p><p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p><p>以及调用函数时如何传入可变参数和关键字参数的语法：</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**&#123;&#39;a&#39;: 1, &#39;b&#39;: 2&#125;)</code>。</p><p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p><p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p><p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;位置参数&quot;&gt;&lt;a href=&quot;#位置参数&quot; class=&quot;headerlink&quot; title=&quot;位置参数&quot;&gt;&lt;/a&gt;位置参数&lt;/h1&gt;&lt;p&gt;&lt;code&gt;power(x, n)&lt;/code&gt;，缺少一个参数就会报错&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/03/26/%E5%87%BD%E6%95%B0/</id>
    <published>2021-03-26T10:19:45.474Z</published>
    <updated>2021-03-26T10:19:58.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h1><p>而<code>max</code>函数<code>max()</code>可以接收任意多个参数，并返回最大的那个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; max(1, 2)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; max(2, 3, 1, -5)</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>​    函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; abs # 变量a指向abs函数</span><br><span class="line">&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>​    Python内置的<code>hex()</code>函数把一个整数转换成十六进制表示的字符串：</p><p>​    定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if x &gt;&#x3D; 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code></p><p>在Python交互环境中定义函数时，注意Python会出现<code>...</code>的提示。函数定义结束后需要按两次回车重新回到<code>&gt;&gt;&gt;</code>提示符下：</p><p><img src="/2021/03/26/%E5%87%BD%E6%95%B0/Users\Monste\AppData\Roaming\Typora\typora-user-images\image-20210326125930170.png" alt="image-20210326125930170"></p><h2 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h2><p>定义一个什么事也不做的空函数，可以用<code>pass</code>语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def nop():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><p>对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数<code>isinstance()</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def my_abs(x):</span><br><span class="line">    if not isinstance(x, (int, float)):</span><br><span class="line">        raise TypeError(&#39;bad operand type&#39;)</span><br><span class="line">    if x &gt;&#x3D; 0:</span><br><span class="line">        return x</span><br><span class="line">    else:</span><br><span class="line">        return -x</span><br></pre></td></tr></table></figure><p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; my_abs(&#39;A&#39;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3, in my_abs</span><br><span class="line">TypeError: bad operand type</span><br></pre></td></tr></table></figure><p>函数返回多值返回的是一个列表</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>定义函数时，需要确定函数名和参数个数；</p><p>如果有必要，可以先对参数的数据类型做检查；</p><p>函数体内部可以用<code>return</code>随时返回函数结果；</p><p>函数执行完毕也没有<code>return</code>语句时，自动<code>return None</code>。</p><p>函数可以同时返回多个值，但其实就是一个tuple。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调用函数&quot;&gt;&lt;a href=&quot;#调用函数&quot; class=&quot;headerlink&quot; title=&quot;调用函数&quot;&gt;&lt;/a&gt;调用函数&lt;/h1&gt;&lt;p&gt;而&lt;code&gt;max&lt;/code&gt;函数&lt;code&gt;max()&lt;/code&gt;可以接收任意多个参数，并返回最大的那个：&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2021/03/26/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</id>
    <published>2021-03-26T10:19:45.470Z</published>
    <updated>2021-03-26T10:12:18.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><p>切片操作十分有用。我们先创建一个0-99的数列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L &#x3D; list(range(100))</span><br><span class="line">&gt;&gt;&gt; L</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure><p>可以通过切片轻松取出某一段数列。比如前10个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10]</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>后10个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[-10:]</span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br></pre></td></tr></table></figure><p>前11-20个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[10:20]</span><br><span class="line">[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br></pre></td></tr></table></figure><p>前10个数，每两个取一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:10:2]</span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure><p>所有数，每5个取一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[::5]</span><br><span class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</span><br></pre></td></tr></table></figure><p>甚至什么都不写，只写<code>[:]</code>就可以原样复制一个list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L[:]</span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3]</span><br><span class="line">(0, 1, 2)</span><br></pre></td></tr></table></figure><h2 id="L-开始位置：结束位置（不包含该位置的元素-：取多少个"><a href="#L-开始位置：结束位置（不包含该位置的元素-：取多少个" class="headerlink" title="L[开始位置：结束位置（不包含该位置的元素)：取多少个]"></a>L[开始位置：结束位置（不包含该位置的元素)：取多少个]</h2><h3 id="注意，切片出来的是一个新列表，不会对原列表产生影响"><a href="#注意，切片出来的是一个新列表，不会对原列表产生影响" class="headerlink" title="注意，切片出来的是一个新列表，不会对原列表产生影响"></a>注意，切片出来的是一个新列表，不会对原列表产生影响</h3><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><h3 id="给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代"><a href="#给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代" class="headerlink" title="给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代"></a>给定一个list或tuple，我们可以通过<code>for</code>循环来遍历这个list或tuple，这种遍历我们称为迭代</h3><p>​    只要是可迭代对象，无论有无下标，都可以迭代，比如dict就可以迭代：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; for key in d:</span><br><span class="line">...     print(key)</span><br><span class="line">...</span><br><span class="line">a</span><br><span class="line">c</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>​    默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.values()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.items()</code>。</p><p>​    <strong>字符串也是可迭代对象</strong>，因此，也可以作用于<code>for</code>循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for ch in &#39;ABC&#39;:</span><br><span class="line">...     print(ch)</span><br><span class="line">...</span><br><span class="line">A</span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure><p>​    </p><p>​    如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>​    </p><p>Python内置的<code>enumerate</code>函数可以把一个list变成索引-元素对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):</span><br><span class="line">...     print(i, value)</span><br><span class="line">...</span><br><span class="line">0 A</span><br><span class="line">1 B</span><br><span class="line">2 C</span><br></pre></td></tr></table></figure><p>​    同时引用了两个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:</span><br><span class="line">...     print(x, y)</span><br><span class="line">...</span><br><span class="line">1 1</span><br><span class="line">2 4</span><br><span class="line">3 9</span><br></pre></td></tr></table></figure><h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p>生成<code>[1x1, 2x2, 3x3, ..., 10x10]</code></p><p>用一行语句代替循环生成list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11)]</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure><p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0]</span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</span><br><span class="line">[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</span><br></pre></td></tr></table></figure><p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import os # 导入os模块，模块的概念后面讲到</span><br><span class="line">&gt;&gt;&gt; [d for d in os.listdir(&#39;.&#39;)] # os.listdir可以列出文件和目录</span><br><span class="line">[&#39;.emacs.d&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;Adlm&#39;, &#39;Applications&#39;, &#39;Desktop&#39;, &#39;Documents&#39;, &#39;Downloads&#39;, &#39;Library&#39;, &#39;Movies&#39;, &#39;Music&#39;, &#39;Pictures&#39;, &#39;Public&#39;, &#39;VirtualBox VMs&#39;, &#39;Workspace&#39;, &#39;XCode&#39;]</span><br></pre></td></tr></table></figure><p><code>for</code>循环其实可以同时使用两个甚至多个变量，比如<code>dict</code>的<code>items()</code>可以同时迭代key和value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; &#125;</span><br><span class="line">&gt;&gt;&gt; for k, v in d.items():</span><br><span class="line">...     print(k, &#39;&#x3D;&#39;, v)</span><br><span class="line">...</span><br><span class="line">y &#x3D; B</span><br><span class="line">x &#x3D; A</span><br><span class="line">z &#x3D; C</span><br></pre></td></tr></table></figure><p>因此，列表生成式也可以使用两个变量来生成list：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d &#x3D; &#123;&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; &#125;</span><br><span class="line">&gt;&gt;&gt; [k + &#39;&#x3D;&#39; + v for k, v in d.items()]</span><br><span class="line">[&#39;y&#x3D;B&#39;, &#39;x&#x3D;A&#39;, &#39;z&#x3D;C&#39;]</span><br></pre></td></tr></table></figure><p>最后把一个list中所有的字符串变成小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; L &#x3D; [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]</span><br><span class="line">&gt;&gt;&gt; [s.lower() for s in L]</span><br><span class="line">[&#39;hello&#39;, &#39;world&#39;, &#39;ibm&#39;, &#39;apple&#39;]</span><br></pre></td></tr></table></figure><h2 id="表达式-for-x-in-range-1-11"><a href="#表达式-for-x-in-range-1-11" class="headerlink" title="[表达式 for x in range(1, 11)]"></a>[表达式 for x in range(1, 11)]</h2><h4 id="if-…-else"><a href="#if-…-else" class="headerlink" title="if … else"></a>if … else</h4><p>以下代码正常输出偶数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0]</span><br><span class="line">[2, 4, 6, 8, 10]</span><br></pre></td></tr></table></figure><p>不能在最后的<code>if</code>加上<code>else</code></p><p>因为跟在<code>for</code>后面的<code>if</code>是一个筛选条件</p><h4 id="把if写在for前面必须加else"><a href="#把if写在for前面必须加else" class="headerlink" title="把if写在for前面必须加else"></a>把<code>if</code>写在<code>for</code>前面必须加<code>else</code></h4><p>因为<code>for</code>前面的部分是一个表达式，它必须根据<code>x</code>计算出一个结果。因此，考察表达式：<code>x if x % 2 == 0</code>，它无法根据<code>x</code>计算出结果，因为缺少<code>else</code>，必须加上<code>else</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x if x % 2 &#x3D;&#x3D; 0 else -x for x in range(1, 11)]</span><br><span class="line">[-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]</span><br></pre></td></tr></table></figure><p>上述<code>for</code>前面的表达式<code>x if x % 2 == 0 else -x</code>才能根据<code>x</code>计算出确定的结果。</p><p>在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><h3 id="表达式-for-x-in-range-1-11-过滤条件"><a href="#表达式-for-x-in-range-1-11-过滤条件" class="headerlink" title="[表达式 for x in range(1, 11) 过滤条件]"></a>[表达式 for x in range(1, 11) 过滤条件]</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;切片&quot;&gt;&lt;a href=&quot;#切片&quot; class=&quot;headerlink&quot; title=&quot;切片&quot;&gt;&lt;/a&gt;切片&lt;/h1&gt;&lt;p&gt;切片操作十分有用。我们先创建一个0-99的数列：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;t</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/python%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/03/26/python%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-26T10:19:45.429Z</published>
    <updated>2021-03-26T04:22:10.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输出-print"><a href="#输出-print" class="headerlink" title="输出 print()"></a>输出 print()</h2><p>​    在括号上加字符串可在屏幕输出文字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    逗号“,”隔开，就可以连成一串输出，遇到逗号“,”会输出一个空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;小菜鸡&#x27;</span>, <span class="string">&#x27;每天&#x27;</span>, <span class="string">&#x27;困困&#x27;</span>)</span><br></pre></td></tr></table></figure><p>​    print(‘原样输出的字符’,变量)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;100 + 200 =&#x27;</span>, <span class="number">100</span> + <span class="number">200</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello,&#x27;</span>, name)</span><br></pre></td></tr></table></figure><h2 id="输入-input"><a href="#输入-input" class="headerlink" title="输入 input()"></a>输入 input()</h2><p>用户输入字符串，并存放到一个<strong>变量</strong>里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>()</span><br></pre></td></tr></table></figure><p>​    input(‘提示输入信息’)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name &#x3D; input(&#39;please enter your name: &#39;)</span><br><span class="line">print(&#39;hello,&#39;, name)</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(&#39;&#39;&#39;叭叭叭</span><br><span class="line">啦啦啦</span><br><span class="line">喵喵喵&#39;&#39;&#39;)</span><br></pre></td></tr></table></figure><h2 id="或-与-非"><a href="#或-与-非" class="headerlink" title="或 与 非"></a>或 与 非</h2><p><strong>and</strong> 都为真才为真</p><p><strong>or</strong> 一个为真则为真</p><p><strong>not</strong> 真变假，假变真</p><h2 id="空值-None"><a href="#空值-None" class="headerlink" title="空值 None"></a>空值 None</h2><p>None不为0，0是有意义的</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p><strong>全部大写的变量名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI &#x3D; 3.14159265359</span><br></pre></td></tr></table></figure><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>python拥有两种除法</p><p><strong>结果为浮点数 /</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 &#x2F; 3</span><br><span class="line">3.3333333333333335</span><br></pre></td></tr></table></figure><p><strong>结果为整数   //</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 &#x2F;&#x2F; 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>取余</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 % 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>​    <code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ord(&#39;A&#39;)</span><br><span class="line">65</span><br><span class="line">&gt;&gt;&gt; ord(&#39;中&#39;)</span><br><span class="line">20013</span><br><span class="line">&gt;&gt;&gt; chr(66)</span><br><span class="line">&#39;B&#39;</span><br><span class="line">&gt;&gt;&gt; chr(25991)</span><br><span class="line">&#39;文&#39;</span><br></pre></td></tr></table></figure><p>​    Python的字符串类型是<code>str</code></p><p>​    网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code></p><p>​    Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; b&#39;ABC&#39;</span><br></pre></td></tr></table></figure><p>​    以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code></p><p>​    含有中文的<code>str</code>无法用<code>ASCII</code>编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;ABC&#39;.encode(&#39;ascii&#39;)</span><br><span class="line">b&#39;ABC&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;中文&#39;.encode(&#39;utf-8&#39;)</span><br><span class="line">b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;中文&#39;.encode(&#39;ascii&#39;)</span><br></pre></td></tr></table></figure><p>​    把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b&#39;ABC&#39;.decode(&#39;ascii&#39;)</span><br><span class="line">&#39;ABC&#39;</span><br><span class="line">&gt;&gt;&gt; b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;)</span><br><span class="line">&#39;中文&#39;</span><br></pre></td></tr></table></figure><p>​    如果<code>bytes</code>中只有一小部分无效的字节，可以传入<code>errors=&#39;ignore&#39;</code>忽略错误的字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors&#x3D;&#39;ignore&#39;)</span><br><span class="line">&#39;中&#39;</span><br></pre></td></tr></table></figure><p><strong>计算字符长度<code>len()</code></strong></p><p>​    lin()计算<code>str</code>的字符数，<code>bytes</code>的字节数</p><p>1个中文字符经过UTF-8编码后通常会占用3个字节</p><h4 id="在文件头加"><a href="#在文件头加" class="headerlink" title="在文件头加"></a>在文件头加</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串  %"></a>格式化字符串  %</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;Hi, %s, you have $%d.&#39; % (&#39;Michael&#39;, 1000000)</span><br></pre></td></tr></table></figure><h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><table><thead><tr><th align="left">占位符</th><th align="left">替换内容</th></tr></thead><tbody><tr><td align="left">%d</td><td align="left">整数</td></tr><tr><td align="left">%f</td><td align="left">浮点数</td></tr><tr><td align="left">%s</td><td align="left">字符串</td></tr><tr><td align="left">%x</td><td align="left">十六进制整数</td></tr></tbody></table><p>​    不确定类型使用，<code>%s</code>永远起作用，它会把任何数据类型转换为字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Age: %s. Gender: %s&#39; % (25, True)</span><br><span class="line">&#39;Age: 25. Gender: True&#39;</span><br></pre></td></tr></table></figure><p>​    字符串里面的<code>%</code>是一个普通字符,用<code>%%</code>来表示一个<code>%</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;growth rate: %d %%&#39; % 7</span><br><span class="line">&#39;growth rate: 7 %&#39;</span><br></pre></td></tr></table></figure><h2 id="格式化字符串-format"><a href="#格式化字符串-format" class="headerlink" title="格式化字符串  format()"></a>格式化字符串  format()</h2><p>​    传入的参数<strong>依次</strong>替换字符串内的占位符<code>&#123;0&#125;</code>、<code>&#123;1&#125;</code>……</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#39;.format(&#39;小明&#39;, 17.125)</span><br><span class="line">&#39;Hello, 小明, 成绩提升了 17.1%&#39;</span><br></pre></td></tr></table></figure><h2 id="格式化字符串-f-string"><a href="#格式化字符串-f-string" class="headerlink" title="格式化字符串  f-string"></a>格式化字符串  f-string</h2><p>​    字符串如果包含<code>&#123;xxx&#125;</code>，就会以对应的变量替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; r &#x3D; 2.5</span><br><span class="line">&gt;&gt;&gt; s &#x3D; 3.14 * r ** 2</span><br><span class="line">&gt;&gt;&gt; print(f&#39;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#39;)</span><br><span class="line">The area of a circle with radius 2.5 is 19.62</span><br></pre></td></tr></table></figure><p>​    <code>&#123;r&#125;</code>被变量<code>r</code>的值替换，<code>&#123;s:.2f&#125;</code>被变量<code>s</code>的值替换，并且<code>:</code>后面的<code>.2f</code>指定了格式化参数（即保留两位小数），因此，<code>&#123;s:.2f&#125;</code>的替换结果是<code>19.62</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;输出-print&quot;&gt;&lt;a href=&quot;#输出-print&quot; class=&quot;headerlink&quot; title=&quot;输出 print()&quot;&gt;&lt;/a&gt;输出 print()&lt;/h2&gt;&lt;p&gt;​    在括号上加字符串可在屏幕输出文字&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/03/25/hello-world/"/>
    <id>http://example.com/2021/03/25/hello-world/</id>
    <published>2021-03-24T16:12:35.319Z</published>
    <updated>2021-03-24T16:12:35.319Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
